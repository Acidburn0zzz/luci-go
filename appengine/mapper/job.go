// Copyright 2018 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mapper

import (
	"context"
	"time"

	"go.chromium.org/gae/service/datastore"
	"go.chromium.org/luci/common/errors"
	"go.chromium.org/luci/common/retry/transient"

	"go.chromium.org/luci/appengine/mapper/splitter"
)

// Query is a representation of datastore queries supported by the
// mapper.
//
// A query defines a set of entities the mapper operates on.
//
// This struct can be embedded into entities as is.
type Query struct {
	Kind     string         // entity kind to limit the query, "" for kindless
	Ancestor *datastore.Key // entity group to limit the query to (or nil)
}

// ToDatastoreQuery returns corresponding datastore.Query.
func (q *Query) ToDatastoreQuery() *datastore.Query {
	dq := datastore.NewQuery(q.Kind)
	if q.Ancestor != nil {
		dq = dq.Ancestor(q.Ancestor)
	}
	return dq
}

// JobConfig defines what a new mapping job should do.
//
// It should be supplied by the users of the mapper library.
type JobConfig struct {
	Query      Query  // a query identifying a set of entities
	Mapper     ID     // ID of a registered mapper to apply to entities
	Params     Params // JSON-serializable parameters for the mapper
	ShardCount int    // number of shards to split the key range into
	PageSize   int    // how many entities to process at once in each shard
}

// Validate returns an error of the config is invalid.
//
// Mapper existence is not checked.
func (jc *JobConfig) Validate() error {
	switch {
	case jc.ShardCount < 1:
		return errors.Reason("ShardCount should be >= 1, try 8").Err()
	case jc.PageSize <= 0:
		return errors.Reason("PageSize should be > 0, try 256").Err()
	}
	return nil
}

// JobState defines a state of a mapping job.
type JobState int

const (
	JobStateUnknown  JobState = iota // should not really be seen anywhere
	JobStateStarting                 // tq task to start the job is enqueued
	JobStateRunning                  // all shards initiated and running now
)

// JobID identifies a mapping job.
type JobID int64

// Job is datastore representation of a mapping job (either active or not).
//
// It is a root entity with autogenerated key.
type Job struct {
	_kind  string                `gae:"$kind,mapper.Job"`
	_extra datastore.PropertyMap `gae:"-,extra"`

	// ID is auto-generated unique identifier of the job.
	ID JobID `gae:"$id"`
	// Config is the configuration of this job. Doesn't change once set.
	Config JobConfig `gae:",noindex"`
	// State is used to track job's lifecycle, see the enum.
	State JobState
	// Created is when the job was created, FYI.
	Created time.Time
	// Updated is when the job was last touched, FYI.
	Updated time.Time
}

// shardList is an entity with a list of shard IDs associated with a job.
//
// A "static" singleton child entity of Job. Stored separately to allow callers
// to skip loading (potentially huge) list of shards if they are not interested
// in it.
type shardList struct {
	_kind  string                `gae:"$kind,mapper.ShardList"`
	_id    int64                 `gae:"$id,1"`
	_extra datastore.PropertyMap `gae:"-,extra"`

	Parent *datastore.Key `gae:"$parent"`
	Shards []int64        `gae:",noindex"`
}

// fetchShardIDs fetches IDs of the job shards.
func (j *Job) fetchShardIDs(c context.Context) ([]int64, error) {
	l := shardList{Parent: datastore.KeyForObj(c, j)}
	switch err := datastore.Get(c, &l); {
	case err == datastore.ErrNoSuchEntity:
		return nil, errors.Annotate(err, "broken state, no ShardList entity for job %d", j.ID).Err()
	case err != nil:
		return nil, errors.Annotate(err, "when fetching list of shards of job %d", j.ID).Tag(transient.Tag).Err()
	default:
		return l.Shards, nil
	}
}

// fetchShards fetches all job shards.
func (j *Job) fetchShards(c context.Context) ([]shard, error) {
	ids, err := j.fetchShardIDs(c)
	if err != nil {
		return nil, err
	}

	shards := make([]shard, len(ids))
	for idx, sid := range ids {
		shards[idx].ID = sid
	}

	if err := datastore.Get(c, shards); err != nil {
		return nil, errors.Annotate(err, "failed to fetch some shards of job %d", j.ID).Tag(transient.Tag).Err()
	}
	return shards, nil
}

// shardState defines a state of one mapping shard.
type shardState int

const (
	shardStateUnknown  shardState = iota // should not really be seen anywhere
	shardStateStarting                   // the shard was just created
)

// shard represents a key range being worked on by a single worker (Start, End].
//
// Shard entities are written to when workers checkpoint progress or finish.
// They are read when calculating overall progress of the job.
//
// It is a root entity with autogenerated key. Shards are associated with jobs
// via ShardList entity (owned by Job, for Job -> [Shard] queries), and via
// JobID property (for Shard -> Job queries). They are purposefully not a part
// of Job entity group, to avoid exceeding O(1) entity group write limit.
type shard struct {
	_kind  string                `gae:"$kind,mapper.Shard"`
	_extra datastore.PropertyMap `gae:"-,extra"`

	// ID is auto-generated unique identifier of the shard.
	ID int64 `gae:"$id"`
	// JobID is ID of a job that owns this shard.
	JobID JobID
	// Index is the index of the shard in the job's shards list.
	Index int `gae:",noindex"`
	// State is used to track shard's lifecycle, see the enum.
	State shardState
	// Range is an entity key range covered by this shard.
	Range splitter.Range `gae:",noindex"`
	// Created is when the shard was created, FYI.
	Created time.Time
	// Updated is when the shard was last touched, FYI.
	Updated time.Time

	// TODO: Resumption point.
}
