// Copyright 2018 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mapper

import (
	"context"
	"fmt"
	"time"

	"go.chromium.org/gae/service/datastore"
	"go.chromium.org/luci/common/clock"
	"go.chromium.org/luci/common/errors"
	"go.chromium.org/luci/common/logging"
	"go.chromium.org/luci/common/retry/transient"

	"go.chromium.org/luci/appengine/mapper/splitter"
)

// Query is a representation of datastore queries supported by the
// mapper.
//
// A query defines a set of entities the mapper operates on.
//
// This struct can be embedded into entities as is.
type Query struct {
	Kind     string         // entity kind to limit the query, "" for kindless
	Ancestor *datastore.Key // entity group to limit the query to (or nil)
}

// ToDatastoreQuery returns corresponding datastore.Query.
func (q *Query) ToDatastoreQuery() *datastore.Query {
	dq := datastore.NewQuery(q.Kind)
	if q.Ancestor != nil {
		dq = dq.Ancestor(q.Ancestor)
	}
	return dq
}

// JobConfig defines what a new mapping job should do.
//
// It should be supplied by the users of the mapper library.
type JobConfig struct {
	Query      Query  // a query identifying a set of entities
	Mapper     ID     // ID of a registered mapper to apply to entities
	Params     Params // JSON-serializable parameters for the mapper
	ShardCount int    // number of shards to split the key range into
	PageSize   int    // how many entities to process at once in each shard

	// Optional parameters below for fine tunning. They have reasonable defaults,
	// and should generally be not touched.

	PagesPerTask int           // how many pages to process inside a TQ task, default unlimited
	TaskDuration time.Duration // how long to run a single mapping TQ task, default 1 min
}

// Validate returns an error of the config is invalid.
//
// Mapper existence is not checked.
func (jc *JobConfig) Validate() error {
	switch {
	case jc.ShardCount < 1:
		return errors.Reason("ShardCount should be >= 1, try 8").Err()
	case jc.PageSize <= 0:
		return errors.Reason("PageSize should be > 0, try 256").Err()
	case jc.PagesPerTask < 0:
		return errors.Reason("PagesPerTask should be >= 0, keep 0 for default").Err()
	case jc.TaskDuration < 0:
		return errors.Reason("TaskDuration should be >= 0, keep 0 for default").Err()
	}
	return nil
}

// JobState defines a state of a mapping job.
type JobState int

const (
	JobStateUnknown  JobState = iota // should not really be seen anywhere
	JobStateStarting                 // tq task to start the job is enqueued
	JobStateRunning                  // all shards initiated and running now
	JobStateSuccess                  // all shards have succeeded
	JobStateFail                     // some shards have failed
)

func (js JobState) String() string {
	switch js {
	case JobStateUnknown:
		return "JobStateUnknown"
	case JobStateStarting:
		return "JobStateStarting"
	case JobStateRunning:
		return "JobStateRunning"
	case JobStateSuccess:
		return "JobStateSuccess"
	case JobStateFail:
		return "JobStateFail"
	default:
		return fmt.Sprintf("JobState_%d", js)
	}
}

// JobID identifies a mapping job.
type JobID int64

// Job is datastore representation of a mapping job (either active or not).
//
// It is a root entity with autogenerated key.
type Job struct {
	_kind  string                `gae:"$kind,mapper.Job"`
	_extra datastore.PropertyMap `gae:"-,extra"`

	// ID is auto-generated unique identifier of the job.
	ID JobID `gae:"$id"`
	// Config is the configuration of this job. Doesn't change once set.
	Config JobConfig `gae:",noindex"`
	// State is used to track job's lifecycle, see the enum.
	State JobState
	// Created is when the job was created, FYI.
	Created time.Time
	// Updated is when the job was last touched, FYI.
	Updated time.Time
}

// shardList is an entity with a list of shard IDs associated with a job.
//
// A "static" singleton child entity of Job. Stored separately to allow callers
// to skip loading (potentially huge) list of shards if they are not interested
// in it.
type shardList struct {
	_kind  string                `gae:"$kind,mapper.ShardList"`
	_id    int64                 `gae:"$id,1"`
	_extra datastore.PropertyMap `gae:"-,extra"`

	Parent *datastore.Key `gae:"$parent"`
	Shards []int64        `gae:",noindex"`
}

// fetchShardIDs fetches IDs of the job shards.
func (j *Job) fetchShardIDs(c context.Context) ([]int64, error) {
	l := shardList{Parent: datastore.KeyForObj(c, j)}
	switch err := datastore.Get(c, &l); {
	case err == datastore.ErrNoSuchEntity:
		return nil, errors.Annotate(err, "broken state, no ShardList entity for job %d", j.ID).Err()
	case err != nil:
		return nil, errors.Annotate(err, "when fetching list of shards of job %d", j.ID).Tag(transient.Tag).Err()
	default:
		return l.Shards, nil
	}
}

// fetchShards fetches all job shards.
func (j *Job) fetchShards(c context.Context) ([]shard, error) {
	ids, err := j.fetchShardIDs(c)
	if err != nil {
		return nil, err
	}

	shards := make([]shard, len(ids))
	for idx, sid := range ids {
		shards[idx].ID = sid
	}

	if err := datastore.Get(c, shards); err != nil {
		return nil, errors.Annotate(err, "failed to fetch some shards of job %d", j.ID).Tag(transient.Tag).Err()
	}
	return shards, nil
}

// getJob fetches a Job entity.
//
// Recognizes and tags transient errors.
func getJob(c context.Context, id JobID) (*Job, error) {
	job := &Job{ID: id}
	switch err := datastore.Get(c, job); {
	case err == datastore.ErrNoSuchEntity:
		return nil, errors.Reason("no mapping job with ID %d", id).Err()
	case err != nil:
		return nil, errors.Annotate(err, "failed to fetch Job entity with ID %d", id).Tag(transient.Tag).Err()
	default:
		return job, nil
	}
}

// getJobInState fetches a Job entity and checks its state.
//
// Returns:
//   (*Job, nil) if the job is there and its state matches 'state'.
//   (nil, nil) if the job is there, but in a different state.
//   (nil, transient error) on datastore fetch errors.
//   (nil, fatal error) if there's no such job at all.
func getJobInState(c context.Context, id JobID, state JobState) (*Job, error) {
	switch job, err := getJob(c, id); {
	case err != nil:
		return nil, err
	case job.State != state:
		logging.Warningf(c, "Skipping the job: its state is %s, expecting %s", job.State, state)
		return nil, nil
	default:
		return job, nil
	}
}

// shardState defines a state of one mapping shard.
type shardState int

const (
	shardStateUnknown  shardState = iota // should not really be seen anywhere
	shardStateStarting                   // the shard was just created
	shardStateRunning                    // some work (but not all) has been done
	shardStateSuccess                    // finished successfully
	shardStateFail                       // failed (perhaps midway)
)

func (ss shardState) isFinal() bool {
	return ss == shardStateSuccess || ss == shardStateFail
}

func (ss shardState) String() string {
	switch ss {
	case shardStateUnknown:
		return "shardStateUnknown"
	case shardStateStarting:
		return "shardStateStarting"
	case shardStateRunning:
		return "shardStateRunning"
	case shardStateSuccess:
		return "shardStateSuccess"
	case shardStateFail:
		return "shardStateFail"
	default:
		return fmt.Sprintf("shardState_%d", ss)
	}
}

// shard represents a key range being worked on by a single worker (Start, End].
//
// Shard entities are written to when workers checkpoint progress or finish.
// They are read when calculating overall progress of the job.
//
// It is a root entity with autogenerated key. Shards are associated with jobs
// via ShardList entity (owned by Job, for Job -> [Shard] queries), and via
// JobID property (for Shard -> Job queries). They are purposefully not a part
// of Job entity group, to avoid exceeding O(1) entity group write limit.
type shard struct {
	_kind  string                `gae:"$kind,mapper.Shard"`
	_extra datastore.PropertyMap `gae:"-,extra"`

	// ID is auto-generated unique identifier of the shard.
	ID int64 `gae:"$id"`
	// JobID is ID of a job that owns this shard.
	JobID JobID
	// Index is the index of the shard in the job's shards list.
	Index int `gae:",noindex"`
	// State is used to track shard's lifecycle, see the enum.
	State shardState
	// Error is an error message for failed shards.
	Error string `gae:",noindex"`
	// ProcessTaskNum is next expected ProcessShard task number.
	ProcessTaskNum int64 `gae:",noindex"`
	// Range is an entity key range covered by this shard.
	Range splitter.Range `gae:",noindex"`
	// ResumeFrom is the last processed key or nil if just starting.
	ResumeFrom *datastore.Key `gae:",noindex"`
	// Created is when the shard was created, FYI.
	Created time.Time
	// Updated is when the shard was last touched, FYI.
	Updated time.Time
}

// getActiveShard returns shard entity with given ID if its still in active
// state and its ProcessTaskNum matches the given taskNum.
//
// Returns:
//   (*shard, nil) if the shard is there and matches the criteria.
//   (nil, nil) if the shard is there, but it doesn't match the criteria.
//   (nil, transient error) on datastore fetch errors.
//   (nil, fatal error) if there's no such shard at all.
func getActiveShard(c context.Context, shardID, taskNum int64) (*shard, error) {
	sh := &shard{ID: shardID}
	switch err := datastore.Get(c, sh); {
	case err == datastore.ErrNoSuchEntity:
		return nil, errors.Annotate(err, "no such shard, aborting").Err() // fatal, no retries
	case err != nil:
		return nil, errors.Annotate(err, "failed to fetch the shard").Tag(transient.Tag).Err()
	case sh.State.isFinal():
		logging.Warningf(c, "The shard is finished already")
		return nil, nil
	case sh.ProcessTaskNum != taskNum:
		logging.Warningf(c, "The task is stale (shard's task_num is %d, but task's is %d). Skipping it", sh.ProcessTaskNum, taskNum)
		return nil, nil
	default:
		return sh, nil
	}
}

// shardTxnCb examines and optionally mutates the shard.
//
// It returns (true, nil) to instruct shardTxn to store the shard, (false, nil)
// to skip storing, and (..., err) to return the error.
type shardTxnCb func(c context.Context, sh *shard) (save bool, err error)

// shardTxn fetches the shard and calls the callback to examine or mutate it.
//
// Silently skips finished shards.
func shardTxn(c context.Context, shardID int64, cb shardTxnCb) error {
	return runTxn(c, func(c context.Context) error {
		sh := shard{ID: shardID}
		switch err := datastore.Get(c, &sh); {
		case err == datastore.ErrNoSuchEntity:
			return err
		case err != nil:
			return transient.Tag.Apply(err)
		case sh.State.isFinal():
			return nil // the shard is already marked as done
		}
		switch save, err := cb(c, &sh); {
		case err != nil:
			return err
		case !save:
			return nil
		default:
			sh.Updated = clock.Now(c).UTC()
			return transient.Tag.Apply(datastore.Put(c, &sh))
		}
	})
}
