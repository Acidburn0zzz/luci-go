// Code generated by protoc-gen-go.
// source: github.com/luci/luci-go/dm/api/service/v1/activate_execution.proto
// DO NOT EDIT!

/*
Package dm is a generated protocol buffer package.

It is generated from these files:
	github.com/luci/luci-go/dm/api/service/v1/activate_execution.proto
	github.com/luci/luci-go/dm/api/service/v1/ensure_graph_data.proto
	github.com/luci/luci-go/dm/api/service/v1/finish_attempt.proto
	github.com/luci/luci-go/dm/api/service/v1/graph_data.proto
	github.com/luci/luci-go/dm/api/service/v1/graph_query.proto
	github.com/luci/luci-go/dm/api/service/v1/service.proto
	github.com/luci/luci-go/dm/api/service/v1/types.proto
	github.com/luci/luci-go/dm/api/service/v1/walk_graph.proto

It has these top-level messages:
	ActivateExecutionReq
	TemplateInstantiation
	EnsureGraphDataReq
	EnsureGraphDataRsp
	FinishAttemptReq
	AbnormalFinish
	Quest
	JsonResult
	Result
	Attempt
	Execution
	GraphData
	GraphQuery
	MultiPropertyValue
	PropertyValue
	AttemptList
	WalkGraphReq
*/
package dm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ActivateExecutionReq allows a currently-running Execution to activate itself.
// Doing this allows DM to know that the Execution has started, and also enables
// the Execution to access other APIs like WalkGraph, AddDeps, and
// FinishAttempt.
//
// ActivateExecution must be called with the ExecutionID and Activation token
// that DM provided when the Execution was started with the distributor.
//
// If the Execution has not been activated, the Execution will be marked as
// 'activating' and this will return an OK code. At this point, your client
// may use the ExecutionToken with any RPCs that have an ExecutionAuth field.
//
// This RPC may return:
//   * OK - The Execution is now activated.
//   * InvalidArgmument - The request was malformed. Retrying will not help.
//   * PermissionDenied - The provided activation token was incorrect.
//     Retrying will not help.
//   * AlreadyExists - The activation token was correct, but some other entity
//     already activated this Execution. The client should cease operations.
//     Retrying will not help.
//
// All other errors should be retried with the exact same ActivateExecutionReq
// data.
type ActivateExecutionReq struct {
	// Auth is the Execution_Auth containing the Activation Token, as provided
	// to the distributor when the Execution was created.
	Auth *Execution_Auth `protobuf:"bytes,1,opt,name=auth" json:"auth,omitempty"`
	// ExecutionToken should be randomly generated by the machine running the
	// execution, or by the distributor service such that if two racing Executions
	// both attempt to Activate with the same ExecutionID and ActivationToken, the
	// ExecutionToken will (probably) be different for them so that only one will
	// win.
	ExecutionToken []byte `protobuf:"bytes,2,opt,name=execution_token,json=executionToken,proto3" json:"execution_token,omitempty"`
}

func (m *ActivateExecutionReq) Reset()                    { *m = ActivateExecutionReq{} }
func (m *ActivateExecutionReq) String() string            { return proto.CompactTextString(m) }
func (*ActivateExecutionReq) ProtoMessage()               {}
func (*ActivateExecutionReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ActivateExecutionReq) GetAuth() *Execution_Auth {
	if m != nil {
		return m.Auth
	}
	return nil
}

func init() {
	proto.RegisterType((*ActivateExecutionReq)(nil), "dm.ActivateExecutionReq")
}

func init() {
	proto.RegisterFile("github.com/luci/luci-go/dm/api/service/v1/activate_execution.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 180 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0x72, 0x4a, 0xcf, 0x2c, 0xc9,
	0x28, 0x4d, 0xd2, 0x4b, 0xce, 0xcf, 0xd5, 0xcf, 0x29, 0x4d, 0xce, 0x04, 0x13, 0xba, 0xe9, 0xf9,
	0xfa, 0x29, 0xb9, 0xfa, 0x89, 0x05, 0x99, 0xfa, 0xc5, 0xa9, 0x45, 0x65, 0x99, 0xc9, 0xa9, 0xfa,
	0x65, 0x86, 0xfa, 0x89, 0xc9, 0x25, 0x99, 0x65, 0x89, 0x25, 0xa9, 0xf1, 0xa9, 0x15, 0xa9, 0xc9,
	0xa5, 0x25, 0x99, 0xf9, 0x79, 0x7a, 0x05, 0x45, 0xf9, 0x25, 0xf9, 0x42, 0x4c, 0x29, 0xb9, 0x52,
	0x56, 0xc4, 0x9b, 0x93, 0x5e, 0x94, 0x58, 0x90, 0x11, 0x9f, 0x92, 0x58, 0x92, 0x08, 0xd1, 0xaf,
	0x94, 0xce, 0x25, 0xe2, 0x08, 0x35, 0xdb, 0x15, 0x66, 0x74, 0x50, 0x6a, 0xa1, 0x90, 0x1a, 0x17,
	0x4b, 0x62, 0x69, 0x49, 0x86, 0x04, 0xa3, 0x02, 0xa3, 0x06, 0xb7, 0x91, 0x90, 0x5e, 0x4a, 0xae,
	0x1e, 0x5c, 0x5e, 0xcf, 0x11, 0x28, 0x13, 0x04, 0x96, 0x17, 0x52, 0xe7, 0xe2, 0x87, 0x3b, 0x29,
	0xbe, 0x24, 0x3f, 0x3b, 0x35, 0x4f, 0x82, 0x09, 0xa8, 0x85, 0x27, 0x88, 0x0f, 0x2e, 0x1c, 0x02,
	0x12, 0x4d, 0x62, 0x03, 0xdb, 0x67, 0x0c, 0x08, 0x00, 0x00, 0xff, 0xff, 0x1c, 0x8e, 0x98, 0x28,
	0xf5, 0x00, 0x00, 0x00,
}
