// Code generated by protoc-gen-go.
// source: github.com/luci/luci-go/tokenserver/api/minter/v1/token_minter.proto
// DO NOT EDIT!

/*
Package minter is a generated protocol buffer package.

It is generated from these files:
	github.com/luci/luci-go/tokenserver/api/minter/v1/token_minter.proto

It has these top-level messages:
	MintMachineTokenRequest
	MachineTokenRequest
	MintMachineTokenResponse
	MachineTokenResponse
	LuciMachineToken
	InspectMachineTokenRequest
	InspectMachineTokenResponse
	MintDelegationTokenRequest
	MintDelegationTokenResponse
*/
package minter

import prpc "github.com/luci/luci-go/grpc/prpc"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/luci/luci-go/common/proto/google"
import messages "github.com/luci/luci-go/server/auth/delegation/messages"
import tokenserver "github.com/luci/luci-go/tokenserver/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The kinds of machine tokens the token server can mint.
//
// Passed to MintMachineToken.
//
// Reserved: 1.
type MachineTokenType int32

const (
	MachineTokenType_UNKNOWN_TYPE       MachineTokenType = 0
	MachineTokenType_LUCI_MACHINE_TOKEN MachineTokenType = 2
)

var MachineTokenType_name = map[int32]string{
	0: "UNKNOWN_TYPE",
	2: "LUCI_MACHINE_TOKEN",
}
var MachineTokenType_value = map[string]int32{
	"UNKNOWN_TYPE":       0,
	"LUCI_MACHINE_TOKEN": 2,
}

func (x MachineTokenType) String() string {
	return proto.EnumName(MachineTokenType_name, int32(x))
}
func (MachineTokenType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Supported ways of singing the request.
type SignatureAlgorithm int32

const (
	SignatureAlgorithm_UNKNOWN_ALGO    SignatureAlgorithm = 0
	SignatureAlgorithm_SHA256_RSA_ALGO SignatureAlgorithm = 1
)

var SignatureAlgorithm_name = map[int32]string{
	0: "UNKNOWN_ALGO",
	1: "SHA256_RSA_ALGO",
}
var SignatureAlgorithm_value = map[string]int32{
	"UNKNOWN_ALGO":    0,
	"SHA256_RSA_ALGO": 1,
}

func (x SignatureAlgorithm) String() string {
	return proto.EnumName(SignatureAlgorithm_name, int32(x))
}
func (SignatureAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Possible kinds of fatal errors.
//
// Non fatal errors are returned as grpc.Internal errors instead.
type ErrorCode int32

const (
	ErrorCode_SUCCESS                     ErrorCode = 0
	ErrorCode_UNSUPPORTED_SIGNATURE       ErrorCode = 1
	ErrorCode_UNSUPPORTED_TOKEN_TYPE      ErrorCode = 2
	ErrorCode_BAD_TIMESTAMP               ErrorCode = 3
	ErrorCode_BAD_CERTIFICATE_FORMAT      ErrorCode = 4
	ErrorCode_BAD_SIGNATURE               ErrorCode = 5
	ErrorCode_UNTRUSTED_CERTIFICATE       ErrorCode = 6
	ErrorCode_BAD_TOKEN_ARGUMENTS         ErrorCode = 7
	ErrorCode_MACHINE_TOKEN_MINTING_ERROR ErrorCode = 8
)

var ErrorCode_name = map[int32]string{
	0: "SUCCESS",
	1: "UNSUPPORTED_SIGNATURE",
	2: "UNSUPPORTED_TOKEN_TYPE",
	3: "BAD_TIMESTAMP",
	4: "BAD_CERTIFICATE_FORMAT",
	5: "BAD_SIGNATURE",
	6: "UNTRUSTED_CERTIFICATE",
	7: "BAD_TOKEN_ARGUMENTS",
	8: "MACHINE_TOKEN_MINTING_ERROR",
}
var ErrorCode_value = map[string]int32{
	"SUCCESS":                     0,
	"UNSUPPORTED_SIGNATURE":       1,
	"UNSUPPORTED_TOKEN_TYPE":      2,
	"BAD_TIMESTAMP":               3,
	"BAD_CERTIFICATE_FORMAT":      4,
	"BAD_SIGNATURE":               5,
	"UNTRUSTED_CERTIFICATE":       6,
	"BAD_TOKEN_ARGUMENTS":         7,
	"MACHINE_TOKEN_MINTING_ERROR": 8,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}
func (ErrorCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// MintMachineTokenRequest wraps a serialized and signed MachineTokenRequest
// message.
type MintMachineTokenRequest struct {
	// The protobuf-serialized MachineTokenRequest message, signed by the private
	// key that matches MachineTokenRequest.certificate.
	//
	// We have to send it as a byte blob to avoid dealing with possible protobuf
	// serialization inconsistencies when checking the signature.
	SerializedTokenRequest []byte `protobuf:"bytes,1,opt,name=serialized_token_request,json=serializedTokenRequest,proto3" json:"serialized_token_request,omitempty"`
	// The signature of 'serialized_token_parameters' blob.
	//
	// See MachineTokenRequest.signature_algorithm for exact meaning.
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *MintMachineTokenRequest) Reset()                    { *m = MintMachineTokenRequest{} }
func (m *MintMachineTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*MintMachineTokenRequest) ProtoMessage()               {}
func (*MintMachineTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// MachineTokenRequest contains the actual request parameters.
type MachineTokenRequest struct {
	// The certificate that identifies a caller (as ASN1-serialized blob).
	//
	// It will be used to extract machine FQDN (it's CN of the cert) and CA name
	// to use to check the cert.
	Certificate []byte `protobuf:"bytes,1,opt,name=certificate,proto3" json:"certificate,omitempty"`
	// The signature algorithm used to sign this request.
	//
	// Defines what's in MintMachineTokenRequest.signature field.
	SignatureAlgorithm SignatureAlgorithm `protobuf:"varint,2,opt,name=signature_algorithm,json=signatureAlgorithm,enum=tokenserver.minter.SignatureAlgorithm" json:"signature_algorithm,omitempty"`
	// Timestamp when this request was created, by the issuer clock.
	IssuedAt *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=issued_at,json=issuedAt" json:"issued_at,omitempty"`
	// The token type being requested.
	//
	// Defines what fields of the response are set.
	TokenType MachineTokenType `protobuf:"varint,4,opt,name=token_type,json=tokenType,enum=tokenserver.minter.MachineTokenType" json:"token_type,omitempty"`
}

func (m *MachineTokenRequest) Reset()                    { *m = MachineTokenRequest{} }
func (m *MachineTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*MachineTokenRequest) ProtoMessage()               {}
func (*MachineTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *MachineTokenRequest) GetIssuedAt() *google_protobuf.Timestamp {
	if m != nil {
		return m.IssuedAt
	}
	return nil
}

// MintMachineTokenResponse is returned by 'MintMachineToken' if the server
// processed the request.
//
// It's returned even if server refuses to mint a token. It contains the error
// details in that case.
type MintMachineTokenResponse struct {
	// Possible kinds of fatal errors.
	//
	// Non fatal errors are returned as grpc.Internal errors instead.
	ErrorCode ErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,enum=tokenserver.minter.ErrorCode" json:"error_code,omitempty"`
	// Optional detailed error message.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	// On success (SUCCESS error code) contains the produced token.
	TokenResponse *MachineTokenResponse `protobuf:"bytes,3,opt,name=token_response,json=tokenResponse" json:"token_response,omitempty"`
	// Identifier of the service and its version that produced the response.
	//
	// Set for both successful responses and errors. On success, it is identical
	// to token_response.service_version.
	ServiceVersion string `protobuf:"bytes,4,opt,name=service_version,json=serviceVersion" json:"service_version,omitempty"`
}

func (m *MintMachineTokenResponse) Reset()                    { *m = MintMachineTokenResponse{} }
func (m *MintMachineTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*MintMachineTokenResponse) ProtoMessage()               {}
func (*MintMachineTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *MintMachineTokenResponse) GetTokenResponse() *MachineTokenResponse {
	if m != nil {
		return m.TokenResponse
	}
	return nil
}

// MachineTokenResponse contains a token requested by MachineTokenRequest.
type MachineTokenResponse struct {
	// Identifier of the service and its version that produced the token.
	//
	// Has the form "<app-id>/<module-version>". Reported to the monitoring by
	// the client. This is _not_ a part of the token.
	ServiceVersion string `protobuf:"bytes,2,opt,name=service_version,json=serviceVersion" json:"service_version,omitempty"`
	// The generated token.
	//
	// The exact field set here depends on a requested type of the token, see
	// MachineTokenRequest.token_type.
	//
	// Types that are valid to be assigned to TokenType:
	//	*MachineTokenResponse_LuciMachineToken
	TokenType isMachineTokenResponse_TokenType `protobuf_oneof:"token_type"`
}

func (m *MachineTokenResponse) Reset()                    { *m = MachineTokenResponse{} }
func (m *MachineTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*MachineTokenResponse) ProtoMessage()               {}
func (*MachineTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isMachineTokenResponse_TokenType interface {
	isMachineTokenResponse_TokenType()
}

type MachineTokenResponse_LuciMachineToken struct {
	LuciMachineToken *LuciMachineToken `protobuf:"bytes,21,opt,name=luci_machine_token,json=luciMachineToken,oneof"`
}

func (*MachineTokenResponse_LuciMachineToken) isMachineTokenResponse_TokenType() {}

func (m *MachineTokenResponse) GetTokenType() isMachineTokenResponse_TokenType {
	if m != nil {
		return m.TokenType
	}
	return nil
}

func (m *MachineTokenResponse) GetLuciMachineToken() *LuciMachineToken {
	if x, ok := m.GetTokenType().(*MachineTokenResponse_LuciMachineToken); ok {
		return x.LuciMachineToken
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MachineTokenResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MachineTokenResponse_OneofMarshaler, _MachineTokenResponse_OneofUnmarshaler, _MachineTokenResponse_OneofSizer, []interface{}{
		(*MachineTokenResponse_LuciMachineToken)(nil),
	}
}

func _MachineTokenResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MachineTokenResponse)
	// token_type
	switch x := m.TokenType.(type) {
	case *MachineTokenResponse_LuciMachineToken:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LuciMachineToken); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MachineTokenResponse.TokenType has unexpected type %T", x)
	}
	return nil
}

func _MachineTokenResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MachineTokenResponse)
	switch tag {
	case 21: // token_type.luci_machine_token
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LuciMachineToken)
		err := b.DecodeMessage(msg)
		m.TokenType = &MachineTokenResponse_LuciMachineToken{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MachineTokenResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MachineTokenResponse)
	// token_type
	switch x := m.TokenType.(type) {
	case *MachineTokenResponse_LuciMachineToken:
		s := proto.Size(x.LuciMachineToken)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// LuciMachineToken is short lived machine token.
//
// It is understood only by LUCI backends. It is a bearer token, that embeds
// machine hostname and details about the machine certificate it was issued for.
// It has short lifetime (usually 1h).
//
// It is expected to be sent to backends in 'X-Luci-Machine-Token' HTTP header.
//
// The token here is supposed to be treated as an opaque base64-encoded blob,
// but in reality it is serialized MachineTokenEnvelope, see machine_token.proto
// and read the comment there for more info about the token format.
type LuciMachineToken struct {
	MachineToken string                     `protobuf:"bytes,1,opt,name=machine_token,json=machineToken" json:"machine_token,omitempty"`
	Expiry       *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=expiry" json:"expiry,omitempty"`
}

func (m *LuciMachineToken) Reset()                    { *m = LuciMachineToken{} }
func (m *LuciMachineToken) String() string            { return proto.CompactTextString(m) }
func (*LuciMachineToken) ProtoMessage()               {}
func (*LuciMachineToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *LuciMachineToken) GetExpiry() *google_protobuf.Timestamp {
	if m != nil {
		return m.Expiry
	}
	return nil
}

// InspectMachineTokenRequest is body of InspectMachineToken RPC call.
//
// It contains machine token of some kind.
type InspectMachineTokenRequest struct {
	// The type of token being checked.
	//
	// Currently only LUCI_MACHINE_TOKEN is supported. This is also the default.
	TokenType MachineTokenType `protobuf:"varint,1,opt,name=token_type,json=tokenType,enum=tokenserver.minter.MachineTokenType" json:"token_type,omitempty"`
	// The token body. Exact meaning depends on token_type.
	Token string `protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
}

func (m *InspectMachineTokenRequest) Reset()                    { *m = InspectMachineTokenRequest{} }
func (m *InspectMachineTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectMachineTokenRequest) ProtoMessage()               {}
func (*InspectMachineTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// InspectMachineTokenResponse is return value of InspectMachineToken RPC call.
type InspectMachineTokenResponse struct {
	// True if the token is valid.
	//
	// A token is valid if its signature is correct, it hasn't expired yet and
	// the credentials it was built from (e.g. a certificate) wasn't revoked.
	Valid bool `protobuf:"varint,1,opt,name=valid" json:"valid,omitempty"`
	// Human readable summary of why token is invalid.
	//
	// Summarizes the rest of the fields of this struct. Set only if 'valid' is
	// false.
	InvalidityReason string `protobuf:"bytes,2,opt,name=invalidity_reason,json=invalidityReason" json:"invalidity_reason,omitempty"`
	// True if the token signature was verified.
	//
	// It means the token was generated by the trusted server and its body is not
	// a garbage. Note that a token can be correctly signed, but invalid (if it
	// has expired or was revoked).
	//
	// If 'signed' is false, token_type below may (or may not) be a garbage.
	// The token server uses private keys managed by Google Cloud Platform, they
	// are constantly being rotated and "old" signatures become invalid over time
	// (when corresponding keys are rotated out of existence).
	//
	// If 'signed' is false, use the rest of the response only as FYI, possibly
	// invalid or even maliciously constructed.
	Signed bool `protobuf:"varint,3,opt,name=signed" json:"signed,omitempty"`
	// True if the token signature was verified and token hasn't expired yet.
	//
	// We use "non_" prefix to make default 'false' value safer.
	NonExpired bool `protobuf:"varint,45,opt,name=non_expired,json=nonExpired" json:"non_expired,omitempty"`
	// True if the token signature was verified and the token wasn't revoked.
	//
	// It is possible for an expired token to be non revoked. They are independent
	// properties.
	//
	// We use "non_" prefix to make default 'false' value safer.
	NonRevoked bool `protobuf:"varint,5,opt,name=non_revoked,json=nonRevoked" json:"non_revoked,omitempty"`
	// Id of a private key used to sign this token, if applicable.
	SigningKeyId string `protobuf:"bytes,6,opt,name=signing_key_id,json=signingKeyId" json:"signing_key_id,omitempty"`
	// Name of a CA that issued the cert the token is based on, if applicable.
	//
	// Resolved from 'ca_id' field of the token body.
	CertCaName string `protobuf:"bytes,7,opt,name=cert_ca_name,json=certCaName" json:"cert_ca_name,omitempty"`
	// The decoded token body (depends on token_type request parameter). Empty if
	// token was malformed and couldn't be deserialized.
	//
	// Types that are valid to be assigned to TokenType:
	//	*InspectMachineTokenResponse_LuciMachineToken
	TokenType isInspectMachineTokenResponse_TokenType `protobuf_oneof:"token_type"`
}

func (m *InspectMachineTokenResponse) Reset()                    { *m = InspectMachineTokenResponse{} }
func (m *InspectMachineTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*InspectMachineTokenResponse) ProtoMessage()               {}
func (*InspectMachineTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isInspectMachineTokenResponse_TokenType interface {
	isInspectMachineTokenResponse_TokenType()
}

type InspectMachineTokenResponse_LuciMachineToken struct {
	LuciMachineToken *tokenserver.MachineTokenBody `protobuf:"bytes,20,opt,name=luci_machine_token,json=luciMachineToken,oneof"`
}

func (*InspectMachineTokenResponse_LuciMachineToken) isInspectMachineTokenResponse_TokenType() {}

func (m *InspectMachineTokenResponse) GetTokenType() isInspectMachineTokenResponse_TokenType {
	if m != nil {
		return m.TokenType
	}
	return nil
}

func (m *InspectMachineTokenResponse) GetLuciMachineToken() *tokenserver.MachineTokenBody {
	if x, ok := m.GetTokenType().(*InspectMachineTokenResponse_LuciMachineToken); ok {
		return x.LuciMachineToken
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InspectMachineTokenResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InspectMachineTokenResponse_OneofMarshaler, _InspectMachineTokenResponse_OneofUnmarshaler, _InspectMachineTokenResponse_OneofSizer, []interface{}{
		(*InspectMachineTokenResponse_LuciMachineToken)(nil),
	}
}

func _InspectMachineTokenResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InspectMachineTokenResponse)
	// token_type
	switch x := m.TokenType.(type) {
	case *InspectMachineTokenResponse_LuciMachineToken:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LuciMachineToken); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InspectMachineTokenResponse.TokenType has unexpected type %T", x)
	}
	return nil
}

func _InspectMachineTokenResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InspectMachineTokenResponse)
	switch tag {
	case 20: // token_type.luci_machine_token
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(tokenserver.MachineTokenBody)
		err := b.DecodeMessage(msg)
		m.TokenType = &InspectMachineTokenResponse_LuciMachineToken{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InspectMachineTokenResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InspectMachineTokenResponse)
	// token_type
	switch x := m.TokenType.(type) {
	case *InspectMachineTokenResponse_LuciMachineToken:
		s := proto.Size(x.LuciMachineToken)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// MintDelegationTokenRequest is passed to MintDelegationToken.
type MintDelegationTokenRequest struct {
	// Identity whose authority is delegated.
	//
	// A string of the form "user:<email>". The token server will check its ACLs
	// to make sure the caller is authorized to impersonate this identity.
	//
	// Required.
	DelegatedIdentity string `protobuf:"bytes,1,opt,name=delegated_identity,json=delegatedIdentity" json:"delegated_identity,omitempty"`
	// How long the token should be considered valid (in seconds).
	//
	// Default is 3600 sec.
	ValidityDuration int64 `protobuf:"varint,2,opt,name=validity_duration,json=validityDuration" json:"validity_duration,omitempty"`
	// Who will be able to use the new token.
	//
	// Each item can be an identity string (e.g. "user:<email>"), a "group:<name>"
	// string, or special "*" string which means "Any bearer can use the token".
	//
	// This is semantically is a set, the order of elements doesn't matter.
	//
	// Required.
	Audience []string `protobuf:"bytes,3,rep,name=audience" json:"audience,omitempty"`
	// What services should accept the new token.
	//
	// List of LUCI services (specified as service identities, e.g.
	// "service:app-id" or as https:// root URLs e.g. "https://<host>") that
	// should accept this token. May also contain special "*" string, which
	// means "All LUCI services".
	//
	// This is semantically is a set, the order of elements doesn't matter.
	//
	// Required.
	Services []string `protobuf:"bytes,4,rep,name=services" json:"services,omitempty"`
	// Optional reason why the token is created.
	//
	// Used only for logging and auditing purposes. Doesn't become part of the
	// token.
	Intent string `protobuf:"bytes,5,opt,name=intent" json:"intent,omitempty"`
}

func (m *MintDelegationTokenRequest) Reset()                    { *m = MintDelegationTokenRequest{} }
func (m *MintDelegationTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*MintDelegationTokenRequest) ProtoMessage()               {}
func (*MintDelegationTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

// MintDelegationTokenResponse is returned by 'MintDelegationToken' on success.
//
// Errors are returned via standard gRPC codes.
type MintDelegationTokenResponse struct {
	// The actual base64-encoded signed token.
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	// Same data as in 'token' in deserialized form, just for convenience.
	//
	// Mostly for JSON encoding users, since they may not understand proto-encoded
	// tokens.
	DelegationSubtoken *messages.Subtoken `protobuf:"bytes,2,opt,name=delegation_subtoken,json=delegationSubtoken" json:"delegation_subtoken,omitempty"`
}

func (m *MintDelegationTokenResponse) Reset()                    { *m = MintDelegationTokenResponse{} }
func (m *MintDelegationTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*MintDelegationTokenResponse) ProtoMessage()               {}
func (*MintDelegationTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *MintDelegationTokenResponse) GetDelegationSubtoken() *messages.Subtoken {
	if m != nil {
		return m.DelegationSubtoken
	}
	return nil
}

func init() {
	proto.RegisterType((*MintMachineTokenRequest)(nil), "tokenserver.minter.MintMachineTokenRequest")
	proto.RegisterType((*MachineTokenRequest)(nil), "tokenserver.minter.MachineTokenRequest")
	proto.RegisterType((*MintMachineTokenResponse)(nil), "tokenserver.minter.MintMachineTokenResponse")
	proto.RegisterType((*MachineTokenResponse)(nil), "tokenserver.minter.MachineTokenResponse")
	proto.RegisterType((*LuciMachineToken)(nil), "tokenserver.minter.LuciMachineToken")
	proto.RegisterType((*InspectMachineTokenRequest)(nil), "tokenserver.minter.InspectMachineTokenRequest")
	proto.RegisterType((*InspectMachineTokenResponse)(nil), "tokenserver.minter.InspectMachineTokenResponse")
	proto.RegisterType((*MintDelegationTokenRequest)(nil), "tokenserver.minter.MintDelegationTokenRequest")
	proto.RegisterType((*MintDelegationTokenResponse)(nil), "tokenserver.minter.MintDelegationTokenResponse")
	proto.RegisterEnum("tokenserver.minter.MachineTokenType", MachineTokenType_name, MachineTokenType_value)
	proto.RegisterEnum("tokenserver.minter.SignatureAlgorithm", SignatureAlgorithm_name, SignatureAlgorithm_value)
	proto.RegisterEnum("tokenserver.minter.ErrorCode", ErrorCode_name, ErrorCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for TokenMinter service

type TokenMinterClient interface {
	// MintMachineToken generates a new token for an authenticated machine.
	//
	// It checks that provided certificate was signed by some trusted CA, and it
	// is still valid (non-expired and hasn't been revoked). It then checks that
	// the request was signed by the corresponding private key. Finally it checks
	// that the caller is authorized to generate requested kind of token.
	//
	// If everything checks out, it generates and returns a new machine token.
	//
	// On fatal error it returns detailed error response via same
	// MintMachineTokenResponse. On transient errors it returns generic
	// grpc.Internal error.
	MintMachineToken(ctx context.Context, in *MintMachineTokenRequest, opts ...grpc.CallOption) (*MintMachineTokenResponse, error)
	// InspectMachineToken decodes a machine token and verifies it is valid.
	//
	// It verifies the token was signed by a private key of the token server and
	// checks token's expiration time and revocation status.
	//
	// It tries to give as much information about the token and its status as
	// possible (e.g. it checks for revocation status even if token is already
	// expired).
	//
	// Administrators can use this call to debug issues with tokens.
	//
	// Returns:
	//   InspectMachineTokenResponse for tokens of supported kind.
	//   grpc.InvalidArgument error for unsupported token kind.
	//   grpc.Internal error for transient errors.
	InspectMachineToken(ctx context.Context, in *InspectMachineTokenRequest, opts ...grpc.CallOption) (*InspectMachineTokenResponse, error)
	// MintDelegationToken generates a new bearer delegation token.
	//
	// Such token can be sent in 'X-Delegation-Token-V1' header (alongside regular
	// credentials like OAuth2 access token) to convey that the caller should be
	// authentication as 'delegated_identity' specified in the token.
	//
	// The delegation tokens are subject to multiple restrictions (embedded in
	// the token):
	//   * They have expiration time.
	//   * They are usable only if presented with a credential of someone from
	//     the 'audience' list.
	//   * They are usable only on services specified in the 'services' list.
	//
	// The token server must be configured in advance with all expected
	// combinations of (caller identity, delegated identity, audience, service)
	// tuples. See DelegationRule in config.proto.
	MintDelegationToken(ctx context.Context, in *MintDelegationTokenRequest, opts ...grpc.CallOption) (*MintDelegationTokenResponse, error)
}
type tokenMinterPRPCClient struct {
	client *prpc.Client
}

func NewTokenMinterPRPCClient(client *prpc.Client) TokenMinterClient {
	return &tokenMinterPRPCClient{client}
}

func (c *tokenMinterPRPCClient) MintMachineToken(ctx context.Context, in *MintMachineTokenRequest, opts ...grpc.CallOption) (*MintMachineTokenResponse, error) {
	out := new(MintMachineTokenResponse)
	err := c.client.Call(ctx, "tokenserver.minter.TokenMinter", "MintMachineToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenMinterPRPCClient) InspectMachineToken(ctx context.Context, in *InspectMachineTokenRequest, opts ...grpc.CallOption) (*InspectMachineTokenResponse, error) {
	out := new(InspectMachineTokenResponse)
	err := c.client.Call(ctx, "tokenserver.minter.TokenMinter", "InspectMachineToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenMinterPRPCClient) MintDelegationToken(ctx context.Context, in *MintDelegationTokenRequest, opts ...grpc.CallOption) (*MintDelegationTokenResponse, error) {
	out := new(MintDelegationTokenResponse)
	err := c.client.Call(ctx, "tokenserver.minter.TokenMinter", "MintDelegationToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type tokenMinterClient struct {
	cc *grpc.ClientConn
}

func NewTokenMinterClient(cc *grpc.ClientConn) TokenMinterClient {
	return &tokenMinterClient{cc}
}

func (c *tokenMinterClient) MintMachineToken(ctx context.Context, in *MintMachineTokenRequest, opts ...grpc.CallOption) (*MintMachineTokenResponse, error) {
	out := new(MintMachineTokenResponse)
	err := grpc.Invoke(ctx, "/tokenserver.minter.TokenMinter/MintMachineToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenMinterClient) InspectMachineToken(ctx context.Context, in *InspectMachineTokenRequest, opts ...grpc.CallOption) (*InspectMachineTokenResponse, error) {
	out := new(InspectMachineTokenResponse)
	err := grpc.Invoke(ctx, "/tokenserver.minter.TokenMinter/InspectMachineToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenMinterClient) MintDelegationToken(ctx context.Context, in *MintDelegationTokenRequest, opts ...grpc.CallOption) (*MintDelegationTokenResponse, error) {
	out := new(MintDelegationTokenResponse)
	err := grpc.Invoke(ctx, "/tokenserver.minter.TokenMinter/MintDelegationToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TokenMinter service

type TokenMinterServer interface {
	// MintMachineToken generates a new token for an authenticated machine.
	//
	// It checks that provided certificate was signed by some trusted CA, and it
	// is still valid (non-expired and hasn't been revoked). It then checks that
	// the request was signed by the corresponding private key. Finally it checks
	// that the caller is authorized to generate requested kind of token.
	//
	// If everything checks out, it generates and returns a new machine token.
	//
	// On fatal error it returns detailed error response via same
	// MintMachineTokenResponse. On transient errors it returns generic
	// grpc.Internal error.
	MintMachineToken(context.Context, *MintMachineTokenRequest) (*MintMachineTokenResponse, error)
	// InspectMachineToken decodes a machine token and verifies it is valid.
	//
	// It verifies the token was signed by a private key of the token server and
	// checks token's expiration time and revocation status.
	//
	// It tries to give as much information about the token and its status as
	// possible (e.g. it checks for revocation status even if token is already
	// expired).
	//
	// Administrators can use this call to debug issues with tokens.
	//
	// Returns:
	//   InspectMachineTokenResponse for tokens of supported kind.
	//   grpc.InvalidArgument error for unsupported token kind.
	//   grpc.Internal error for transient errors.
	InspectMachineToken(context.Context, *InspectMachineTokenRequest) (*InspectMachineTokenResponse, error)
	// MintDelegationToken generates a new bearer delegation token.
	//
	// Such token can be sent in 'X-Delegation-Token-V1' header (alongside regular
	// credentials like OAuth2 access token) to convey that the caller should be
	// authentication as 'delegated_identity' specified in the token.
	//
	// The delegation tokens are subject to multiple restrictions (embedded in
	// the token):
	//   * They have expiration time.
	//   * They are usable only if presented with a credential of someone from
	//     the 'audience' list.
	//   * They are usable only on services specified in the 'services' list.
	//
	// The token server must be configured in advance with all expected
	// combinations of (caller identity, delegated identity, audience, service)
	// tuples. See DelegationRule in config.proto.
	MintDelegationToken(context.Context, *MintDelegationTokenRequest) (*MintDelegationTokenResponse, error)
}

func RegisterTokenMinterServer(s prpc.Registrar, srv TokenMinterServer) {
	s.RegisterService(&_TokenMinter_serviceDesc, srv)
}

func _TokenMinter_MintMachineToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MintMachineTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenMinterServer).MintMachineToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenserver.minter.TokenMinter/MintMachineToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenMinterServer).MintMachineToken(ctx, req.(*MintMachineTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenMinter_InspectMachineToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectMachineTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenMinterServer).InspectMachineToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenserver.minter.TokenMinter/InspectMachineToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenMinterServer).InspectMachineToken(ctx, req.(*InspectMachineTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenMinter_MintDelegationToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MintDelegationTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenMinterServer).MintDelegationToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenserver.minter.TokenMinter/MintDelegationToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenMinterServer).MintDelegationToken(ctx, req.(*MintDelegationTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TokenMinter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tokenserver.minter.TokenMinter",
	HandlerType: (*TokenMinterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MintMachineToken",
			Handler:    _TokenMinter_MintMachineToken_Handler,
		},
		{
			MethodName: "InspectMachineToken",
			Handler:    _TokenMinter_InspectMachineToken_Handler,
		},
		{
			MethodName: "MintDelegationToken",
			Handler:    _TokenMinter_MintDelegationToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptor0,
}

func init() {
	proto.RegisterFile("github.com/luci/luci-go/tokenserver/api/minter/v1/token_minter.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1099 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x56, 0xdd, 0x52, 0xdb, 0x46,
	0x14, 0x8e, 0x0c, 0x18, 0xfb, 0x18, 0x88, 0x58, 0x03, 0x71, 0x4d, 0x3b, 0xc9, 0xb8, 0x99, 0x36,
	0x43, 0x8a, 0x3c, 0x75, 0xa7, 0x3f, 0x33, 0xc9, 0x8d, 0x62, 0x14, 0x50, 0x41, 0x32, 0xb3, 0x92,
	0x9b, 0xe9, 0xd5, 0x8e, 0xb0, 0x36, 0x46, 0x83, 0x2d, 0x39, 0x92, 0x4c, 0xe3, 0x3e, 0x47, 0xdf,
	0xa3, 0xaf, 0xd1, 0xb7, 0xe8, 0x5d, 0xaf, 0x7a, 0xdf, 0xdb, 0xae, 0x76, 0x25, 0x5b, 0x06, 0x91,
	0x30, 0xb9, 0xf1, 0x68, 0xbf, 0xf3, 0x9d, 0x9f, 0x3d, 0x7f, 0x6b, 0x38, 0x1a, 0x7a, 0xf1, 0xe5,
	0xf4, 0x42, 0x19, 0x04, 0xe3, 0xf6, 0x68, 0x3a, 0xf0, 0xf8, 0xcf, 0xe1, 0x30, 0x68, 0xc7, 0xc1,
	0x15, 0xf5, 0x23, 0x1a, 0x5e, 0xd3, 0xb0, 0xed, 0x4c, 0xbc, 0xf6, 0xd8, 0xf3, 0x63, 0xf6, 0x79,
	0xfd, 0xad, 0x90, 0x10, 0x71, 0x56, 0x26, 0x61, 0x10, 0x07, 0x08, 0xe5, 0xd8, 0x8a, 0x90, 0x34,
	0x1f, 0x0f, 0x83, 0x60, 0x38, 0xa2, 0x6d, 0xce, 0xb8, 0x98, 0xbe, 0x6d, 0xc7, 0xde, 0x98, 0x46,
	0xb1, 0x33, 0x9e, 0x08, 0xa5, 0xe6, 0xc9, 0x5d, 0xae, 0x33, 0xaf, 0xd3, 0xf8, 0xb2, 0xed, 0xd2,
	0x11, 0x1d, 0x3a, 0xb1, 0x17, 0xf8, 0x6d, 0xa6, 0x1d, 0x39, 0x43, 0x1a, 0xe5, 0xb0, 0xd4, 0xd2,
	0x8b, 0x7b, 0x5f, 0xc2, 0x19, 0x5c, 0x7a, 0x3e, 0x25, 0x1c, 0x17, 0xca, 0xad, 0x77, 0xf0, 0xc8,
	0x60, 0x11, 0x1b, 0x42, 0x64, 0x27, 0x12, 0x4c, 0xdf, 0x4d, 0x59, 0xa8, 0xe8, 0x27, 0x68, 0x30,
	0x65, 0xcf, 0x19, 0x79, 0xbf, 0x53, 0x57, 0x28, 0x91, 0x50, 0xc8, 0x1a, 0xd2, 0x13, 0xe9, 0xd9,
	0x06, 0xde, 0x5b, 0xc8, 0x97, 0x34, 0x3f, 0x87, 0x6a, 0xe4, 0x0d, 0x7d, 0x27, 0x9e, 0x86, 0xb4,
	0x51, 0xe2, 0xd4, 0x05, 0xd0, 0xfa, 0xa3, 0x04, 0xf5, 0x22, 0x7f, 0x4f, 0xa0, 0x36, 0xa0, 0x61,
	0xec, 0xbd, 0xf5, 0x06, 0x4e, 0x4c, 0x53, 0x17, 0x79, 0x08, 0xbd, 0x81, 0xfa, 0xdc, 0x0c, 0x71,
	0x46, 0xc3, 0x20, 0x64, 0x37, 0x1f, 0x73, 0x0f, 0x5b, 0x9d, 0xaf, 0x94, 0xdb, 0x65, 0x50, 0xac,
	0x8c, 0xae, 0x66, 0x6c, 0x8c, 0xa2, 0x5b, 0x18, 0xfa, 0x11, 0xaa, 0x5e, 0x14, 0x4d, 0xd9, 0x35,
	0x9d, 0xb8, 0xb1, 0xc2, 0xcc, 0xd5, 0x3a, 0x4d, 0x45, 0x54, 0x50, 0xc9, 0x2a, 0xa8, 0xd8, 0x59,
	0x05, 0x71, 0x45, 0x90, 0xd5, 0x18, 0x75, 0x01, 0x44, 0x62, 0xe2, 0xd9, 0x84, 0x36, 0x56, 0x79,
	0x20, 0x4f, 0x8b, 0x02, 0xc9, 0x5f, 0xd8, 0x66, 0x5c, 0x5c, 0x8d, 0xb3, 0xcf, 0x9f, 0x57, 0x2b,
	0x6b, 0x72, 0xb9, 0xf5, 0x9f, 0x04, 0x8d, 0xdb, 0xa5, 0x88, 0x26, 0x01, 0xb3, 0x84, 0x5e, 0x02,
	0xd0, 0x30, 0x0c, 0x42, 0x32, 0x08, 0x5c, 0x91, 0x9a, 0xad, 0xce, 0x17, 0x45, 0x7e, 0xb4, 0x84,
	0xd5, 0x65, 0x24, 0x5c, 0xa5, 0xd9, 0x27, 0xfa, 0x12, 0x36, 0x85, 0x76, 0xda, 0x44, 0x3c, 0x63,
	0x55, 0xbc, 0xc1, 0x41, 0x43, 0x60, 0xa8, 0x07, 0x5b, 0x59, 0x8d, 0x85, 0xd3, 0x34, 0x11, 0xcf,
	0x3e, 0x76, 0x9d, 0x2c, 0x48, 0xbc, 0x19, 0x2f, 0xc5, 0xfc, 0x35, 0x3c, 0x4c, 0x94, 0xbc, 0x01,
	0x25, 0x4c, 0x33, 0x62, 0x0d, 0xcb, 0x13, 0x54, 0xc5, 0x5b, 0x29, 0xfc, 0x8b, 0x40, 0x5b, 0x7f,
	0x4a, 0xb0, 0x53, 0x78, 0xeb, 0x02, 0x0b, 0xa5, 0x22, 0x0b, 0xc8, 0x06, 0x94, 0x34, 0x3d, 0x59,
	0xea, 0xf0, 0xc6, 0x2e, 0x8f, 0xbf, 0xb0, 0x1c, 0x67, 0x8c, 0x9d, 0x77, 0x79, 0xf2, 0x00, 0xcb,
	0xa3, 0x1b, 0xd8, 0xab, 0x8d, 0x7c, 0x71, 0x59, 0x95, 0x24, 0xb9, 0xc4, 0x7e, 0x77, 0xe4, 0xdd,
	0xd6, 0x15, 0xc8, 0x37, 0x2d, 0x24, 0x49, 0x5e, 0x76, 0x2f, 0x89, 0x24, 0x8f, 0xf3, 0xa4, 0x0e,
	0x94, 0xe9, 0xfb, 0x89, 0x17, 0xce, 0xf8, 0x45, 0x3e, 0xdc, 0x65, 0x29, 0xb3, 0xf5, 0x1b, 0x34,
	0x75, 0x3f, 0x9a, 0xd0, 0x41, 0xe1, 0x94, 0x2e, 0x77, 0xa0, 0xf4, 0x49, 0x1d, 0x88, 0x76, 0x60,
	0x4d, 0xc4, 0x2c, 0xd2, 0x2b, 0x0e, 0xad, 0xbf, 0x4b, 0xb0, 0x5f, 0xe8, 0x39, 0x2d, 0x0f, 0xd3,
	0xba, 0x66, 0xd3, 0xef, 0x72, 0xaf, 0x15, 0x2c, 0x0e, 0xe8, 0x39, 0x6c, 0x7b, 0x3e, 0xff, 0xf4,
	0xe2, 0x19, 0x6b, 0x26, 0x27, 0x9a, 0x97, 0x4d, 0x5e, 0x08, 0x30, 0xc7, 0xd1, 0x1e, 0x94, 0x93,
	0x71, 0xa4, 0x2e, 0x6f, 0xb6, 0x0a, 0x4e, 0x4f, 0xe8, 0x31, 0xd4, 0xfc, 0xc0, 0x27, 0x3c, 0x03,
	0x4c, 0x78, 0xc8, 0x85, 0xc0, 0x20, 0x4d, 0x20, 0x19, 0x21, 0xa4, 0xd7, 0x2c, 0x24, 0xb7, 0xb1,
	0x36, 0x27, 0x60, 0x81, 0xa0, 0xa7, 0xb0, 0x95, 0xd8, 0xf2, 0xfc, 0x21, 0xb9, 0xa2, 0x33, 0xc2,
	0xa2, 0x2c, 0x8b, 0x7a, 0xa4, 0xe8, 0x29, 0x9d, 0xe9, 0x2e, 0xdb, 0x39, 0x1b, 0xc9, 0x82, 0x21,
	0x03, 0x87, 0xf8, 0xce, 0x98, 0x36, 0xd6, 0x39, 0x07, 0x12, 0xac, 0xeb, 0x98, 0x0c, 0x41, 0x46,
	0x61, 0x6b, 0xed, 0xf0, 0xea, 0x2d, 0x4f, 0xe0, 0x52, 0xef, 0x04, 0xee, 0xec, 0xe3, 0x3d, 0xd5,
	0xfa, 0x4b, 0x82, 0x66, 0x32, 0xf3, 0x47, 0xf3, 0x9d, 0xbe, 0x54, 0xdb, 0x43, 0x40, 0xe9, 0xb6,
	0x67, 0x9b, 0xc9, 0x73, 0xa9, 0x1f, 0xb3, 0xcc, 0xa5, 0x7d, 0xb5, 0x3d, 0x97, 0xe8, 0xa9, 0x20,
	0xc9, 0xfc, 0x3c, 0xef, 0xee, 0x34, 0xe4, 0xf6, 0x78, 0xe6, 0x57, 0xb0, 0x9c, 0x09, 0x8e, 0x52,
	0x1c, 0x35, 0xa1, 0xe2, 0x4c, 0x5d, 0x8f, 0xfa, 0x83, 0x64, 0xd0, 0x57, 0x98, 0xc5, 0xf9, 0x39,
	0x91, 0xa5, 0x03, 0x16, 0xb1, 0x91, 0xe5, 0xb2, 0xec, 0x9c, 0x54, 0x2c, 0xe9, 0x27, 0x3f, 0xe6,
	0x39, 0xaf, 0xe2, 0xf4, 0xd4, 0x7a, 0x0f, 0xfb, 0x85, 0x37, 0x59, 0xf4, 0x4a, 0x7e, 0x2a, 0xc4,
	0x81, 0x35, 0x6f, 0x7d, 0xf1, 0x9c, 0x91, 0x68, 0x7a, 0xb1, 0xe8, 0xc2, 0x5a, 0x07, 0x29, 0xd9,
	0x9b, 0xa7, 0x58, 0xa9, 0x04, 0xa3, 0x05, 0x3d, 0xc3, 0x0e, 0x5e, 0x82, 0x7c, 0xb3, 0xb7, 0x91,
	0x0c, 0x1b, 0x7d, 0xf3, 0xd4, 0xec, 0xbd, 0x31, 0x89, 0xfd, 0xeb, 0xb9, 0x26, 0x3f, 0x60, 0x71,
	0xa3, 0xb3, 0x7e, 0x57, 0x27, 0x86, 0xda, 0x3d, 0xd1, 0x4d, 0x8d, 0xd8, 0xbd, 0x53, 0xcd, 0x94,
	0x4b, 0x07, 0x2f, 0x00, 0xdd, 0x7e, 0x24, 0xf2, 0xfa, 0xea, 0xd9, 0x71, 0x8f, 0xe9, 0xd7, 0xe1,
	0xa1, 0x75, 0xa2, 0x76, 0xbe, 0xff, 0x81, 0x60, 0x4b, 0x15, 0xa0, 0x74, 0xf0, 0x8f, 0x04, 0xd5,
	0xf9, 0xc6, 0x45, 0x35, 0x58, 0xb7, 0xfa, 0xdd, 0xae, 0x66, 0x59, 0x8c, 0xff, 0x19, 0xec, 0xf6,
	0x4d, 0xab, 0x7f, 0x7e, 0xde, 0xc3, 0xb6, 0x76, 0x44, 0x2c, 0xfd, 0xd8, 0x54, 0xed, 0x3e, 0xd6,
	0x64, 0x89, 0xa5, 0x77, 0x2f, 0x2f, 0xe2, 0x91, 0x88, 0x30, 0x4b, 0x68, 0x1b, 0x36, 0x5f, 0xa9,
	0x0c, 0xd3, 0x0d, 0xcd, 0xb2, 0x55, 0xe3, 0x5c, 0x5e, 0x49, 0xe8, 0x09, 0xd4, 0xd5, 0xb0, 0xad,
	0xbf, 0xd6, 0xbb, 0xaa, 0xad, 0x91, 0xd7, 0x3d, 0x6c, 0xa8, 0xb6, 0xbc, 0x9a, 0xd1, 0x17, 0xd6,
	0xd7, 0x84, 0x63, 0x1b, 0xf7, 0xad, 0xc4, 0x76, 0x4e, 0x49, 0x2e, 0xa3, 0x47, 0x50, 0xe7, 0xc6,
	0xb9, 0x43, 0x15, 0x1f, 0xf7, 0x0d, 0xcd, 0xb4, 0x2d, 0x79, 0x9d, 0x4d, 0xd3, 0xfe, 0x52, 0x5e,
	0x88, 0xa1, 0x9b, 0xb6, 0x6e, 0x1e, 0x13, 0x0d, 0xe3, 0x1e, 0x96, 0x2b, 0x9d, 0x7f, 0x4b, 0x50,
	0xe3, 0xd9, 0x35, 0xf8, 0x32, 0x41, 0x63, 0x96, 0xf3, 0x1b, 0x6f, 0x15, 0x7a, 0x5e, 0xb8, 0x75,
	0x8a, 0xff, 0x5c, 0x34, 0xbf, 0xb9, 0x1f, 0x39, 0xed, 0x9e, 0x6b, 0xa8, 0x17, 0x2c, 0x22, 0xa4,
	0x14, 0x19, 0xb9, 0x7b, 0x57, 0x36, 0xdb, 0xf7, 0xe6, 0x2f, 0xfc, 0x16, 0x34, 0x75, 0xb1, 0xdf,
	0xbb, 0xe7, 0xb8, 0xd8, 0xef, 0x07, 0xa6, 0xe5, 0xa2, 0xcc, 0x9f, 0x83, 0xef, 0xfe, 0x0f, 0x00,
	0x00, 0xff, 0xff, 0x11, 0x9a, 0x41, 0xd8, 0xa0, 0x0a, 0x00, 0x00,
}
