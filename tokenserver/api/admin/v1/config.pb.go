// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/tokenserver/api/admin/v1/config.proto

package admin

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// TokenServerConfig is read from tokenserver.cfg in luci-config.
type TokenServerConfig struct {
	// List of CAs we trust.
	CertificateAuthority []*CertificateAuthorityConfig `protobuf:"bytes,1,rep,name=certificate_authority,json=certificateAuthority" json:"certificate_authority,omitempty"`
}

func (m *TokenServerConfig) Reset()                    { *m = TokenServerConfig{} }
func (m *TokenServerConfig) String() string            { return proto.CompactTextString(m) }
func (*TokenServerConfig) ProtoMessage()               {}
func (*TokenServerConfig) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *TokenServerConfig) GetCertificateAuthority() []*CertificateAuthorityConfig {
	if m != nil {
		return m.CertificateAuthority
	}
	return nil
}

// CertificateAuthorityConfig defines a single CA we trust.
//
// Such CA issues certificates for nodes that use The Token Service. Each node
// has a private key and certificate with Common Name set to the FQDN of this
// node, e.g. "CN=slave43-c1.c.chromecompute.google.com.internal".
//
// The Token Server uses this CN to derive an identity string for a machine. It
// splits FQDN into a hostname ("slave43-c1") and a domain name
// ("c.chromecompute.google.com.internal"), searches for a domain name in
// "known_domains" set, and, if it is present, uses parameters described there
// for generating a token that contains machine's FQDN and certificate serial
// number (among other things, see MachineTokenBody in machine_token.proto).
type CertificateAuthorityConfig struct {
	UniqueId    int64    `protobuf:"varint,6,opt,name=unique_id,json=uniqueId" json:"unique_id,omitempty"`
	Cn          string   `protobuf:"bytes,1,opt,name=cn" json:"cn,omitempty"`
	CertPath    string   `protobuf:"bytes,2,opt,name=cert_path,json=certPath" json:"cert_path,omitempty"`
	CrlUrl      string   `protobuf:"bytes,3,opt,name=crl_url,json=crlUrl" json:"crl_url,omitempty"`
	UseOauth    bool     `protobuf:"varint,4,opt,name=use_oauth,json=useOauth" json:"use_oauth,omitempty"`
	OauthScopes []string `protobuf:"bytes,7,rep,name=oauth_scopes,json=oauthScopes" json:"oauth_scopes,omitempty"`
	// KnownDomains describes parameters to use for each particular domain.
	KnownDomains []*DomainConfig `protobuf:"bytes,5,rep,name=known_domains,json=knownDomains" json:"known_domains,omitempty"`
}

func (m *CertificateAuthorityConfig) Reset()                    { *m = CertificateAuthorityConfig{} }
func (m *CertificateAuthorityConfig) String() string            { return proto.CompactTextString(m) }
func (*CertificateAuthorityConfig) ProtoMessage()               {}
func (*CertificateAuthorityConfig) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *CertificateAuthorityConfig) GetUniqueId() int64 {
	if m != nil {
		return m.UniqueId
	}
	return 0
}

func (m *CertificateAuthorityConfig) GetCn() string {
	if m != nil {
		return m.Cn
	}
	return ""
}

func (m *CertificateAuthorityConfig) GetCertPath() string {
	if m != nil {
		return m.CertPath
	}
	return ""
}

func (m *CertificateAuthorityConfig) GetCrlUrl() string {
	if m != nil {
		return m.CrlUrl
	}
	return ""
}

func (m *CertificateAuthorityConfig) GetUseOauth() bool {
	if m != nil {
		return m.UseOauth
	}
	return false
}

func (m *CertificateAuthorityConfig) GetOauthScopes() []string {
	if m != nil {
		return m.OauthScopes
	}
	return nil
}

func (m *CertificateAuthorityConfig) GetKnownDomains() []*DomainConfig {
	if m != nil {
		return m.KnownDomains
	}
	return nil
}

// DomainConfig is used inside CertificateAuthorityConfig.
type DomainConfig struct {
	// Domain is domain names of hosts this config applies to.
	//
	// Machines that reside in a subdomain of given domain are also considered
	// part of it, e.g. both FQDNs "host.example.com" and "host.abc.example.com"
	// match domain "example.com".
	Domain []string `protobuf:"bytes,1,rep,name=domain" json:"domain,omitempty"`
	// MachineTokenLifetime is how long generated machine tokens live, in seconds.
	//
	// If 0, machine tokens are not allowed.
	MachineTokenLifetime int64 `protobuf:"varint,5,opt,name=machine_token_lifetime,json=machineTokenLifetime" json:"machine_token_lifetime,omitempty"`
}

func (m *DomainConfig) Reset()                    { *m = DomainConfig{} }
func (m *DomainConfig) String() string            { return proto.CompactTextString(m) }
func (*DomainConfig) ProtoMessage()               {}
func (*DomainConfig) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *DomainConfig) GetDomain() []string {
	if m != nil {
		return m.Domain
	}
	return nil
}

func (m *DomainConfig) GetMachineTokenLifetime() int64 {
	if m != nil {
		return m.MachineTokenLifetime
	}
	return 0
}

// DelegationPermissions is read from delegation.cfg in luci-config.
type DelegationPermissions struct {
	// Rules specify what calls to MintDelegationToken are allowed.
	//
	// Rules are evaluated independently. One and only one rule should match the
	// request to allow the operation. If none rules or more than one rule match,
	// the request will be denied.
	//
	// See DelegationRule comments for more details.
	Rules []*DelegationRule `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty"`
}

func (m *DelegationPermissions) Reset()                    { *m = DelegationPermissions{} }
func (m *DelegationPermissions) String() string            { return proto.CompactTextString(m) }
func (*DelegationPermissions) ProtoMessage()               {}
func (*DelegationPermissions) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *DelegationPermissions) GetRules() []*DelegationRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// DelegationRule describes a single allowed case of using delegation tokens.
//
// An incoming MintDelegationTokenRequest is basically a tuple of:
//  * 'requestor_id' - an identity of whoever makes the request.
//  * 'delegated_identity' - an identity to delegate.
//  * 'audience' - a set of identities that will be able to use the token.
//  * 'services' - a set of services that should accept the token.
//
// A request matches a rule iff:
//  * 'requestor_id' is in 'requestor' set.
//  * 'delegated_identity' is in 'allowed_to_impersonate' set.
//  * 'audience' is a subset of 'allowed_audience' set.
//  * 'services' is a subset of 'target_service' set.
//
// The presence of a matching rule permits to mint the token. The rule also
// provides an upper bound on allowed validity_duration, and the rule's name
// is logged in the audit trail.
type DelegationRule struct {
	// A descriptive name of this rule, for the audit log.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Email of developers that own this rule, to know who to contact.
	Owner []string `protobuf:"bytes,2,rep,name=owner" json:"owner,omitempty"`
	// A set of callers to which this rule applies.
	//
	// Matched against verified credentials of a caller of MintDelegationToken.
	//
	// Each element is either:
	//  * An identity string ("user:<email>").
	//  * A group reference ("group:<name>").
	//
	// The groups specified here are expanded when MintDelegationTokenRequest is
	// evaluated.
	Requestor []string `protobuf:"bytes,3,rep,name=requestor" json:"requestor,omitempty"`
	// Identities that are allowed to be delegated/impersonated by the requestor.
	//
	// Matched against 'delegated_identity' field of MintDelegationTokenRequest.
	//
	// Each element is either:
	//  * An identity string ("user:<email>").
	//  * A group reference ("group:<name>").
	//  * A special identifier "REQUESTOR" that is substituted by the requestor
	//    identity when evaluating the rule.
	//
	// "REQUESTOR" allows one to generate tokens that delegate their own identity
	// to some target audience.
	//
	// The groups specified here are expanded when MintDelegationTokenRequest is
	// evaluated.
	AllowedToImpersonate []string `protobuf:"bytes,4,rep,name=allowed_to_impersonate,json=allowedToImpersonate" json:"allowed_to_impersonate,omitempty"`
	// A set of identities that should be able to use the new token.
	//
	// Matched against 'audience' field of MintDelegationTokenRequest.
	//
	// Each element is either:
	//  * An identity string ("user:<email>").
	//  * A group reference ("group:<name>").
	//  * A special identifier "REQUESTOR" that is substituted by the requestor
	//    identity when evaluating the rule.
	//  * A special token "*" that means "any bearer can use the new token,
	//    including anonymous".
	//
	// "REQUESTOR" is typically used here for rules that allow requestors to
	// impersonate someone else. The corresponding tokens have the requestor as
	// the only allowed audience.
	//
	// The groups specified here are NOT expanded when MintDelegationTokenRequest
	// is evaluated. To match the rule, MintDelegationTokenRequest must specify
	// subset of 'allowed_audience' groups explicitly in 'audience' field.
	AllowedAudience []string `protobuf:"bytes,5,rep,name=allowed_audience,json=allowedAudience" json:"allowed_audience,omitempty"`
	// A set of services that should be able to accept the new token.
	//
	// Matched against 'services' field of MintDelegationTokenRequest.
	//
	// Each element is either:
	//  * A service identity string ("service:<id>").
	//  * A special token "*" that mean "any LUCI service should accept the
	//    token".
	TargetService []string `protobuf:"bytes,6,rep,name=target_service,json=targetService" json:"target_service,omitempty"`
	// Maximum allowed validity duration (sec) of minted delegation tokens.
	//
	// Default is 12 hours.
	MaxValidityDuration int64 `protobuf:"varint,7,opt,name=max_validity_duration,json=maxValidityDuration" json:"max_validity_duration,omitempty"`
}

func (m *DelegationRule) Reset()                    { *m = DelegationRule{} }
func (m *DelegationRule) String() string            { return proto.CompactTextString(m) }
func (*DelegationRule) ProtoMessage()               {}
func (*DelegationRule) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *DelegationRule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DelegationRule) GetOwner() []string {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *DelegationRule) GetRequestor() []string {
	if m != nil {
		return m.Requestor
	}
	return nil
}

func (m *DelegationRule) GetAllowedToImpersonate() []string {
	if m != nil {
		return m.AllowedToImpersonate
	}
	return nil
}

func (m *DelegationRule) GetAllowedAudience() []string {
	if m != nil {
		return m.AllowedAudience
	}
	return nil
}

func (m *DelegationRule) GetTargetService() []string {
	if m != nil {
		return m.TargetService
	}
	return nil
}

func (m *DelegationRule) GetMaxValidityDuration() int64 {
	if m != nil {
		return m.MaxValidityDuration
	}
	return 0
}

// ServiceAccountsPermissions is read from service_accounts.cfg in luci-config.
type ServiceAccountsPermissions struct {
	// Rules specify how MintOAuthTokenViaGrant can be used.
	//
	// Rules define a mapping {service account email -> authorization config},
	// where 'service account email' is matched to 'service_account' field of
	// ServiceAccountRule, and 'authorization config' is the rest of fields in
	// ServiceAccountRule that define how exactly the given service account is
	// allowed to be used.
	//
	// See ServiceAccountRule comments for more details.
	Rules []*ServiceAccountRule `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty"`
	// Defaults specifies some default values applied to all rules, to reduce
	// duplication.
	//
	// See docs for individual fields to figure out how defaults are merged into
	// the rules.
	Defaults *ServiceAccountRuleDefaults `protobuf:"bytes,2,opt,name=defaults" json:"defaults,omitempty"`
}

func (m *ServiceAccountsPermissions) Reset()                    { *m = ServiceAccountsPermissions{} }
func (m *ServiceAccountsPermissions) String() string            { return proto.CompactTextString(m) }
func (*ServiceAccountsPermissions) ProtoMessage()               {}
func (*ServiceAccountsPermissions) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *ServiceAccountsPermissions) GetRules() []*ServiceAccountRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *ServiceAccountsPermissions) GetDefaults() *ServiceAccountRuleDefaults {
	if m != nil {
		return m.Defaults
	}
	return nil
}

// ServiceAccountRule describes a single allowed case of using service accounts.
//
// The usage of a service account is initiated by an end user, through some
// "proxy" service. For example, when a user posts a Swarming task that uses
// a service account, the end user is whoever posts the task, and the proxy is
// Swarming service itself.
//
// This rule specifies which end users are allowed to act as an account, and
// through which proxies.
type ServiceAccountRule struct {
	// A descriptive name of this rule, for the audit log.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Email of developers that own this rule, to know who to contact.
	Owner []string `protobuf:"bytes,2,rep,name=owner" json:"owner,omitempty"`
	// Email of service accounts that this rule applies to.
	//
	// This is the "primary key" in the rules table: there can be only one rule
	// that applies to a given service account.
	ServiceAccount []string `protobuf:"bytes,3,rep,name=service_account,json=serviceAccount" json:"service_account,omitempty"`
	// OAuth scopes we allow to be granted to the OAuth token.
	//
	// Any subset of given scopes is allowed. This field is evaluated in
	// MintOAuthTokenViaGrant RPC handler, right before generating the OAuth
	// token.
	//
	// Merged with corresponding list from ServiceAccountRuleDefaults.
	AllowedScope []string `protobuf:"bytes,4,rep,name=allowed_scope,json=allowedScope" json:"allowed_scope,omitempty"`
	// A set of identities that are allowed to act as the service account (perhaps
	// indirectly through some other intermediary "proxy" service like Swarming).
	//
	// Users listed here are ultimately able to grab an OAuth token belonging to
	// the service account.
	//
	// Each element is either:
	//  * An identity string ("user:<email>").
	//  * A group reference ("group:<name>").
	EndUser []string `protobuf:"bytes,5,rep,name=end_user,json=endUser" json:"end_user,omitempty"`
	// A set of identities that are allowed to act on behalf of end users when
	// grabbing an OAuth token for the service account.
	//
	// These identities represent "proxy" services that do something with service
	// accounts on behalf of end users. Only identities in this set are allowed
	// to perform MintOAuthTokenGrant RPC.
	//
	// Each element is either:
	//  * An identity string ("user:<email>").
	//  * A group reference ("group:<name>").
	Proxy []string `protobuf:"bytes,6,rep,name=proxy" json:"proxy,omitempty"`
	// Maximum allowed validity duration (sec) of OAuth token grants.
	//
	// The grant is minted by MintOAuthTokenGrant RPC (called, for example, when
	// Swarming task is posted), and checked by MintOAuthTokenViaGrant RPC (called
	// when the task actually runs). So the allowed validity duration should
	// account for possible queuing delays.
	//
	// This duration has no relation to the OAuth token lifetime. The OAuth token
	// produced by MintOAuthTokenViaGrant can always live up to 1h regardless of
	// validity duration of the grant.
	//
	// Default is taken from ServiceAccountRuleDefaults or 24 hours if not
	// specified there.
	MaxGrantValidityDuration int64 `protobuf:"varint,7,opt,name=max_grant_validity_duration,json=maxGrantValidityDuration" json:"max_grant_validity_duration,omitempty"`
}

func (m *ServiceAccountRule) Reset()                    { *m = ServiceAccountRule{} }
func (m *ServiceAccountRule) String() string            { return proto.CompactTextString(m) }
func (*ServiceAccountRule) ProtoMessage()               {}
func (*ServiceAccountRule) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

func (m *ServiceAccountRule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ServiceAccountRule) GetOwner() []string {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *ServiceAccountRule) GetServiceAccount() []string {
	if m != nil {
		return m.ServiceAccount
	}
	return nil
}

func (m *ServiceAccountRule) GetAllowedScope() []string {
	if m != nil {
		return m.AllowedScope
	}
	return nil
}

func (m *ServiceAccountRule) GetEndUser() []string {
	if m != nil {
		return m.EndUser
	}
	return nil
}

func (m *ServiceAccountRule) GetProxy() []string {
	if m != nil {
		return m.Proxy
	}
	return nil
}

func (m *ServiceAccountRule) GetMaxGrantValidityDuration() int64 {
	if m != nil {
		return m.MaxGrantValidityDuration
	}
	return 0
}

// ServiceAccountRuleDefaults specifies some default values applied to all
// service account rules, to reduce duplication.
type ServiceAccountRuleDefaults struct {
	// OAuth scopes we allow to be granted to all generated OAuth tokens.
	//
	// Always merged with 'allowed_scope' fields of ServiceAccountRule rule to
	// get the final list of scopes.
	AllowedScope []string `protobuf:"bytes,1,rep,name=allowed_scope,json=allowedScope" json:"allowed_scope,omitempty"`
	// Default value for corresponding ServiceAccountRule field, if not specified
	// there.
	//
	// Default is 24 hours.
	MaxGrantValidityDuration int64 `protobuf:"varint,2,opt,name=max_grant_validity_duration,json=maxGrantValidityDuration" json:"max_grant_validity_duration,omitempty"`
}

func (m *ServiceAccountRuleDefaults) Reset()                    { *m = ServiceAccountRuleDefaults{} }
func (m *ServiceAccountRuleDefaults) String() string            { return proto.CompactTextString(m) }
func (*ServiceAccountRuleDefaults) ProtoMessage()               {}
func (*ServiceAccountRuleDefaults) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{7} }

func (m *ServiceAccountRuleDefaults) GetAllowedScope() []string {
	if m != nil {
		return m.AllowedScope
	}
	return nil
}

func (m *ServiceAccountRuleDefaults) GetMaxGrantValidityDuration() int64 {
	if m != nil {
		return m.MaxGrantValidityDuration
	}
	return 0
}

func init() {
	proto.RegisterType((*TokenServerConfig)(nil), "tokenserver.admin.TokenServerConfig")
	proto.RegisterType((*CertificateAuthorityConfig)(nil), "tokenserver.admin.CertificateAuthorityConfig")
	proto.RegisterType((*DomainConfig)(nil), "tokenserver.admin.DomainConfig")
	proto.RegisterType((*DelegationPermissions)(nil), "tokenserver.admin.DelegationPermissions")
	proto.RegisterType((*DelegationRule)(nil), "tokenserver.admin.DelegationRule")
	proto.RegisterType((*ServiceAccountsPermissions)(nil), "tokenserver.admin.ServiceAccountsPermissions")
	proto.RegisterType((*ServiceAccountRule)(nil), "tokenserver.admin.ServiceAccountRule")
	proto.RegisterType((*ServiceAccountRuleDefaults)(nil), "tokenserver.admin.ServiceAccountRuleDefaults")
}

func init() {
	proto.RegisterFile("go.chromium.org/luci/tokenserver/api/admin/v1/config.proto", fileDescriptor2)
}

var fileDescriptor2 = []byte{
	// 722 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xc1, 0x6e, 0x2a, 0x37,
	0x14, 0xd5, 0x0c, 0x03, 0x0c, 0x0e, 0x21, 0xc4, 0x25, 0xe9, 0x34, 0xa9, 0x54, 0x42, 0x15, 0x95,
	0x2e, 0x0a, 0x6a, 0x5a, 0xa9, 0x52, 0xab, 0x2e, 0xd2, 0x20, 0x55, 0x41, 0x95, 0x1a, 0x4d, 0x92,
	0x2e, 0xba, 0xb1, 0x1c, 0xcf, 0x05, 0xac, 0xcc, 0xd8, 0xc4, 0xf6, 0x04, 0xb2, 0xeb, 0xa6, 0x7f,
	0xd0, 0x4f, 0xe8, 0x67, 0xbe, 0xc5, 0xd3, 0x78, 0x9c, 0x04, 0x04, 0x79, 0x4f, 0x6f, 0x87, 0xcf,
	0x39, 0xf7, 0xfa, 0xde, 0x73, 0xf0, 0xa0, 0x9f, 0xa7, 0x72, 0xc0, 0x66, 0x4a, 0x66, 0x3c, 0xcf,
	0x06, 0x52, 0x4d, 0x87, 0x69, 0xce, 0xf8, 0xd0, 0xc8, 0x7b, 0x10, 0x1a, 0xd4, 0x23, 0xa8, 0x21,
	0x9d, 0xf3, 0x21, 0x4d, 0x32, 0x2e, 0x86, 0x8f, 0xdf, 0x0f, 0x99, 0x14, 0x13, 0x3e, 0x1d, 0xcc,
	0x95, 0x34, 0x12, 0xef, 0xaf, 0xc8, 0x06, 0x56, 0xd2, 0x5b, 0xa0, 0xfd, 0x9b, 0x02, 0xbc, 0xb6,
	0xe0, 0x85, 0x55, 0xe3, 0x3b, 0x74, 0xc0, 0x40, 0x19, 0x3e, 0xe1, 0x8c, 0x1a, 0x20, 0x34, 0x37,
	0x33, 0xa9, 0xb8, 0x79, 0x8a, 0xbc, 0x6e, 0xa5, 0xbf, 0x73, 0xf6, 0xdd, 0x60, 0xa3, 0xcf, 0xe0,
	0xe2, 0x55, 0x7f, 0xfe, 0x2c, 0x2f, 0xbb, 0xc5, 0x1d, 0xb6, 0x85, 0xeb, 0xfd, 0xeb, 0xa3, 0xa3,
	0xb7, 0x8b, 0xf0, 0x31, 0x6a, 0xe4, 0x82, 0x3f, 0xe4, 0x40, 0x78, 0x12, 0xd5, 0xba, 0x5e, 0xbf,
	0x12, 0x87, 0x25, 0x70, 0x99, 0xe0, 0x16, 0xf2, 0x99, 0x88, 0xbc, 0xae, 0xd7, 0x6f, 0xc4, 0x3e,
	0x13, 0x85, 0xb8, 0xb8, 0x83, 0xcc, 0xa9, 0x99, 0x45, 0xbe, 0x85, 0xc3, 0x02, 0xb8, 0xa2, 0x66,
	0x86, 0x3f, 0x47, 0x75, 0xa6, 0x52, 0x92, 0xab, 0x34, 0xaa, 0x58, 0xaa, 0xc6, 0x54, 0x7a, 0xab,
	0x52, 0x7b, 0x85, 0x06, 0x22, 0x8b, 0xf5, 0xa2, 0xa0, 0xeb, 0xf5, 0xc3, 0x38, 0xcc, 0x35, 0xfc,
	0x59, 0x9c, 0xf1, 0x09, 0x6a, 0x5a, 0x82, 0x68, 0x26, 0xe7, 0xa0, 0xa3, 0x7a, 0xb7, 0xd2, 0x6f,
	0xc4, 0x3b, 0x16, 0xbb, 0xb6, 0x10, 0x1e, 0xa1, 0xdd, 0x7b, 0x21, 0x17, 0x82, 0x24, 0x32, 0xa3,
	0x5c, 0xe8, 0xa8, 0x6a, 0xdd, 0xf9, 0x6a, 0x8b, 0x3b, 0x23, 0xab, 0x70, 0x7e, 0x34, 0x6d, 0x55,
	0x09, 0xe9, 0x9e, 0x41, 0xcd, 0x55, 0x16, 0x1f, 0xa2, 0x5a, 0xd9, 0xcf, 0x9a, 0xdd, 0x88, 0xdd,
	0x09, 0xff, 0x88, 0x0e, 0x33, 0xca, 0x66, 0x5c, 0x00, 0xb1, 0xfd, 0x49, 0xca, 0x27, 0x60, 0x78,
	0x06, 0x51, 0xd5, 0xba, 0xd3, 0x71, 0xac, 0x4d, 0xf3, 0x0f, 0xc7, 0x8d, 0x83, 0xd0, 0x6f, 0x57,
	0xc6, 0x41, 0x58, 0x69, 0x07, 0xe3, 0x20, 0x0c, 0xda, 0xd5, 0x71, 0x10, 0xd6, 0xda, 0xf5, 0xde,
	0x15, 0x3a, 0x18, 0x41, 0x0a, 0x53, 0x6a, 0xb8, 0x14, 0x57, 0xa0, 0x32, 0xae, 0x35, 0x97, 0x42,
	0xe3, 0x9f, 0x50, 0x55, 0xe5, 0x29, 0x68, 0x17, 0xf5, 0xc9, 0xb6, 0x65, 0x5e, 0x0a, 0xe3, 0x3c,
	0x85, 0xb8, 0xd4, 0xf7, 0xfe, 0xf3, 0x51, 0x6b, 0x9d, 0xc1, 0x18, 0x05, 0x82, 0x66, 0xe0, 0x82,
	0xb2, 0xbf, 0x71, 0x07, 0x55, 0xe5, 0x42, 0x80, 0x8a, 0x7c, 0xbb, 0x5d, 0x79, 0xc0, 0x5f, 0xa2,
	0x86, 0x82, 0x87, 0x1c, 0xb4, 0x91, 0x2a, 0xaa, 0x58, 0xe6, 0x15, 0x28, 0x56, 0xa7, 0x69, 0x2a,
	0x17, 0x90, 0x10, 0x23, 0x09, 0xcf, 0xe6, 0xa0, 0xb4, 0x14, 0xd4, 0x40, 0x14, 0x58, 0x69, 0xc7,
	0xb1, 0x37, 0xf2, 0xf2, 0x95, 0xc3, 0xdf, 0xa2, 0xf6, 0x73, 0x15, 0xcd, 0x13, 0x0e, 0x82, 0x81,
	0x4d, 0xa8, 0x11, 0xef, 0x39, 0xfc, 0xdc, 0xc1, 0xf8, 0x14, 0xb5, 0x0c, 0x55, 0x53, 0x30, 0xa4,
	0x58, 0x94, 0x33, 0x88, 0x6a, 0x56, 0xb8, 0x5b, 0xa2, 0xd7, 0x25, 0x88, 0xcf, 0xd0, 0x41, 0x46,
	0x97, 0xe4, 0x91, 0xa6, 0x3c, 0xe1, 0xe6, 0x89, 0x24, 0xb9, 0xb2, 0xcb, 0x46, 0x75, 0x9b, 0xc0,
	0x67, 0x19, 0x5d, 0xfe, 0xe5, 0xb8, 0x91, 0xa3, 0x7a, 0xff, 0x7b, 0xe8, 0xc8, 0xd5, 0x9f, 0x33,
	0x26, 0x73, 0x61, 0xf4, 0xaa, 0xdd, 0xbf, 0xac, 0xdb, 0x7d, 0xba, 0xc5, 0xee, 0xf5, 0xea, 0x15,
	0xcb, 0xf1, 0x25, 0x0a, 0x13, 0x98, 0xd0, 0x3c, 0x35, 0xda, 0xfe, 0xeb, 0xb7, 0xbf, 0xcc, 0xcd,
	0xfa, 0x91, 0x2b, 0x8a, 0x5f, 0xca, 0x7b, 0xef, 0x3c, 0x84, 0x37, 0x85, 0x9f, 0x90, 0xe0, 0x37,
	0x68, 0xcf, 0x79, 0x47, 0x68, 0xd9, 0xc0, 0xe5, 0xd8, 0xd2, 0x6b, 0x6d, 0xf1, 0xd7, 0x68, 0xf7,
	0x39, 0x16, 0xfb, 0xb4, 0x5c, 0x86, 0x4d, 0x07, 0xda, 0xb7, 0x85, 0xbf, 0x40, 0x21, 0x88, 0x84,
	0xe4, 0x1a, 0x94, 0xcb, 0xac, 0x0e, 0x22, 0xb9, 0xd5, 0xa0, 0x8a, 0xeb, 0xe7, 0x4a, 0x2e, 0x9f,
	0x5c, 0x44, 0xe5, 0x01, 0xff, 0x8a, 0x8e, 0x8b, 0x68, 0xa6, 0x8a, 0x0a, 0xf3, 0x66, 0x40, 0x51,
	0x46, 0x97, 0xbf, 0x17, 0x8a, 0x8d, 0x94, 0xfe, 0xd9, 0x48, 0x69, 0xd5, 0xa7, 0xcd, 0x99, 0xbd,
	0x2d, 0x33, 0x7f, 0x64, 0x04, 0xff, 0xc3, 0x23, 0xfc, 0x56, 0xff, 0xbb, 0x6a, 0xf3, 0xba, 0xab,
	0xd9, 0x6f, 0xf5, 0x0f, 0xef, 0x03, 0x00, 0x00, 0xff, 0xff, 0x6a, 0x37, 0x7c, 0xa8, 0xe9, 0x05,
	0x00, 0x00,
}
