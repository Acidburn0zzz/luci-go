// Code generated by protoc-gen-go.
// source: github.com/luci/luci-go/tokenserver/api/admin/v1/config.proto
// DO NOT EDIT!

package admin

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// TokenServerConfig is read from tokenserver.cfg in luci-config.
type TokenServerConfig struct {
	// List of CAs we trust.
	CertificateAuthority []*CertificateAuthorityConfig `protobuf:"bytes,1,rep,name=certificate_authority,json=certificateAuthority" json:"certificate_authority,omitempty"`
}

func (m *TokenServerConfig) Reset()                    { *m = TokenServerConfig{} }
func (m *TokenServerConfig) String() string            { return proto.CompactTextString(m) }
func (*TokenServerConfig) ProtoMessage()               {}
func (*TokenServerConfig) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *TokenServerConfig) GetCertificateAuthority() []*CertificateAuthorityConfig {
	if m != nil {
		return m.CertificateAuthority
	}
	return nil
}

// CertificateAuthorityConfig defines a single CA we trust.
//
// Such CA issues certificates for nodes that use The Token Service. Each node
// has a private key and certificate with Common Name set to the FQDN of this
// node, e.g. "CN=slave43-c1.c.chromecompute.google.com.internal".
//
// The Token Server uses this CN to derive an identity string for a machine. It
// splits FQDN into a hostname ("slave43-c1") and a domain name
// ("c.chromecompute.google.com.internal"), searches for a domain name in
// "known_domains" set, and, if it is present, uses parameters described there
// for generating a token with machine_id <hostname>@<token-server-url>.
type CertificateAuthorityConfig struct {
	UniqueId int64  `protobuf:"varint,6,opt,name=unique_id,json=uniqueId" json:"unique_id,omitempty"`
	Cn       string `protobuf:"bytes,1,opt,name=cn" json:"cn,omitempty"`
	CertPath string `protobuf:"bytes,2,opt,name=cert_path,json=certPath" json:"cert_path,omitempty"`
	CrlUrl   string `protobuf:"bytes,3,opt,name=crl_url,json=crlUrl" json:"crl_url,omitempty"`
	UseOauth bool   `protobuf:"varint,4,opt,name=use_oauth,json=useOauth" json:"use_oauth,omitempty"`
	// KnownDomains describes parameters to use for each particular domain.
	KnownDomains []*DomainConfig `protobuf:"bytes,5,rep,name=known_domains,json=knownDomains" json:"known_domains,omitempty"`
}

func (m *CertificateAuthorityConfig) Reset()                    { *m = CertificateAuthorityConfig{} }
func (m *CertificateAuthorityConfig) String() string            { return proto.CompactTextString(m) }
func (*CertificateAuthorityConfig) ProtoMessage()               {}
func (*CertificateAuthorityConfig) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *CertificateAuthorityConfig) GetKnownDomains() []*DomainConfig {
	if m != nil {
		return m.KnownDomains
	}
	return nil
}

// DomainConfig is used inside CertificateAuthorityConfig.
type DomainConfig struct {
	// Domain is domain names of hosts this config applies to.
	Domain []string `protobuf:"bytes,1,rep,name=domain" json:"domain,omitempty"`
	// MachineTokenLifetime is how long generated machine tokens live, in seconds.
	//
	// If 0, machine tokens are not allowed.
	MachineTokenLifetime int64 `protobuf:"varint,5,opt,name=machine_token_lifetime,json=machineTokenLifetime" json:"machine_token_lifetime,omitempty"`
}

func (m *DomainConfig) Reset()                    { *m = DomainConfig{} }
func (m *DomainConfig) String() string            { return proto.CompactTextString(m) }
func (*DomainConfig) ProtoMessage()               {}
func (*DomainConfig) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

// DelegationPermissions is read from delegation.cfg in luci-config.
type DelegationPermissions struct {
	// Rules specify what calls to MintDelegationToken are allowed.
	//
	// Rules are evaluated independently. One and only one rule should match the
	// request to allow the operation. If none rules or more than one rule match,
	// the request will be denied.
	//
	// See DelegationRule comments for more details.
	Rules []*DelegationRule `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty"`
}

func (m *DelegationPermissions) Reset()                    { *m = DelegationPermissions{} }
func (m *DelegationPermissions) String() string            { return proto.CompactTextString(m) }
func (*DelegationPermissions) ProtoMessage()               {}
func (*DelegationPermissions) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *DelegationPermissions) GetRules() []*DelegationRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// DelegationRule describes a single allowed case of using delegation tokens.
//
// An incoming MintDelegationToken request is basically a tuple of:
//  * 'requestor_id' - an identity of whoever makes the request.
//  * 'delegated_identity' - an identity to delegate.
//  * 'audience' - a set of identities that will be able to use the token.
//  * 'services' - a set of services that should accept the token.
//
// A request matches a rule iff:
//  * 'requestor_id' is in 'requestor' set.
//  * 'delegated_identity' is in 'allowed_to_impersonate' set.
//  * 'audience' is a subset of 'allowed_audience' set.
//  * 'service' is a subset of 'target_service' set.
//
// The presence of a matching rule permits to mint the token. The rule also
// provides an upper bound on allowed validity_duration, and the rule's name
// is logged in the audit trail.
type DelegationRule struct {
	// A descriptive name of this rule, for the audit log.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Email of developers that added this rule, to know who to contact.
	Owner []string `protobuf:"bytes,2,rep,name=owner" json:"owner,omitempty"`
	// A set of callers to which this rule applies.
	//
	// Each element is either:
	//  * An identity string ("user:<email>").
	//  * A group reference ("group:<name>").
	Requestor []string `protobuf:"bytes,3,rep,name=requestor" json:"requestor,omitempty"`
	// Identities that are allowed to be delegated/impersonated by the requestor.
	//
	// Each element is either:
	//  * An identity string ("user:<email>").
	//  * A group reference ("group:<name>").
	//  * A special identifier "REQUESTOR" that is substituted by the requestor
	//    identity when evaluating the rule.
	//
	// "REQUESTOR" allows one to generate tokens that delegate their own identity
	// to some target audience.
	AllowedToImpersonate []string `protobuf:"bytes,4,rep,name=allowed_to_impersonate,json=allowedToImpersonate" json:"allowed_to_impersonate,omitempty"`
	// A set of identities that should be able to use the new token.
	//
	// Each element is either:
	//  * An identity string ("user:<email>").
	//  * A group reference ("group:<name>").
	//  * A special identifier "REQUESTOR" that is substituted by the requestor
	//    identity when evaluating the rule.
	//
	// "REQUESTOR" is typically used here for rules that allow requestors to
	// impersonate someone else. The corresponding tokens have the requestor as
	// the only allowed audience.
	AllowedAudience []string `protobuf:"bytes,5,rep,name=allowed_audience,json=allowedAudience" json:"allowed_audience,omitempty"`
	// A set of services that should be able to accept the new token.
	//
	// Each element is a service identity string ("service:<id>").
	TargetService []string `protobuf:"bytes,6,rep,name=target_service,json=targetService" json:"target_service,omitempty"`
	// Maximum allowed validity duration (sec) of minted delegation tokens.
	//
	// Default is 12 hours.
	MaxValidityDuration int64 `protobuf:"varint,7,opt,name=max_validity_duration,json=maxValidityDuration" json:"max_validity_duration,omitempty"`
}

func (m *DelegationRule) Reset()                    { *m = DelegationRule{} }
func (m *DelegationRule) String() string            { return proto.CompactTextString(m) }
func (*DelegationRule) ProtoMessage()               {}
func (*DelegationRule) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func init() {
	proto.RegisterType((*TokenServerConfig)(nil), "tokenserver.admin.TokenServerConfig")
	proto.RegisterType((*CertificateAuthorityConfig)(nil), "tokenserver.admin.CertificateAuthorityConfig")
	proto.RegisterType((*DomainConfig)(nil), "tokenserver.admin.DomainConfig")
	proto.RegisterType((*DelegationPermissions)(nil), "tokenserver.admin.DelegationPermissions")
	proto.RegisterType((*DelegationRule)(nil), "tokenserver.admin.DelegationRule")
}

func init() {
	proto.RegisterFile("github.com/luci/luci-go/tokenserver/api/admin/v1/config.proto", fileDescriptor1)
}

var fileDescriptor1 = []byte{
	// 533 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x74, 0x53, 0x5f, 0x6f, 0xd3, 0x3e,
	0x14, 0x55, 0xff, 0xa5, 0xad, 0x7f, 0x5b, 0x7f, 0x9d, 0x69, 0x47, 0x04, 0x48, 0x8c, 0x4a, 0x48,
	0xe5, 0x61, 0x8d, 0x18, 0x48, 0x3c, 0xf1, 0x30, 0xad, 0x2f, 0x43, 0x48, 0x54, 0xd9, 0xe0, 0xd5,
	0x72, 0x93, 0xdb, 0xd4, 0x5a, 0x62, 0x17, 0xdb, 0x69, 0xe1, 0x7b, 0xf0, 0x09, 0xf9, 0x24, 0x5c,
	0x3b, 0x19, 0x1d, 0xa2, 0xbc, 0x58, 0xbe, 0xe7, 0x9c, 0x7b, 0xaf, 0x4f, 0x4f, 0x4a, 0xde, 0x67,
	0xc2, 0xae, 0xcb, 0xe5, 0x2c, 0x51, 0x45, 0x94, 0x97, 0x89, 0xf0, 0xc7, 0x79, 0xa6, 0x22, 0xab,
	0xee, 0x40, 0x1a, 0xd0, 0x5b, 0xd0, 0x11, 0xdf, 0x88, 0x88, 0xa7, 0x85, 0x90, 0xd1, 0xf6, 0x75,
	0x94, 0x28, 0xb9, 0x12, 0xd9, 0x6c, 0xa3, 0x95, 0x55, 0xf4, 0xe4, 0x81, 0x6c, 0xe6, 0x25, 0x93,
	0x1d, 0x39, 0xb9, 0x75, 0xe0, 0x8d, 0x07, 0xaf, 0xbc, 0x9a, 0x2e, 0xc9, 0x38, 0x01, 0x6d, 0xc5,
	0x4a, 0x24, 0xdc, 0x02, 0xe3, 0xa5, 0x5d, 0x2b, 0x2d, 0xec, 0xf7, 0xb0, 0x71, 0xd6, 0x9a, 0xfe,
	0x77, 0x71, 0x3e, 0xfb, 0x6b, 0xce, 0xec, 0x6a, 0xaf, 0xbf, 0xbc, 0x97, 0x57, 0xd3, 0xe2, 0x51,
	0x72, 0x80, 0x9b, 0xfc, 0x6c, 0x90, 0x27, 0xff, 0x6e, 0xa2, 0x4f, 0x49, 0xbf, 0x94, 0xe2, 0x6b,
	0x09, 0x4c, 0xa4, 0x61, 0x70, 0xd6, 0x98, 0xb6, 0xe2, 0x5e, 0x05, 0x5c, 0xa7, 0x74, 0x40, 0x9a,
	0x89, 0xc4, 0xc7, 0x34, 0xa6, 0xfd, 0x18, 0x6f, 0x4e, 0xec, 0x76, 0xb0, 0x0d, 0xb7, 0xeb, 0xb0,
	0xe9, 0xe1, 0x9e, 0x03, 0x16, 0x58, 0xd3, 0xc7, 0xa4, 0x9b, 0xe8, 0x9c, 0x95, 0x3a, 0x0f, 0x5b,
	0x9e, 0x0a, 0xb0, 0xfc, 0xac, 0x73, 0xbf, 0xc2, 0x00, 0x53, 0xce, 0x5e, 0xd8, 0x46, 0xaa, 0x87,
	0x2b, 0x0c, 0x7c, 0x72, 0x35, 0x9d, 0x93, 0xe3, 0x3b, 0xa9, 0x76, 0x92, 0xa5, 0xaa, 0xe0, 0x42,
	0x9a, 0xb0, 0xe3, 0xad, 0x3f, 0x3f, 0x60, 0x7d, 0xee, 0x15, 0xb5, 0xd9, 0x23, 0xdf, 0x55, 0x41,
	0x66, 0x62, 0xc9, 0xd1, 0x43, 0x96, 0x9e, 0x92, 0xa0, 0x9a, 0xe7, 0x7f, 0x49, 0x7c, 0x4a, 0x55,
	0xd1, 0xb7, 0xe4, 0xb4, 0xe0, 0xc9, 0x5a, 0x48, 0x60, 0x7e, 0x3e, 0xcb, 0xc5, 0x0a, 0xac, 0x28,
	0x00, 0xd7, 0x3a, 0xeb, 0xa3, 0x9a, 0xf5, 0x51, 0x7d, 0xac, 0xb9, 0x0f, 0xed, 0x5e, 0x73, 0xd8,
	0xc2, 0xb3, 0x35, 0x6c, 0xe3, 0xd9, 0x1e, 0x76, 0xf0, 0x0c, 0x86, 0xdd, 0xc9, 0x82, 0x8c, 0xe7,
	0x90, 0x43, 0xc6, 0xad, 0x50, 0x72, 0x01, 0xba, 0x10, 0xc6, 0xe0, 0xcd, 0xd0, 0x77, 0xa4, 0xa3,
	0xcb, 0x1c, 0x4c, 0x9d, 0xe3, 0x8b, 0x43, 0x66, 0x7e, 0x37, 0xc6, 0xa8, 0x8c, 0x2b, 0xfd, 0xe4,
	0x47, 0x93, 0x0c, 0xfe, 0x64, 0x28, 0x25, 0x6d, 0xc9, 0xf1, 0x81, 0x55, 0x0a, 0xfe, 0x4e, 0x47,
	0xa4, 0x83, 0xe6, 0x41, 0x63, 0x06, 0xce, 0x5d, 0x55, 0xd0, 0x67, 0xa4, 0xaf, 0x01, 0x83, 0x33,
	0x56, 0x69, 0x8c, 0xc0, 0x31, 0x7b, 0xc0, 0x59, 0xe7, 0x79, 0xae, 0x76, 0x90, 0xa2, 0x75, 0x26,
	0x8a, 0x0d, 0x68, 0xa3, 0x24, 0x7e, 0x11, 0x18, 0x89, 0x93, 0x8e, 0x6a, 0xf6, 0x56, 0x5d, 0xef,
	0x39, 0xfa, 0x8a, 0x0c, 0xef, 0xbb, 0x78, 0x99, 0x0a, 0x90, 0x09, 0xf8, 0x84, 0xfa, 0xf1, 0xff,
	0x35, 0x7e, 0x59, 0xc3, 0xf4, 0x25, 0x19, 0x58, 0xae, 0x33, 0xb0, 0xcc, 0x19, 0x15, 0x28, 0x0c,
	0xbc, 0xf0, 0xb8, 0x42, 0x6f, 0x2a, 0x90, 0x5e, 0x90, 0x71, 0xc1, 0xbf, 0xb1, 0x2d, 0xcf, 0x45,
	0x8a, 0x9f, 0x21, 0x4b, 0x4b, 0xed, 0xcd, 0x86, 0x5d, 0x9f, 0xc0, 0x23, 0x24, 0xbf, 0xd4, 0xdc,
	0xbc, 0xa6, 0x96, 0x81, 0xff, 0x5b, 0xbd, 0xf9, 0x15, 0x00, 0x00, 0xff, 0xff, 0x68, 0x96, 0x3b,
	0x9b, 0x97, 0x03, 0x00, 0x00,
}
