// Code generated by protoc-gen-go.
// source: github.com/luci/luci-go/tokenserver/api/machine_token.proto
// DO NOT EDIT!

/*
Package tokenserver is a generated protocol buffer package.

It is generated from these files:
	github.com/luci/luci-go/tokenserver/api/machine_token.proto
	github.com/luci/luci-go/tokenserver/api/token_file.proto

It has these top-level messages:
	MachineTokenBody
	MachineTokenEnvelope
	TokenFile
*/
package tokenserver

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The kinds of machine tokens the token server can mint.
//
// Passed to MintMachineToken and InspectMachineToken.
//
// Reserved: 1.
type MachineTokenType int32

const (
	MachineTokenType_UNKNOWN_TYPE       MachineTokenType = 0
	MachineTokenType_LUCI_MACHINE_TOKEN MachineTokenType = 2
)

var MachineTokenType_name = map[int32]string{
	0: "UNKNOWN_TYPE",
	2: "LUCI_MACHINE_TOKEN",
}
var MachineTokenType_value = map[string]int32{
	"UNKNOWN_TYPE":       0,
	"LUCI_MACHINE_TOKEN": 2,
}

func (x MachineTokenType) String() string {
	return proto.EnumName(MachineTokenType_name, int32(x))
}
func (MachineTokenType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// MachineTokenBody describes internal structure of the machine token.
//
// The token will be put in HTTP headers and its body shouldn't be too large.
// For that reason we use unix timestamps instead of google.protobuf.Timestamp
// (no need for microsecond precision), and assume certificate serial numbers
// are smallish uint64 integers (not random blobs).
type MachineTokenBody struct {
	// Machine identity this token conveys (machine FQDN).
	//
	// It is extracted from a Common Name of a certificate used as a basis for
	// the token.
	MachineFqdn string `protobuf:"bytes,1,opt,name=machine_fqdn,json=machineFqdn" json:"machine_fqdn,omitempty"`
	// Service account email that signed this token.
	//
	// When verifying the token backends will check that the issuer is in
	// "auth-token-servers" group.
	IssuedBy string `protobuf:"bytes,2,opt,name=issued_by,json=issuedBy" json:"issued_by,omitempty"`
	// Unix timestamp in seconds when this token was issued. Required.
	IssuedAt uint64 `protobuf:"varint,3,opt,name=issued_at,json=issuedAt" json:"issued_at,omitempty"`
	// Number of seconds the token is considered valid.
	//
	// Usually 3600. Set by the token server. Required.
	Lifetime uint64 `protobuf:"varint,4,opt,name=lifetime" json:"lifetime,omitempty"`
	// Id of a CA that issued machine certificate used to make this token.
	//
	// These IDs are defined in token server config (via unique_id field).
	CaId int64 `protobuf:"varint,5,opt,name=ca_id,json=caId" json:"ca_id,omitempty"`
	// Serial number of the machine certificate used to make this token.
	//
	// ca_id and cert_sn together uniquely identify the certificate, and can be
	// used to check for certificate revocation (by asking token server whether
	// the given certificate is in CRL). Revocation checks are optional, most
	// callers can rely on expiration checks only.
	CertSn uint64 `protobuf:"varint,6,opt,name=cert_sn,json=certSn" json:"cert_sn,omitempty"`
}

func (m *MachineTokenBody) Reset()                    { *m = MachineTokenBody{} }
func (m *MachineTokenBody) String() string            { return proto.CompactTextString(m) }
func (*MachineTokenBody) ProtoMessage()               {}
func (*MachineTokenBody) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *MachineTokenBody) GetMachineFqdn() string {
	if m != nil {
		return m.MachineFqdn
	}
	return ""
}

func (m *MachineTokenBody) GetIssuedBy() string {
	if m != nil {
		return m.IssuedBy
	}
	return ""
}

func (m *MachineTokenBody) GetIssuedAt() uint64 {
	if m != nil {
		return m.IssuedAt
	}
	return 0
}

func (m *MachineTokenBody) GetLifetime() uint64 {
	if m != nil {
		return m.Lifetime
	}
	return 0
}

func (m *MachineTokenBody) GetCaId() int64 {
	if m != nil {
		return m.CaId
	}
	return 0
}

func (m *MachineTokenBody) GetCertSn() uint64 {
	if m != nil {
		return m.CertSn
	}
	return 0
}

// MachineTokenEnvelope is what is actually being serialized and represented
// as a machine token (after being encoded using base64 standard raw encoding).
//
// Resulting token (including base64 encoding) is usually ~500 bytes long.
type MachineTokenEnvelope struct {
	TokenBody []byte `protobuf:"bytes,1,opt,name=token_body,json=tokenBody,proto3" json:"token_body,omitempty"`
	KeyId     string `protobuf:"bytes,2,opt,name=key_id,json=keyId" json:"key_id,omitempty"`
	RsaSha256 []byte `protobuf:"bytes,3,opt,name=rsa_sha256,json=rsaSha256,proto3" json:"rsa_sha256,omitempty"`
}

func (m *MachineTokenEnvelope) Reset()                    { *m = MachineTokenEnvelope{} }
func (m *MachineTokenEnvelope) String() string            { return proto.CompactTextString(m) }
func (*MachineTokenEnvelope) ProtoMessage()               {}
func (*MachineTokenEnvelope) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *MachineTokenEnvelope) GetTokenBody() []byte {
	if m != nil {
		return m.TokenBody
	}
	return nil
}

func (m *MachineTokenEnvelope) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *MachineTokenEnvelope) GetRsaSha256() []byte {
	if m != nil {
		return m.RsaSha256
	}
	return nil
}

func init() {
	proto.RegisterType((*MachineTokenBody)(nil), "tokenserver.MachineTokenBody")
	proto.RegisterType((*MachineTokenEnvelope)(nil), "tokenserver.MachineTokenEnvelope")
	proto.RegisterEnum("tokenserver.MachineTokenType", MachineTokenType_name, MachineTokenType_value)
}

func init() {
	proto.RegisterFile("github.com/luci/luci-go/tokenserver/api/machine_token.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 334 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0x90, 0x5f, 0x4b, 0xeb, 0x30,
	0x18, 0xc6, 0x4f, 0xf7, 0xa7, 0x67, 0xcd, 0x7a, 0x51, 0x72, 0x8e, 0x5a, 0x14, 0x61, 0xee, 0x6a,
	0x08, 0xae, 0xa0, 0xe8, 0x8d, 0xde, 0x6c, 0xa3, 0x62, 0x99, 0xeb, 0xa4, 0xeb, 0x10, 0xaf, 0x42,
	0xda, 0x64, 0x5b, 0xe8, 0xd6, 0x74, 0x6d, 0x36, 0xc8, 0x47, 0xf3, 0xdb, 0x49, 0x53, 0x27, 0xf3,
	0x26, 0xf0, 0xfe, 0x9e, 0xe7, 0x25, 0xcf, 0xfb, 0x80, 0xc7, 0x25, 0x13, 0xab, 0x5d, 0xd4, 0x8f,
	0xf9, 0xc6, 0x59, 0xef, 0x62, 0xa6, 0x9e, 0x9b, 0x25, 0x77, 0x04, 0x4f, 0x68, 0x5a, 0xd0, 0x7c,
	0x4f, 0x73, 0x07, 0x67, 0xcc, 0xd9, 0xe0, 0x78, 0xc5, 0x52, 0x8a, 0x14, 0xef, 0x67, 0x39, 0x17,
	0x1c, 0xb6, 0x8f, 0x4c, 0xdd, 0x4f, 0x0d, 0x58, 0x93, 0xca, 0x14, 0x96, 0x78, 0xc8, 0x89, 0x84,
	0x57, 0xc0, 0x3c, 0x2c, 0x2e, 0xb6, 0x24, 0xb5, 0xb5, 0x8e, 0xd6, 0x33, 0x82, 0xf6, 0x37, 0x7b,
	0xde, 0x92, 0x14, 0x5e, 0x00, 0x83, 0x15, 0xc5, 0x8e, 0x12, 0x14, 0x49, 0xbb, 0xa6, 0xf4, 0x56,
	0x05, 0x86, 0xf2, 0x48, 0xc4, 0xc2, 0xae, 0x77, 0xb4, 0x5e, 0xe3, 0x20, 0x0e, 0x04, 0x3c, 0x07,
	0xad, 0x35, 0x5b, 0x50, 0xc1, 0x36, 0xd4, 0x6e, 0x54, 0xda, 0x61, 0x86, 0xff, 0x40, 0x33, 0xc6,
	0x88, 0x11, 0xbb, 0xd9, 0xd1, 0x7a, 0xf5, 0xa0, 0x11, 0x63, 0x8f, 0xc0, 0x33, 0xf0, 0x37, 0xa6,
	0xb9, 0x40, 0x45, 0x6a, 0xeb, 0xca, 0xaf, 0x97, 0xe3, 0x2c, 0xed, 0x26, 0xe0, 0xff, 0x71, 0x74,
	0x37, 0xdd, 0xd3, 0x35, 0xcf, 0x28, 0xbc, 0x04, 0x40, 0x9d, 0x88, 0x22, 0x4e, 0xa4, 0x0a, 0x6f,
	0x06, 0x86, 0xf8, 0xb9, 0xee, 0x04, 0xe8, 0x09, 0x95, 0xe5, 0x2f, 0x55, 0xee, 0x66, 0x42, 0xa5,
	0x47, 0xca, 0xad, 0xbc, 0xc0, 0xa8, 0x58, 0xe1, 0xdb, 0xfb, 0x07, 0x95, 0xda, 0x0c, 0x8c, 0xbc,
	0xc0, 0x33, 0x05, 0xae, 0x9f, 0x7e, 0xf7, 0x14, 0xca, 0x8c, 0x42, 0x0b, 0x98, 0x73, 0x7f, 0xec,
	0x4f, 0xdf, 0x7d, 0x14, 0x7e, 0xbc, 0xb9, 0xd6, 0x1f, 0x78, 0x0a, 0xe0, 0xeb, 0x7c, 0xe4, 0xa1,
	0xc9, 0x60, 0xf4, 0xe2, 0xf9, 0x2e, 0x0a, 0xa7, 0x63, 0xd7, 0xb7, 0x6a, 0x91, 0xae, 0xaa, 0xbf,
	0xfb, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x8d, 0x5f, 0xcb, 0xbe, 0xb9, 0x01, 0x00, 0x00,
}
