// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/luci/luci-go/logdog/api/endpoints/coordinator/services/v1/tasks.proto

package logdog

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/duration"
import google_protobuf2 "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The type of archival task.
type ArchiveDispatchTask_Tag int32

const (
	ArchiveDispatchTask_TERMINATED ArchiveDispatchTask_Tag = 0
	ArchiveDispatchTask_EXPIRED    ArchiveDispatchTask_Tag = 1
)

var ArchiveDispatchTask_Tag_name = map[int32]string{
	0: "TERMINATED",
	1: "EXPIRED",
}
var ArchiveDispatchTask_Tag_value = map[string]int32{
	"TERMINATED": 0,
	"EXPIRED":    1,
}

func (x ArchiveDispatchTask_Tag) String() string {
	return proto.EnumName(ArchiveDispatchTask_Tag_name, int32(x))
}
func (ArchiveDispatchTask_Tag) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0, 0} }

// ArchiveDispatchTask is an internal task used by the Coordinator to schedule
// an archival dispatch.
type ArchiveDispatchTask struct {
	// The hash ID for the log stream to archive.
	Id  string                  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Tag ArchiveDispatchTask_Tag `protobuf:"varint,2,opt,name=tag,enum=logdog.ArchiveDispatchTask_Tag" json:"tag,omitempty"`
	// Don't waste time archiving the log stream until it is at least this old.
	//
	// This is in place to prevent overly-aggressive archivals from wasting time
	// trying, then failing, becuase the log stream data is still being collected
	// into intermediate storage.
	SettleDelay *google_protobuf.Duration `protobuf:"bytes,3,opt,name=settle_delay,json=settleDelay" json:"settle_delay,omitempty"`
	// The amount of time after the task was created that log stream completeness
	// will be used as a success criteria. If the task's age is older than this
	// value, completeness will not be enforced.
	//
	// The task's age can be calculated by subtracting its lease expiration time
	// (leaseTimestamp) from its enqueued timestamp (enqueueTimestamp).
	CompletePeriod *google_protobuf.Duration `protobuf:"bytes,4,opt,name=complete_period,json=completePeriod" json:"complete_period,omitempty"`
}

func (m *ArchiveDispatchTask) Reset()                    { *m = ArchiveDispatchTask{} }
func (m *ArchiveDispatchTask) String() string            { return proto.CompactTextString(m) }
func (*ArchiveDispatchTask) ProtoMessage()               {}
func (*ArchiveDispatchTask) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *ArchiveDispatchTask) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ArchiveDispatchTask) GetTag() ArchiveDispatchTask_Tag {
	if m != nil {
		return m.Tag
	}
	return ArchiveDispatchTask_TERMINATED
}

func (m *ArchiveDispatchTask) GetSettleDelay() *google_protobuf.Duration {
	if m != nil {
		return m.SettleDelay
	}
	return nil
}

func (m *ArchiveDispatchTask) GetCompletePeriod() *google_protobuf.Duration {
	if m != nil {
		return m.CompletePeriod
	}
	return nil
}

// ArchiveTask is a task queue task description for the archival of a single
// log stream.
type ArchiveTask struct {
	// The name of the project that this stream is bound to.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	// The hash ID of the log stream to archive.
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// The archival key of the log stream. If this key doesn't match the key in
	// the log stream state, the request is superfluous and should be deleted.
	Key []byte `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	// Don't waste time archiving the log stream until it is at least this old.
	//
	// This is in place to prevent overly-aggressive archivals from wasting time
	// trying, then failing, becuase the log stream data is still being collected
	// into intermediate storage.
	SettleDelay *google_protobuf.Duration `protobuf:"bytes,4,opt,name=settle_delay,json=settleDelay" json:"settle_delay,omitempty"`
	// The amount of time after the task was created that log stream completeness
	// will be used as a success criteria. If the task's age is older than this
	// value, completeness will not be enforced.
	//
	// The task's age can be calculated by subtracting its lease expiration time
	// (leaseTimestamp) from its enqueued timestamp (enqueueTimestamp).
	CompletePeriod *google_protobuf.Duration `protobuf:"bytes,5,opt,name=complete_period,json=completePeriod" json:"complete_period,omitempty"`
	// The time when this archive task was dispatched.
	//
	// This time is optional, and will be based on the Coordinator's clock. If not
	// zero, it can be used by the Archivist to avoid superfluous archival
	// processing by asserting that IF this time is close to the Archivist's local
	// clock by a specific threshold, it will punt the archival task.
	//
	// Because archival is dispatched by Tumble, the actual encoding of archival
	// parameters is oftentimes delayed such that the request is dispatched to
	// Pub/Sub before the datastore has been updated.
	DispatchedAt *google_protobuf2.Timestamp `protobuf:"bytes,6,opt,name=dispatched_at,json=dispatchedAt" json:"dispatched_at,omitempty"`
}

func (m *ArchiveTask) Reset()                    { *m = ArchiveTask{} }
func (m *ArchiveTask) String() string            { return proto.CompactTextString(m) }
func (*ArchiveTask) ProtoMessage()               {}
func (*ArchiveTask) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *ArchiveTask) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *ArchiveTask) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ArchiveTask) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *ArchiveTask) GetSettleDelay() *google_protobuf.Duration {
	if m != nil {
		return m.SettleDelay
	}
	return nil
}

func (m *ArchiveTask) GetCompletePeriod() *google_protobuf.Duration {
	if m != nil {
		return m.CompletePeriod
	}
	return nil
}

func (m *ArchiveTask) GetDispatchedAt() *google_protobuf2.Timestamp {
	if m != nil {
		return m.DispatchedAt
	}
	return nil
}

func init() {
	proto.RegisterType((*ArchiveDispatchTask)(nil), "logdog.ArchiveDispatchTask")
	proto.RegisterType((*ArchiveTask)(nil), "logdog.ArchiveTask")
	proto.RegisterEnum("logdog.ArchiveDispatchTask_Tag", ArchiveDispatchTask_Tag_name, ArchiveDispatchTask_Tag_value)
}

func init() {
	proto.RegisterFile("github.com/luci/luci-go/logdog/api/endpoints/coordinator/services/v1/tasks.proto", fileDescriptor2)
}

var fileDescriptor2 = []byte{
	// 379 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x92, 0xcd, 0x8e, 0xd3, 0x30,
	0x14, 0x85, 0x49, 0x3a, 0x74, 0x84, 0x5b, 0x4a, 0x65, 0x36, 0xa1, 0x0b, 0xa6, 0xca, 0xaa, 0x1b,
	0x6c, 0xcd, 0xb0, 0x45, 0x42, 0x45, 0xc9, 0x62, 0x16, 0xa0, 0x2a, 0xca, 0x82, 0x5d, 0xe5, 0xda,
	0xc6, 0x35, 0x4d, 0x72, 0x2d, 0xfb, 0xa6, 0x12, 0xef, 0xc0, 0x33, 0x23, 0xd4, 0xfc, 0x80, 0xc4,
	0x20, 0x21, 0x34, 0x1b, 0xcb, 0x3f, 0xe7, 0x5c, 0x9f, 0xef, 0xda, 0x64, 0x67, 0x2c, 0x1e, 0xdb,
	0x03, 0x93, 0x50, 0xf3, 0xaa, 0x95, 0xb6, 0x1b, 0xde, 0x18, 0xe0, 0x15, 0x18, 0x05, 0x86, 0x0b,
	0x67, 0xb9, 0x6e, 0x94, 0x03, 0xdb, 0x60, 0xe0, 0x12, 0xc0, 0x2b, 0xdb, 0x08, 0x04, 0xcf, 0x83,
	0xf6, 0x67, 0x2b, 0x75, 0xe0, 0xe7, 0x5b, 0x8e, 0x22, 0x9c, 0x02, 0x73, 0x1e, 0x10, 0xe8, 0xb4,
	0x77, 0xae, 0x5e, 0x1b, 0x00, 0x53, 0x69, 0xde, 0xed, 0x1e, 0xda, 0x2f, 0x5c, 0xb5, 0x5e, 0xa0,
	0x85, 0xa6, 0xd7, 0xad, 0x6e, 0xfe, 0x3c, 0x47, 0x5b, 0xeb, 0x80, 0xa2, 0x76, 0xbd, 0x20, 0xfd,
	0x11, 0x91, 0x97, 0x5b, 0x2f, 0x8f, 0xf6, 0xac, 0x33, 0x1b, 0x9c, 0x40, 0x79, 0x2c, 0x45, 0x38,
	0xd1, 0x05, 0x89, 0xad, 0x4a, 0xa2, 0x75, 0xb4, 0x79, 0x56, 0xc4, 0x56, 0xd1, 0x5b, 0x32, 0x41,
	0x61, 0x92, 0x78, 0x1d, 0x6d, 0x16, 0x77, 0x37, 0xac, 0xbf, 0x9e, 0xfd, 0xc5, 0xc9, 0x4a, 0x61,
	0x8a, 0x8b, 0x96, 0xbe, 0x23, 0xf3, 0xa0, 0x11, 0x2b, 0xbd, 0x57, 0xba, 0x12, 0xdf, 0x92, 0xc9,
	0x3a, 0xda, 0xcc, 0xee, 0x5e, 0xb1, 0x3e, 0x12, 0x1b, 0x23, 0xb1, 0x6c, 0x88, 0x5c, 0xcc, 0x7a,
	0x79, 0x76, 0x51, 0xd3, 0x0f, 0xe4, 0x85, 0x84, 0xda, 0x55, 0x1a, 0xf5, 0xde, 0x69, 0x6f, 0x41,
	0x25, 0x57, 0xff, 0x2a, 0xb0, 0x18, 0x1d, 0xbb, 0xce, 0x90, 0xa6, 0x64, 0x52, 0x0a, 0x43, 0x17,
	0x84, 0x94, 0x79, 0xf1, 0xf1, 0xfe, 0xd3, 0xb6, 0xcc, 0xb3, 0xe5, 0x13, 0x3a, 0x23, 0xd7, 0xf9,
	0xe7, 0xdd, 0x7d, 0x91, 0x67, 0xcb, 0x28, 0xfd, 0x1e, 0x93, 0xd9, 0x80, 0xd1, 0x81, 0x27, 0xe4,
	0xda, 0x79, 0xf8, 0xaa, 0x25, 0x0e, 0xf4, 0xe3, 0x72, 0x68, 0x49, 0xfc, 0xab, 0x25, 0x4b, 0x32,
	0x39, 0xe9, 0x1e, 0x6b, 0x5e, 0x5c, 0xa6, 0x0f, 0x88, 0xaf, 0x1e, 0x4b, 0xfc, 0xf4, 0x3f, 0x89,
	0xe9, 0x7b, 0xf2, 0x5c, 0x0d, 0x8f, 0xa1, 0xd5, 0x5e, 0x60, 0x32, 0xed, 0x2a, 0xac, 0x1e, 0x54,
	0x28, 0xc7, 0x7f, 0x50, 0xcc, 0x7f, 0x1b, 0xb6, 0x78, 0x98, 0x76, 0x8a, 0xb7, 0x3f, 0x03, 0x00,
	0x00, 0xff, 0xff, 0x49, 0xdd, 0x06, 0x6c, 0xb3, 0x02, 0x00, 0x00,
}
