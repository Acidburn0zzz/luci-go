<!--
  Copyright 2016 The LUCI Authors. All rights reserved.
  Use of this source code is governed under the Apache License, Version 2.0
  that can be found in the LICENSE file.
  -->

<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/google-signin/google-signin-aware.html">
<link rel="import" href="../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../bower_components/iron-icons/av-icons.html">
<link rel="import" href="../bower_components/iron-icons/editor-icons.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="">

<!--
An element for rendering muxed LogDog log streams.
-->
<dom-module id="logdog-stream-view">

  <template>
    <style is="custom-style">
      #mainView {
        position: relative;
      }

      #buttons {
        position: fixed;
        height: auto;
        padding: 5px;
        background-color: rgba(0, 0, 0, 0.1);
        z-index: 100;
      }
      #buttons > paper-button {
        background-color: white;
      }

      .paper-button-highlight[toggles][active] {
        background-color: #cd6a51;
      }

      .paper-icon-button-highlight[toggles][active] {
        background-color: #cd6a51;
        border-radius: 80%;
      }

      #streamStatus {
        position: fixed;
        right: 16px;
        background-color: #EEEEEE;
        opacity: 0.7;
      }

      #logContent {
        padding-top: 54px; /* Pad around buttons */
        background-color: white;
      }

      .log-entry {
        padding: 0 0 0 0;
        clear: left;
      }

      .log-entry-meta {
        background-color: lightgray;
        padding: 5px;
        border-width: 2px 0px 0px 0px;
        border-color: darkgray;
        border-style: dotted;
        user-select: none;

        font-style: italic;
        font-family: Courier New, Courier, monospace;
        font-size: 10px;

        /* Can be toggled to "flex" by applying .showMeta class to #logs. */
        display: none;
      }
      .log-entry-meta-line {
        padding: 5px;
        border-width: 1px;
        border-style: solid;
        border-color: gray;
        border-radius: 10px;
        margin-right: 10px;
        text-align: center;
      }
      .showMeta .log-entry-meta {
        display: flex;
      }

      /* .log-entry-content { */
      .log-entry-chunk {
        padding: 0 0 0 0;
        margin: 0 0 0 0;
        float: none;
        font-family: Courier New, Courier, monospace;
        font-size: 16px;
        list-style: none;

        border-bottom: 1px solid #CCCCCC;

        /* Can be toggled by applying .wrapLines class to #logs. */
        white-space: pre;
      }

      /*.wrapLines .log-entry-content { */
      .wrapLines .log-entry-chunk {
        white-space: pre-wrap;
        word-break: break-word;
      }

      .logFetchButtonContainer {
        height: auto;
        display: none;
        flex-direction: row;
        background-color: rgba(0, 0, 0, 0.2);
        padding: 2px;
      }

      .logFetchButtonVisible {
        display: flex !important;
      }

      .logFetchButton {
        width: 100%;
        height: 18px;
      }

      .logSplitUpButton {
        background: yellow;
      }
      .logSplitDownButton {
        background: green;
      }

      .logBottomButton {
        background-color: lightcoral;
      }

      #logEnd {
        margin-bottom: 30px;
        background-color: gray;
      }

      .clickable-log-anchor {
        height: 24px;
      }

      #status-bar {
        /* Overlay at the bottom of the page. */
        position: fixed;
        z-index: 9999;
        overflow: hidden;
        bottom: 0;
        left: 0;
        width: 100%;

        text-align: center;
        font-size: 16px;
        background-color: rgba(245, 245, 220, 0.7);
      }
    </style>

    <rpc-client
      id="client"
      auto-token
      host="[[host]]"></rpc-client>

    <!--
      This must be after "rpc-client" so we get the signin event after it
      does.
    -->
    <google-signin-aware
      id="aware"
      on-google-signin-aware-success="_onSignin"></google-signin-aware>

    <!-- Stream view options. -->
    <div id="mainView">
      <div id="buttons">
        <!-- If we have exactly one stream, we will enable users to split. -->
        <template is="dom-if" if="{{showStreamingControls}}">
          <template is="dom-if" if="{{canSplit}}">
            <paper-icon-button title="Split, load logs from end"
                icon="editor:vertical-align-bottom"
                on-tap="_splitClicked">
            </paper-icon-button>
          </template>

          <template is="dom-if" if="{{isSplit}}">
            <paper-icon-button title="Scroll to split"
                icon="editor:vertical-align-center" on-tap="_scrollToSplit">
            </paper-icon-button>
          </template>

          <paper-icon-button class="paper-icon-button-highlight" toggles
              title="Automatically scroll to new logs." icon="icons:update"
              active="{{follow}}">
          </paper-icon-button>

          <paper-icon-button class="paper-icon-button-highlight" toggles
              title="Automatically load logs." icon="{{playingIconName}}"
              active="{{playing}}">
          </paper-icon-button>

          <template is="dom-if" if="{{isSplit}}">
            <paper-icon-button toggles
                title="Load new logs, or backfill from top."
                icon="{{backfillIconName}}"
                active="{{backfill}}">
            </paper-icon-button>
          </template>
        </template>

        <template is="dom-if" if="{{_not(playing)}}">
          <paper-button class="paper-button-highlight" toggles raised
              active="{{wrapLines}}">
            Wrap
          </paper-button>

          <template is="dom-if" if="{{metadata}}">
            <paper-button class="paper-button-highlight" toggles raised
                active="{{showMetadata}}">
              Metadata
            </paper-button>
          </template>
        </template>
      </div>

      <!-- Display current fetching status, if stream data is still loading. -->
      <div id="streamStatus">
        <template is="dom-if" if="{{streamStatus}}">
          <table>
            <template is="dom-repeat" items="{{streamStatus}}">
              <tr>
                <td>{{item.name}}</td>
                <td>{{item.desc}}</td>
              </tr>
            </template>
          </table>
        </template>
      </div>

      <!-- Muxed log content. -->
      <div id="logContent"
          on-mousewheel="_handleMouseWheel">
        <div id="logs">
          <!-- Content will be populated with JavaScript as logs are loaded.

            <div class="log-entry">
              <div class="log-entry-meta">
                <div class="log-entry-meta-line">(Meta 0)</div>
                ...
                <div class="log-entry-meta-line">(Meta N)</div>
              </div>
              <div class="log-entry-content">
                LINE #0
                ...
                LINE #N
              </div>
            </div>
            ...


            Note that we can't use templating to show/hide the log dividers,
            since our positional log insertion requires them to be present and
            move along with insertions as points of reference.
          -->

          <div id="logSplit" class="logFetchButtonContainer">
            <!-- Insert point (prepend for head, append for tail). -->
            <paper-button id="logSplitUp"
                class="logFetchButton logSplitUpButton giant"
                disabled="[[streamAnchorsNotClickable]]"
                on-click="_handleUpClick">
              <iron-icon icon="file-upload"></iron-icon>
            </paper-button>
            <paper-button id="logSplitDown"
                class="logFetchButton logSplitDownButton giant"
                disabled="[[streamAnchorsNotClickable]]"
                on-click="_handleDownClick">
              <iron-icon icon="file-download"></iron-icon>
            </paper-button>
          </div>

          <div id="logBottom" class="logFetchButtonContainer">
            <!--
              Bottom of the log stream (red bottom line). When tail is complete,
              all future logs get prepended to this.
            -->
            <paper-button id="logBottomButton"
                class="logFetchButton logBottomButton giant"
                disabled="[[streamAnchorsNotClickable]]"
                on-click="_handleBottomClick">
              <iron-icon icon="arrow-drop-down"></iron-icon>
            </paper-button>
          </div>
          <div id="logEnd"></div>
        </div>
      </div>

    </div>

    <template is="dom-if" if="{{statusBar}}">
      <div id="status-bar">{{statusBar.value}}</div>
    </template>
  </template>

</dom-module>

<script>
  "use strict";

  Polymer({
    is: "logdog-stream-view",

    properties: {
      /** The name ([host][:port]) of the pRPC host. */
      host: {
        type: String,
        notify: true,
      },

      /**
       * An array of log stream names to load and mux.
       *
       * Each stream entry is a valid stream path prefixed with that stream's
       * project. For example, for stream "foo/bar/+/baz" in project "chromium",
       * the stream path would be: "chromium/foo/bar/+/baz".
       */
      streams: {
        type: Array,
        value: [],
        notify: true,
        observer: "_streamsChanged",
      },

      toolbarAnchor: {
        type: Object,
        value: null,
      },

      mobile: {
        type: Boolean,
        value: false,
      },

      /**
       * The number of logs to load before forcing a page refresh.
       *
       * The smaller the value, the smoother the page will behave while logs are
       * loading. However, the logs will also load slower because of forced
       * renders in between elements.
       */
      burst: {
        type: Number,
        value: 1000,
        notify: true,
      },

      /**
       * If true, render metadata blocks alongside their log entries.
       *
       * This will cause significantly more HTML elements during rendering (so
       * that each metadata element can show up next to its row) and greatly
       * slow the viewer down.
       */
      metadata: {
        type: Boolean,
        value: false,
      },

      /** If true, show log metadata column. */
      showMetadata: {
        type: Boolean,
        value: false,
        observer: "_showMetadataChanged",
      },

      /** If true, wrap log lines to the screen. */
      wrapLines: {
        type: Boolean,
        value: false,
        observer: "_wrapLinesChanged",
      },

      /**
       * If true, automatically scroll the page to the bottom of the logs
       * while they are streaming.
       */
      follow: {
        type: Boolean,
        value: false,
        observer: "_followChanged",
      },

      canSplit: {
        type: Boolean,
        value: false,
        readOnly: true,
      },

      showStreamingControls: {
        type: Boolean,
        value: true,
        readOnly: true,
      },

      isSplit: {
        type: Boolean,
        value: false,
        readOnly: true,
      },

      streamAnchorsNotClickable: {
        type: Boolean,
        computed:
          '_computeAnchorsNotClickable(playing, showStreamingControls)',
      },

      playing: {
        type: Boolean,
        value: false,
        observer: "_playingChanged",
      },

      playingIconName: {
        type: String,
        computed: '_computePlayingIconName(playing)',
      },

      backfill: {
        type: Boolean,
        value: false,
        observer: "_backfillChanged",
      },

      backfillIconName: {
        type: String,
        computed: '_computeBackfillIconName(backfill)',
      },

      /**
       * The current stream status. This is an Array of objects:
       *   obj.name is the name of the stream.
       *   obj.desc is the status description of the stream.
       */
      streamStatus: {
        type: String,
        value: null,
        notify: true,
        readOnly: true,
      },

      /**
       * The text content of the status element at the bottom of the page.
       */
      statusBar: {
        type: String,
        value: null,
        readOnly: true,
      },
    },

    created: function() {
      this._scrollTimeoutId = null;

      // Create "onScrollHandler", which just invokes "_onScroll" while bound
      // to "this". We create it here so we can unregister it later, since
      // "bind" returns a modified value.
      this._onScrollHandler = function(e) { this._onScroll(e); }.bind(this);
    },

    attached: function() {
      require(["inc/rpc/client", "inc/logdog-stream-view/viewer"],
          function(client, viewer) {
            // Instantiate our view, and install callbacks.
            this._v = viewer;
            this._model = new viewer.Model({
                client: new client.luci_rpc.Client(this.$.client),
                mobile: this.mobile,

                pushLogEntries: this._pushLogEntries.bind(this),
                clearLogEntries: this._clearLogEntries.bind(this),
                updateControls: this._updateControls.bind(this),
                locationIsVisible: this._locationIsVisible.bind(this),
            });
            this._streamsChanged();
          }.bind(this));

      window.addEventListener('scroll', this._onScrollHandler);
    },

    detached: function() {
      // Unregsiter event handlers.
      window.removeEventListener('scroll', this._onScrollHandler);

      // Reset state.
      this.reset();
    },

    stop: function() {
      this.reset();
    },

    /** Clears state and begins fetching log data. */
    reset: function() {
      if ( this._model ) {
        this._model.reset();
      }
      this._resetScroll();
      this._model = null;
      this._renderedLogs = false;
    },

    /**
     * Called each time a scroll event is fired. Since this can be really
     * frequent, this will kick off a "scroll handler" in the background at an
     * interval. Multiple scroll events within that interval will only result
     * in one scroll handler invocation.
     */
    _onScroll: function(e) {
      if ( this._scrollTimeoutId ) {
        return;
      }

      window.setTimeout(function() {
        this._handleScrollEvent(e);
      }.bind(this), 100);
    },

    /** Actual scroll event handler. */
    _handleScrollEvent: function(e) {
      this._resetScroll();

      // Update our button bar position to be relative to the parent's height.
      this._adjustToTop(this.$.buttons);
      this._adjustToTop(this.$.streamStatus);
    },

    _adjustToTop: function(elem) {
      // Update our button bar position to be relative to the parent's height.
      var pageRect = this.$.mainView.getBoundingClientRect();
      var elemRect = elem.getBoundingClientRect();
      var adjusted = (elem.offsetTop + pageRect.top - elemRect.top);
      if ( adjusted < 0 ) {
        adjusted = 0;
      }
      elem.style.top = adjusted;
    },

    /** Clears asynchornous scroll event status. */
    _resetScroll: function() {
      if ( this._scrollTimeoutId !== null ) {
        window.clearTimeout(this._scrollTimeoutId);
        this._scrollTimeoutId = null;
      }
    },

    _handleMouseWheel: function(e) {
      this.follow = false;
    },

    _handleDownClick: function(e) {
      this._model.fetchLocation(this._v.Location.HEAD, true);
    },

    _handleUpClick: function(e) {
      this._model.fetchLocation(this._v.Location.TAIL, true);
    },

    _handleBottomClick: function(e) {
      this._model.fetchLocation(this._v.Location.BOTTOM, true);
    },

    /** Called when the bound log stream variables has changed. */
    _streamsChanged: function() {
      if( ! this._model ) {
        return;
      }

      this._model.resolve(this.streams).then( function() {
        // If we're not on mobile, start with playing state.
        this.playing = (!this.mobile);

        // Perform the initial fetch after resolution.
        this._model.setAutomatic( this.playing );
        this._model.setTailing( ! this.backfill );
        this._model.fetch(false);
      }.bind(this) );
    },

    _appendMetaLine: function(root, key, value) {
      var line = document.createElement("div");
      line.className = "log-entry-meta-line";

      if ( key != null ) {
        var e = document.createElement("strong");
        e.textContent = key;
        line.appendChild(e);
      }

      if ( value != null ) {
        var e = document.createElement("span");
        e.textContent = value;
        line.appendChild(e);
      }

      root.appendChild(line);
    },

    _pushLogEntries: function(entries, insertion) {
      // Mark that we've rendered logs (show bars now).
      this._renderedLogs = true;

      // Build our log entry chunk.
      var logEntryChunk = document.createElement("div");
      logEntryChunk.className = "log-entry-chunk";

      var lastLogEntry = logEntryChunk;
      var lines = new Array();

      entries.forEach(function(le) {
        var text = le.text;
        if (!(text && text.lines)) {
          return;
        }

        // If we're rendering metadata, render an element per log entry.
        if( this.metadata ) {
          var entryRow = document.createElement("div");
          entryRow.className = "log-entry";

          // Metadata column.
          var metadataBlock = document.createElement("div");
          metadataBlock.className = "log-entry-meta";

          this._appendMetaLine(metadataBlock, "Timestamp:", le.timestamp);
          this._appendMetaLine(metadataBlock, "Stream:", le.desc.name);
          this._appendMetaLine(metadataBlock, "Index:", le.streamIndex);

          // Log column.
          var logDataBlock = document.createElement("div");
          logDataBlock.className = "log-entry-content";

          le.text.lines.forEach(function(line) {
            lines.push(line.value);
          });

          logDataBlock.textContent = lines.join("\n");
          lines.length = 0;

          entryRow.appendChild(metadataBlock);
          entryRow.appendChild(logDataBlock);

          logEntryChunk.appendChild(entryRow);
          lastLogEntry = entryRow;
        } else {
          // Add this to the lines. We'll assign this directly to logEntryChunk
          // after the loop.
          le.text.lines.forEach(function(line) {
            lines.push(line.value);
          });
        }
      }.bind(this));

      if ( ! this.metadata ) {
        // Only one HTML element: the chunk.
        logEntryChunk.textContent = lines.join("\n");
        lastLogEntry = logEntryChunk;
      }

      // To have styles apply correctly, we need to add it twice, see
      // https://github.com/Polymer/polymer/issues/3100.
      Polymer.dom(this.root).appendChild(logEntryChunk);

      // Add the log entry to the appropriate place.
      var anchor, scrollToTop = false;
      var forceScroll = false;
      switch ( insertion ) {
      case this._v.Location.HEAD:
        // InsertionPoint.HEAD: PREPEND to "logSplit".
        this.$.logs.insertBefore(logEntryChunk, this.$.logSplit);

        // If we're not split, scroll to the log bottom. Otherwise, scroll to
        // the split.
        anchor = lastLogEntry;
        break;

      case this._v.Location.TAIL:
        // InsertionPoint.TAIL: APPEND to "logSplit".
        anchor = this.$.logSplit;

        // Identify the element *after* our insertion point and scroll to it.
        // This provides a semblance of stability as we top-insert.
        //
        // As a special case, if the next element is the log bottom, just
        // scroll to the split, since there is no content to stabilize.
        if ( anchor.nextElementSibling !== this.$.logBottom ) {
          anchor = anchor.nextElementSibling;
        }

        // Insert logs by adding them before the sibling following the log
        // split (append to this.$.logSplit).
        this.$.logs.insertBefore(logEntryChunk, this.$.logSplit.nextSibling);

        // When tailing, always scroll to the anchor point.
        scrollToTop = true;
        forceScroll = true;
        break;

      case this._v.Location.BOTTOM:
        // InsertionPoint.BOTTOM: PREPEND to "logBottom".
        anchor = this.$.logBottom;
        this.$.logs.insertBefore(logEntryChunk, anchor);
        break;
      }

      this._maybeScrollToElement(anchor, scrollToTop, forceScroll);
    },

    _clearLogEntries: function() {
      // Remove all current log elements. */
      for ( var cur = this.$.logs.firstChild; cur; ) {
        var del = cur;
        cur = cur.nextElementSibling;
        if ( del.classList && del.classList.contains('log-entry-chunk') ) {
          this.$.logs.removeChild(del);
        }
      }
    },

    _locationIsVisible: function(l) {
      var anchor;
      switch( l ) {
      case this._v.Location.HEAD:
      case this._v.Location.TAIL:
        anchor = this.$.logSplit;

      case this._v.Location.BOTTOM:
        anchor = this.$.logBottom;

      default:
        return false;
      }
      return this._elementInViewport(anchor);
    },

    _updateControls: function(c) {
      this._setCanSplit(c.canSplit);
      this._setIsSplit(c.split);
      this.toggleClass("logFetchButtonVisible",
          (c.split && this._renderedLogs), this.$.logSplit);
      this.toggleClass("logFetchButtonVisible",
          (c.bottom && this._renderedLogs), this.$.logBottom);

      this._setShowStreamingControls( !c.fullyLoaded );
      if ( c.fullyLoaded ) {
        this.playing = false;
      }

      switch( c.loadingState ) {
      case this._v.LoadingState.NONE:
        this._loadStatusBar(null);
        break;
      case this._v.LoadingState.RESOLVING:
        this._loadStatusBar("Resolving stream names...");
        break;
      case this._v.LoadingState.LOADING:
        this._loadStatusBar("Loading streams...");
        break;
      case this._v.LoadingState.RENDERING:
        this._loadStatusBar("Rendering logs.");
        break;
      case this._v.LoadingState.NEEDS_AUTH:
        this._loadStatusBar("Not authenticated. Please log in.");
        break;
      case this._v.LoadingState.ERROR:
        this._loadStatusBar("Error loading streams (see console).");
        break;
      }

      this._setStreamStatus(c.streamStatus);
    },

    /** Scrolls to the follow anchor point. */
    _maybeScrollToFollow: function() {
      // Determine our anchor element.
      var e;
      if ( this.isSplit && this.backfill ) {
        // Centering on the split element, at the bottom of the page.
        e = this.$.logSplit;
      } else {
        // Scroll to the bottom of the page.
        e = this.$.logEnd;
      }

      this._maybeScrollToElement(e, false, false);
    },

    /**
     * Scrolls to the specified element, centering it at the top or bottom of
     * the view. By default,t his will only happen if "follow" is enabled;
     * however, it can be forced via "force".
     */
    _maybeScrollToElement: function(element, topOfView, force) {
      if (this.follow || force) {
        if ( topOfView ) {
          element.scrollIntoView({
            behavior: "auto",
            block: "end",
          });
        } else {
          // Bug? "block: start" doesn't seem to work the same as false.
          element.scrollIntoView(false);
        }
      }
    },

    /**
     * Callback when "showMetadata" has changed. This adds/removes the
     * "showMeta" CSS class from the metadata column.
     */
    _showMetadataChanged: function(v) {
      this.toggleClass("showMeta", v, this.$.logs);
    },

    /**
     * Callback when "wrapLines" has changed. This adds/removes the
     * "wrapLines" CSS class to the log data.
     */
    _wrapLinesChanged: function(v) {
      this.toggleClass("wrapLines", v, this.$.logs);
     },

    /** Callback when "follow" has changed. */
    _playingChanged: function(v) {
      if( ! this._model ) {
        return;
      }

      // If we're playing, begin log fetching.
      this._model.setAutomatic(v);
    },

    _computePlayingIconName: function(playing) {
      return ( (playing) ?
          "av:pause-circle-outline" : "av:play-circle-outline" );
    },

    /** Callback when "follow" has changed. */
    _backfillChanged: function(v) {
      if( ! this._model ) {
        return;
      }

      // If we're backfilling, then we're not tailing.
      this._model.setTailing(!v);
    },

    _computeBackfillIconName: function(backfill) {
      return ( (backfill) ?
          "editor:border-bottom" : "editor:border-top" );
    },

    /** Callback when "follow" has changed. */
    _followChanged: function(v) {
      if ( ! this._model ) {
        return;
      }

      if ( v ) {
        // If follow is toggled on, automatically begin playing.
        this.playing = true;
        this._maybeScrollToFollow();
      }
    },

    /** Callback when "split" button has been clicked. */
    _splitClicked: function() {
      if( ! this._model ) {
        return;
      }

      // After a split, toggle off playing.
      this._model.split();
      this._model.setTailing(true);
      this.playing = false;
    },

    /** Callback when "split" button has been clicked. */
    _scrollToSplit: function() {
      this._maybeScrollToElement(this.$.logSplit, true, true);
    },

    _computeAnchorsNotClickable: function(playing, showStreamingControls,
                                          rendering) {
      // Anchors are not clickable if we're playing or the controls are
      // not visible.
      return ( playing || (!showStreamingControls) || rendering );
    },

    /** Filter function to invert a value. */
    _not: function(v) {
      return (!v);
    },

    /**
     * Loads text content into the status bar.
     *
     * If null is passed, the status bar will be cleared. If text is passed, the
     * status bar will become visible with the supplied content.
     */
    _loadStatusBar: function(v) {
      var st = null;
      if (v) {
        st = {
          value: v,
        };
      }
      this._setStatusBar(st);
    },

    _onSignin: function() {
      if ( this._model ) {
        this._model.notifyAuthenticationChanged();
      }
    },

    _elementInViewport: function(el) {
      var top = el.offsetTop;
      var left = el.offsetLeft;
      var width = el.offsetWidth;
      var height = el.offsetHeight;

      while(el.offsetParent) {
        el = el.offsetParent;
        top += el.offsetTop;
        left += el.offsetLeft;
      }

      return (
        top < (window.pageYOffset + window.innerHeight) &&
        left < (window.pageXOffset + window.innerWidth) &&
        (top + height) > window.pageYOffset &&
        (left + width) > window.pageXOffset
      );
    },

  });
</script>
