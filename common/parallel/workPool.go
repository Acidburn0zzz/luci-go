// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package parallel

import (
	"sync"

	"github.com/luci/luci-go/common/errors"
)

// WorkPool creates a fixed-size pool of worker goroutines. A supplied generator
// method creates task functions and passes them through to the work pool.
// Available workers will consume tasks from the pool and execute them until the
// generator is finished.
//
// WorkPool blocks until all the generator completes and all workers have
// finished their tasks.
func WorkPool(workers int, gen func(chan<- func() error)) error {
	if workers < 0 {
		return errors.New("invalid number of workers")
	}

	sem := make(Semaphore, workers)
	return errors.MultiErrorFromErrors(Run(sem, gen))
}

// Run executes task functions produced by a generator method. Execution is
// throttled by an optional Semaphore, requiring a token prior to dispatch.
//
// Run returns immediately with the channel of errors being generated by the
// functions your gen function pushes. This channel will be closed after all
// error values are consumed, and will yield one error for every function
// run (so, nil indicates a successful run).
//
// This channel must be consumed, or it can block additional functions from
// being run from gen. A common consumption function is
// errors.MultiErrorFromErrors, which will buffer all non-nil errors into an
// errors.MultiError. Other functions to consider are Must and Ignore (in this
// package).
func Run(sem Semaphore, gen func(chan<- func() error)) <-chan error {
	errchan := make(chan error, cap(sem))
	funchan := make(chan func() error, cap(sem))

	go func() {
		defer close(funchan)
		gen(funchan)
	}()

	go func() {
		grp := sync.WaitGroup{}

		for fn := range funchan {
			sem.Lock()

			grp.Add(1)
			fn := fn

			go func() {
				defer func() {
					sem.Unlock()
					grp.Done()
				}()

				errchan <- fn()
			}()
		}

		grp.Wait()
		close(errchan)
	}()

	return errchan
}

// Must can be used to consume the channel from Run. It asserts that none of
// the functions run return an error. If one returns non-nil, this will panic
// with the first error encountered (which may cause the channel to remain open
// and unprocessed).
func Must(ch <-chan error) {
	for err := range ch {
		if err != nil {
			panic(err)
		}
	}
}

// Ignore can be used to consume the channel from Run. It blocks on all errors
// in the channel and discards them.
func Ignore(ch <-chan error) {
	for range ch {
	}
}
