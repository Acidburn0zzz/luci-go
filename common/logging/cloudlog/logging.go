// Copyright 2015 The LUCI Authors. All rights reserved.
// Use of this source code is governed under the Apache License, Version 2.0
// that can be found in the LICENSE file.

package cloudlog

import (
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"sync/atomic"

	"github.com/luci/luci-go/common/clock"
	"github.com/luci/luci-go/common/cloudlogging"
	"github.com/luci/luci-go/common/logging"
	"golang.org/x/net/context"
)

// generatedInsertIDBaseSize is the size, in bytes, of the InsertIDBase value
// generated by GenerateInsertIDBase.
const generatedInsertIDBaseSize = 32

// Config is a configuration structure for Cloud Logging.
type Config struct {
	// InsertIDBase is the base unique value for log insert IDs. Setting this will
	// cause an InsertID to be generated for each log entry to uniquely identify
	// it to the cloud logging system, avoiding duplicates.
	//
	// A random InsertIDBase value can be generated by calling
	// GenerateInsertIDBase().
	//
	// If this is empty, no InsertID will be generated for log messages, which
	// should generally be fine.
	InsertIDBase string

	// FieldConverter, if not nil, is called to convert a logging Field to a
	// string.
	FieldConverter func(interface{}) string
}

// GenerateInsertIDBase generates and assigns a random InsertIDBase value.
func (c *Config) GenerateInsertIDBase() error {
	buf := make([]byte, generatedInsertIDBaseSize)
	count, err := rand.Read(buf)
	if err != nil {
		return err
	}
	if count != len(buf) {
		panic("cloudlog: generated count is smaller than buffer")
	}
	c.InsertIDBase = hex.EncodeToString(buf)
	return nil
}

// Use installs a cloud logging Logger into the supplied Context.
func Use(ctx context.Context, config Config, client cloudlogging.Client) context.Context {
	counter := new(atomicCounter)

	return logging.SetFactory(ctx, func(factoryCtx context.Context) logging.Logger {
		return &boundCloudLogger{
			Config:  &config,
			ctx:     factoryCtx,
			client:  client,
			index:   counter.next(),
			counter: new(atomicCounter),
		}
	})
}

// boundCloudLogger is a logging.Logger implementation binding the current
// Context to the Cloud Logging singleton.
type boundCloudLogger struct {
	*Config

	ctx    context.Context
	client cloudlogging.Client
	index  int64
	// Allocating atomicCounter ensures proper 8-byte alignment.
	counter *atomicCounter
}

var _ logging.Logger = (*boundCloudLogger)(nil)

func (l *boundCloudLogger) Debugf(fmt string, args ...interface{}) {
	l.LogCall(logging.Debug, 0, fmt, args)
}
func (l *boundCloudLogger) Infof(fmt string, args ...interface{}) {
	l.LogCall(logging.Info, 0, fmt, args)
}
func (l *boundCloudLogger) Warningf(fmt string, args ...interface{}) {
	l.LogCall(logging.Warning, 0, fmt, args)
}
func (l *boundCloudLogger) Errorf(fmt string, args ...interface{}) {
	l.LogCall(logging.Error, 0, fmt, args)
}

func (l *boundCloudLogger) LogCall(level logging.Level, calldepth int, f string, args []interface{}) {
	if len(f) == 0 {
		return
	}

	text := fmt.Sprintf(f, args...)
	fields := logging.GetFields(l.ctx)
	if len(fields) > 0 {
		text = text + " " + fields.String()
	}

	// Add logging fields to labels.
	entry := cloudlogging.Entry{
		Timestamp:   clock.Now(l.ctx),
		Severity:    l.getSeverity(level),
		Labels:      make(map[string]string, len(fields)),
		TextPayload: text,
	}

	// Populate Labels.
	for k, v := range fields {
		val := ""
		if l.FieldConverter != nil {
			val = l.FieldConverter(v)
		} else {
			val = fmt.Sprintf("%v", v)
		}
		entry.Labels[k] = val
	}

	// Generate an InsertID, if we're configured with a base.
	if l.InsertIDBase != "" {
		entry.InsertID = l.generateInsertID()
	}

	l.client.PushEntries([]*cloudlogging.Entry{&entry})
}

func (*boundCloudLogger) getSeverity(l logging.Level) cloudlogging.Severity {
	switch l {
	case logging.Debug:
		return cloudlogging.Debug
	case logging.Info:
		return cloudlogging.Info
	case logging.Warning:
		return cloudlogging.Warning
	case logging.Error:
		return cloudlogging.Error

	default:
		return cloudlogging.Default
	}
}

func (l *boundCloudLogger) generateInsertID() string {
	return fmt.Sprintf("%s.%d.%d", l.InsertIDBase, l.index, l.counter.next())
}

// atomicCounter must be allocated separately. If embedding, use a pointer.
// Stores current counter value.
type atomicCounter int64

func (c *atomicCounter) next() int64 {
	nextPlusOne := atomic.AddInt64((*int64)(c), 1)
	return nextPlusOne - 1
}
