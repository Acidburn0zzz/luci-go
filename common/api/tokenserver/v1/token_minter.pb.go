// Code generated by protoc-gen-go.
// source: token_minter.proto
// DO NOT EDIT!

package tokenserver

import prpccommon "github.com/luci/luci-go/common/prpc"
import prpc "github.com/luci/luci-go/server/prpc"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf1 "github.com/luci/luci-go/common/proto/google"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The kinds of tokens the token server can mint.
type TokenRequest_TokenType int32

const (
	TokenRequest_UNKNOWN_TYPE               TokenRequest_TokenType = 0
	TokenRequest_GOOGLE_OAUTH2_ACCESS_TOKEN TokenRequest_TokenType = 1
)

var TokenRequest_TokenType_name = map[int32]string{
	0: "UNKNOWN_TYPE",
	1: "GOOGLE_OAUTH2_ACCESS_TOKEN",
}
var TokenRequest_TokenType_value = map[string]int32{
	"UNKNOWN_TYPE":               0,
	"GOOGLE_OAUTH2_ACCESS_TOKEN": 1,
}

func (x TokenRequest_TokenType) String() string {
	return proto.EnumName(TokenRequest_TokenType_name, int32(x))
}
func (TokenRequest_TokenType) EnumDescriptor() ([]byte, []int) { return fileDescriptor4, []int{1, 0} }

// Supported ways of singing the request.
type TokenRequest_SignatureAlgorithm int32

const (
	TokenRequest_UNKNOWN_ALGO    TokenRequest_SignatureAlgorithm = 0
	TokenRequest_SHA256_RSA_ALGO TokenRequest_SignatureAlgorithm = 1
)

var TokenRequest_SignatureAlgorithm_name = map[int32]string{
	0: "UNKNOWN_ALGO",
	1: "SHA256_RSA_ALGO",
}
var TokenRequest_SignatureAlgorithm_value = map[string]int32{
	"UNKNOWN_ALGO":    0,
	"SHA256_RSA_ALGO": 1,
}

func (x TokenRequest_SignatureAlgorithm) String() string {
	return proto.EnumName(TokenRequest_SignatureAlgorithm_name, int32(x))
}
func (TokenRequest_SignatureAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor4, []int{1, 1}
}

// Possible kinds of fatal errors.
//
// Non fatal errors are returned as grpc.Internal errors instead.
type MintTokenResponse_ErrorCode int32

const (
	MintTokenResponse_SUCCESS MintTokenResponse_ErrorCode = 0
)

var MintTokenResponse_ErrorCode_name = map[int32]string{
	0: "SUCCESS",
}
var MintTokenResponse_ErrorCode_value = map[string]int32{
	"SUCCESS": 0,
}

func (x MintTokenResponse_ErrorCode) String() string {
	return proto.EnumName(MintTokenResponse_ErrorCode_name, int32(x))
}
func (MintTokenResponse_ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor4, []int{2, 0}
}

// MintTokenRequest wraps a serialized and signed TokenRequest message.
type MintTokenRequest struct {
	// The protobuf-serialized TokenRequest message, signed by the private
	// key that matches TokenRequest.certificate.
	//
	// We have to send it as a byte blob to avoid dealing with possible protobuf
	// serialization inconsistencies when checking the signature.
	SerializedTokenRequest []byte `protobuf:"bytes,1,opt,name=serialized_token_request,json=serializedTokenRequest,proto3" json:"serialized_token_request,omitempty"`
	// The signature of 'serialized_token_parameters' blob.
	//
	// See TokenRequest.signature_algorithm for exact meaning.
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *MintTokenRequest) Reset()                    { *m = MintTokenRequest{} }
func (m *MintTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*MintTokenRequest) ProtoMessage()               {}
func (*MintTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

// TokenRequest contains the actual request parameters.
type TokenRequest struct {
	// The certificate that identifies a caller (as ASN1-serialized blob).
	//
	// It will be used to extract machine FQDN (it's CN of the cert) and CA name
	// to use to check the cert.
	Certificate []byte `protobuf:"bytes,1,opt,name=certificate,proto3" json:"certificate,omitempty"`
	// The signature algorithm used to sign this request.
	//
	// Defines what's in MintTokenRequest.signature field.
	SignatureAlgorithm TokenRequest_SignatureAlgorithm `protobuf:"varint,2,opt,name=signature_algorithm,json=signatureAlgorithm,enum=tokenserver.TokenRequest_SignatureAlgorithm" json:"signature_algorithm,omitempty"`
	// Timestamp when this request was created, by the issuer clock.
	IssuedAt *google_protobuf1.Timestamp `protobuf:"bytes,3,opt,name=issued_at,json=issuedAt" json:"issued_at,omitempty"`
	// The token type being requested.
	//
	// Defines what fields of the response are set.
	TokenType TokenRequest_TokenType `protobuf:"varint,4,opt,name=token_type,json=tokenType,enum=tokenserver.TokenRequest_TokenType" json:"token_type,omitempty"`
	// The list of API scopes to grant to the token.
	//
	// Must not be empty. It is also validated against a whitelist specified in
	// config.DomainConfig.
	Oauth2Scopes []string `protobuf:"bytes,5,rep,name=oauth2_scopes,json=oauth2Scopes" json:"oauth2_scopes,omitempty"`
}

func (m *TokenRequest) Reset()                    { *m = TokenRequest{} }
func (m *TokenRequest) String() string            { return proto.CompactTextString(m) }
func (*TokenRequest) ProtoMessage()               {}
func (*TokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{1} }

func (m *TokenRequest) GetIssuedAt() *google_protobuf1.Timestamp {
	if m != nil {
		return m.IssuedAt
	}
	return nil
}

// MintTokenResponse is returned by 'MintToken' if server processed the request.
//
// It's returned even if server refuses to mint a token. It contains the error
// details in that case.
type MintTokenResponse struct {
	ErrorCode MintTokenResponse_ErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,enum=tokenserver.MintTokenResponse_ErrorCode" json:"error_code,omitempty"`
	// Optional detailed error message.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	// On success (NO_ERROR error code) contains the produced token.
	TokenResponse *TokenResponse `protobuf:"bytes,3,opt,name=token_response,json=tokenResponse" json:"token_response,omitempty"`
}

func (m *MintTokenResponse) Reset()                    { *m = MintTokenResponse{} }
func (m *MintTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*MintTokenResponse) ProtoMessage()               {}
func (*MintTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{2} }

func (m *MintTokenResponse) GetTokenResponse() *TokenResponse {
	if m != nil {
		return m.TokenResponse
	}
	return nil
}

// TokenResponse contains a token requested by TokenRequest.
type TokenResponse struct {
	// The service account associated with the returned token (if any).
	ServiceAccount *ServiceAccount `protobuf:"bytes,1,opt,name=service_account,json=serviceAccount" json:"service_account,omitempty"`
	// The generated token.
	//
	// The exact field set here depends on a requested type of the token, see
	// TokenRequest.token_type.
	//
	// Types that are valid to be assigned to TokenType:
	//	*TokenResponse_GoogleOauth2AccessToken
	TokenType isTokenResponse_TokenType `protobuf_oneof:"token_type"`
}

func (m *TokenResponse) Reset()                    { *m = TokenResponse{} }
func (m *TokenResponse) String() string            { return proto.CompactTextString(m) }
func (*TokenResponse) ProtoMessage()               {}
func (*TokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{3} }

type isTokenResponse_TokenType interface {
	isTokenResponse_TokenType()
}

type TokenResponse_GoogleOauth2AccessToken struct {
	GoogleOauth2AccessToken *OAuth2AccessToken `protobuf:"bytes,20,opt,name=google_oauth2_access_token,json=googleOauth2AccessToken,oneof"`
}

func (*TokenResponse_GoogleOauth2AccessToken) isTokenResponse_TokenType() {}

func (m *TokenResponse) GetTokenType() isTokenResponse_TokenType {
	if m != nil {
		return m.TokenType
	}
	return nil
}

func (m *TokenResponse) GetServiceAccount() *ServiceAccount {
	if m != nil {
		return m.ServiceAccount
	}
	return nil
}

func (m *TokenResponse) GetGoogleOauth2AccessToken() *OAuth2AccessToken {
	if x, ok := m.GetTokenType().(*TokenResponse_GoogleOauth2AccessToken); ok {
		return x.GoogleOauth2AccessToken
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TokenResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TokenResponse_OneofMarshaler, _TokenResponse_OneofUnmarshaler, _TokenResponse_OneofSizer, []interface{}{
		(*TokenResponse_GoogleOauth2AccessToken)(nil),
	}
}

func _TokenResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TokenResponse)
	// token_type
	switch x := m.TokenType.(type) {
	case *TokenResponse_GoogleOauth2AccessToken:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GoogleOauth2AccessToken); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TokenResponse.TokenType has unexpected type %T", x)
	}
	return nil
}

func _TokenResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TokenResponse)
	switch tag {
	case 20: // token_type.google_oauth2_access_token
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OAuth2AccessToken)
		err := b.DecodeMessage(msg)
		m.TokenType = &TokenResponse_GoogleOauth2AccessToken{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TokenResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TokenResponse)
	// token_type
	switch x := m.TokenType.(type) {
	case *TokenResponse_GoogleOauth2AccessToken:
		s := proto.Size(x.GoogleOauth2AccessToken)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*MintTokenRequest)(nil), "tokenserver.MintTokenRequest")
	proto.RegisterType((*TokenRequest)(nil), "tokenserver.TokenRequest")
	proto.RegisterType((*MintTokenResponse)(nil), "tokenserver.MintTokenResponse")
	proto.RegisterType((*TokenResponse)(nil), "tokenserver.TokenResponse")
	proto.RegisterEnum("tokenserver.TokenRequest_TokenType", TokenRequest_TokenType_name, TokenRequest_TokenType_value)
	proto.RegisterEnum("tokenserver.TokenRequest_SignatureAlgorithm", TokenRequest_SignatureAlgorithm_name, TokenRequest_SignatureAlgorithm_value)
	proto.RegisterEnum("tokenserver.MintTokenResponse_ErrorCode", MintTokenResponse_ErrorCode_name, MintTokenResponse_ErrorCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion1

// Client API for TokenMinter service

type TokenMinterClient interface {
	// MintToken generates a new token for an authenticated caller.
	//
	// It checks that provided certificate was signed by some trusted CA, and it
	// is still valid (non-expired and hasn't been revoked). It then checks that
	// the request was signed by the corresponding private key. Finally it checks
	// that the caller is authorized to generate requested kind of token.
	//
	// If everything checks out, it generates and returns a new token.
	//
	// On fatal error it returns detailed error response via same
	// MintTokenResponse. On transient errors it returns generic grpc.Internal
	// error.
	MintToken(ctx context.Context, in *MintTokenRequest, opts ...grpc.CallOption) (*MintTokenResponse, error)
}
type tokenMinterPRPCClient struct {
	client *prpccommon.Client
}

func NewTokenMinterPRPCClient(client *prpccommon.Client) TokenMinterClient {
	return &tokenMinterPRPCClient{client}
}

func (c *tokenMinterPRPCClient) MintToken(ctx context.Context, in *MintTokenRequest, opts ...grpc.CallOption) (*MintTokenResponse, error) {
	out := new(MintTokenResponse)
	err := c.client.Call(ctx, "tokenserver.TokenMinter", "MintToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type tokenMinterClient struct {
	cc *grpc.ClientConn
}

func NewTokenMinterClient(cc *grpc.ClientConn) TokenMinterClient {
	return &tokenMinterClient{cc}
}

func (c *tokenMinterClient) MintToken(ctx context.Context, in *MintTokenRequest, opts ...grpc.CallOption) (*MintTokenResponse, error) {
	out := new(MintTokenResponse)
	err := grpc.Invoke(ctx, "/tokenserver.TokenMinter/MintToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TokenMinter service

type TokenMinterServer interface {
	// MintToken generates a new token for an authenticated caller.
	//
	// It checks that provided certificate was signed by some trusted CA, and it
	// is still valid (non-expired and hasn't been revoked). It then checks that
	// the request was signed by the corresponding private key. Finally it checks
	// that the caller is authorized to generate requested kind of token.
	//
	// If everything checks out, it generates and returns a new token.
	//
	// On fatal error it returns detailed error response via same
	// MintTokenResponse. On transient errors it returns generic grpc.Internal
	// error.
	MintToken(context.Context, *MintTokenRequest) (*MintTokenResponse, error)
}

func RegisterTokenMinterServer(s prpc.Registrar, srv TokenMinterServer) {
	s.RegisterService(&_TokenMinter_serviceDesc, srv)
}

func _TokenMinter_MintToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(MintTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(TokenMinterServer).MintToken(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _TokenMinter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tokenserver.TokenMinter",
	HandlerType: (*TokenMinterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MintToken",
			Handler:    _TokenMinter_MintToken_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptor4 = []byte{
	// 583 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x7c, 0x54, 0xdd, 0x6e, 0xd3, 0x30,
	0x18, 0x5d, 0x18, 0x7f, 0xf9, 0x92, 0x75, 0xc5, 0xe3, 0x27, 0x0a, 0x50, 0xaa, 0xec, 0xa6, 0x17,
	0x28, 0x93, 0x82, 0xf8, 0x91, 0x10, 0x17, 0x59, 0xa9, 0x5a, 0xb1, 0xb5, 0x41, 0x49, 0x2a, 0xb4,
	0x0b, 0x64, 0x65, 0x99, 0xd7, 0x05, 0xda, 0xba, 0xc4, 0x0e, 0x12, 0xbc, 0x13, 0x2f, 0xc1, 0x83,
	0xf0, 0x2c, 0xb8, 0x76, 0xd3, 0x25, 0x2b, 0xe3, 0x2e, 0x3e, 0x3e, 0xdf, 0xb1, 0xcf, 0xf9, 0x3e,
	0x07, 0x10, 0xa7, 0x5f, 0xc9, 0x1c, 0xcf, 0xb2, 0x39, 0x27, 0xb9, 0xbb, 0xc8, 0x29, 0xa7, 0xc8,
	0x90, 0x18, 0x23, 0xf9, 0x77, 0x92, 0xdb, 0xcf, 0x26, 0x94, 0x4e, 0xa6, 0xe4, 0x40, 0x6e, 0x9d,
	0x16, 0xe7, 0x07, 0x3c, 0x9b, 0x11, 0xc6, 0x93, 0xd9, 0x42, 0xb1, 0xed, 0x07, 0x4b, 0x62, 0x96,
	0x12, 0x9c, 0xa4, 0x29, 0x2d, 0xe6, 0x7c, 0x05, 0x9b, 0x4a, 0x44, 0xad, 0x9c, 0x2f, 0xd0, 0x1c,
	0x8a, 0x23, 0xe2, 0x25, 0x16, 0x92, 0x6f, 0x85, 0x50, 0x40, 0x6f, 0xc0, 0x12, 0xa5, 0x59, 0x32,
	0xcd, 0x7e, 0x92, 0x33, 0xac, 0xee, 0x91, 0xab, 0x3d, 0x4b, 0x6b, 0x6b, 0x1d, 0x33, 0x7c, 0x78,
	0xb9, 0x5f, 0xab, 0x7c, 0x02, 0x3a, 0xcb, 0x26, 0xf3, 0x84, 0x17, 0x39, 0xb1, 0x6e, 0x48, 0xea,
	0x25, 0xe0, 0xfc, 0xda, 0x06, 0xb3, 0x46, 0x6f, 0x83, 0x91, 0x92, 0x9c, 0x67, 0xe7, 0x59, 0x9a,
	0x70, 0xb2, 0xd2, 0xae, 0x42, 0xe8, 0x33, 0xec, 0xad, 0xeb, 0x71, 0x32, 0x9d, 0xd0, 0x3c, 0xe3,
	0x17, 0x33, 0x29, 0xdd, 0xf0, 0x9e, 0xbb, 0x95, 0x3c, 0xdc, 0xaa, 0xb2, 0x1b, 0x95, 0x45, 0x7e,
	0x59, 0x13, 0x22, 0xb6, 0x81, 0xa1, 0xd7, 0xa0, 0x67, 0x8c, 0x15, 0xc2, 0x65, 0xc2, 0xad, 0x6d,
	0x21, 0x6a, 0x78, 0xb6, 0xab, 0x72, 0x75, 0xcb, 0x5c, 0xdd, 0xb8, 0xcc, 0x35, 0xbc, 0xab, 0xc8,
	0x3e, 0x47, 0x87, 0x00, 0x2a, 0x17, 0xfe, 0x63, 0x41, 0xac, 0x9b, 0xf2, 0x3a, 0xfb, 0xd7, 0x5f,
	0x47, 0x2e, 0x62, 0x41, 0x0d, 0x75, 0x5e, 0x7e, 0xa2, 0x7d, 0xd8, 0xa1, 0x49, 0xc1, 0x2f, 0x3c,
	0xcc, 0x52, 0xba, 0x20, 0xcc, 0xba, 0xd5, 0xde, 0xee, 0xe8, 0xa1, 0xa9, 0xc0, 0x48, 0x62, 0xce,
	0x3b, 0xd0, 0xd7, 0xc5, 0xa8, 0x09, 0xe6, 0x78, 0x74, 0x34, 0x0a, 0x3e, 0x8d, 0x70, 0x7c, 0xf2,
	0xb1, 0xd7, 0xdc, 0x42, 0x2d, 0xb0, 0xfb, 0x41, 0xd0, 0x3f, 0xee, 0xe1, 0xc0, 0x1f, 0xc7, 0x03,
	0x0f, 0xfb, 0xdd, 0x6e, 0x2f, 0x8a, 0x70, 0x1c, 0x1c, 0xf5, 0x46, 0x4d, 0xcd, 0x79, 0x0b, 0x68,
	0x33, 0x8a, 0xaa, 0x8e, 0x7f, 0xdc, 0x0f, 0x84, 0xce, 0x1e, 0xec, 0x46, 0x03, 0xdf, 0x7b, 0xf9,
	0x0a, 0x87, 0x91, 0xaf, 0x40, 0xcd, 0xf9, 0xa3, 0xc1, 0xbd, 0xca, 0x70, 0xb0, 0x05, 0x15, 0xe6,
	0x50, 0x1f, 0x80, 0xe4, 0x39, 0xcd, 0x71, 0x4a, 0xcf, 0x54, 0xcf, 0x1a, 0x5e, 0xa7, 0x66, 0x7d,
	0xa3, 0xc6, 0xed, 0x2d, 0x0b, 0xba, 0x82, 0x1f, 0xea, 0xa4, 0xfc, 0x5c, 0xfa, 0x57, 0x42, 0x22,
	0x5e, 0x96, 0x4c, 0xd4, 0xc0, 0x08, 0xff, 0x12, 0x1c, 0x2a, 0x0c, 0xf9, 0xd0, 0x28, 0x07, 0x50,
	0x69, 0xad, 0xdb, 0xf4, 0x8f, 0xb0, 0x15, 0x23, 0xdc, 0xe1, 0xd5, 0xa5, 0x63, 0x81, 0xbe, 0x3e,
	0x1f, 0x19, 0x70, 0x27, 0x1a, 0xcb, 0x8c, 0x9a, 0x5b, 0xce, 0x6f, 0x0d, 0x76, 0xea, 0xe6, 0xde,
	0xc3, 0xee, 0x95, 0x57, 0x23, 0x1d, 0x1a, 0xde, 0xe3, 0xda, 0x79, 0x91, 0xe2, 0xf8, 0x8a, 0x12,
	0x36, 0x58, 0x6d, 0x2d, 0xa6, 0xd6, 0x56, 0x43, 0x84, 0x57, 0x0d, 0x16, 0x5a, 0xc2, 0x8f, 0x7a,
	0x4a, 0xd6, 0x7d, 0x29, 0xd8, 0xaa, 0x09, 0x06, 0xfe, 0x92, 0xe7, 0x4b, 0x9a, 0xbc, 0xd1, 0x60,
	0x2b, 0x7c, 0xa4, 0x34, 0x82, 0xe4, 0xca, 0xd6, 0xa1, 0x59, 0x1d, 0x3e, 0xef, 0x04, 0x0c, 0x09,
	0x0f, 0xe5, 0x9f, 0x02, 0x7d, 0x00, 0x7d, 0x9d, 0x3f, 0x7a, 0x7a, 0x5d, 0x5f, 0xe4, 0x58, 0xda,
	0xad, 0xff, 0xb7, 0xed, 0xf4, 0xb6, 0x7c, 0x03, 0x2f, 0xfe, 0x06, 0x00, 0x00, 0xff, 0xff, 0x95,
	0x3c, 0xdc, 0xe6, 0x8c, 0x04, 0x00, 0x00,
}
