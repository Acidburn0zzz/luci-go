// Code generated by protoc-gen-go.
// source: config.proto
// DO NOT EDIT!

package tokenserver

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// TokenServerConfig is read from tokenserver.cfg in luci-config.
type TokenServerConfig struct {
	// List of CAs we trust.
	CertificateAuthority []*CertificateAuthorityConfig `protobuf:"bytes,1,rep,name=certificate_authority,json=certificateAuthority" json:"certificate_authority,omitempty"`
}

func (m *TokenServerConfig) Reset()                    { *m = TokenServerConfig{} }
func (m *TokenServerConfig) String() string            { return proto.CompactTextString(m) }
func (*TokenServerConfig) ProtoMessage()               {}
func (*TokenServerConfig) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *TokenServerConfig) GetCertificateAuthority() []*CertificateAuthorityConfig {
	if m != nil {
		return m.CertificateAuthority
	}
	return nil
}

// CertificateAuthorityConfig defines a single CA we trust.
//
// Such CA issues certificates for nodes that use The Token Service. Each node
// has a private key and certificate with Common Name set to the FQDN of this
// node, e.g. "CN=slave43-c1.c.chromecompute.google.com.internal".
//
// The Token Server uses this CN to derive a name of a service account to
// associate with a node. It splits FQDN into a hostname ("slave43-c1") and
// a domain name ("c.chromecompute.google.com.internal"), searches for a domain
// name in "known_domains" map, and creates a service account in a Cloud Project
// specified there: <hostname>@<project-id>.iam.gserviceaccount.com.
//
// Note that we can't put FQDN in the service account email, since it is limited
// in length and doesn't allow '.' in it.
type CertificateAuthorityConfig struct {
	Cn       string `protobuf:"bytes,1,opt,name=cn" json:"cn,omitempty"`
	CertPath string `protobuf:"bytes,2,opt,name=cert_path,json=certPath" json:"cert_path,omitempty"`
	CrlUrl   string `protobuf:"bytes,3,opt,name=crl_url,json=crlUrl" json:"crl_url,omitempty"`
	UseOauth bool   `protobuf:"varint,4,opt,name=use_oauth,json=useOauth" json:"use_oauth,omitempty"`
	// KnownDomains describes what cloud project to use for nodes in particular
	// domains.
	KnownDomains map[string]*DomainConfig `protobuf:"bytes,5,rep,name=known_domains,json=knownDomains" json:"known_domains,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CertificateAuthorityConfig) Reset()                    { *m = CertificateAuthorityConfig{} }
func (m *CertificateAuthorityConfig) String() string            { return proto.CompactTextString(m) }
func (*CertificateAuthorityConfig) ProtoMessage()               {}
func (*CertificateAuthorityConfig) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *CertificateAuthorityConfig) GetKnownDomains() map[string]*DomainConfig {
	if m != nil {
		return m.KnownDomains
	}
	return nil
}

// DomainConfig is used inside CertificateAuthorityConfig.
type DomainConfig struct {
	// CloudProjectName is a name of Google Cloud Project to create service
	// accounts in.
	//
	// The Token Server's own service account must have Editor permission in this
	// project.
	CloudProjectName string `protobuf:"bytes,1,opt,name=cloud_project_name,json=cloudProjectName" json:"cloud_project_name,omitempty"`
}

func (m *DomainConfig) Reset()                    { *m = DomainConfig{} }
func (m *DomainConfig) String() string            { return proto.CompactTextString(m) }
func (*DomainConfig) ProtoMessage()               {}
func (*DomainConfig) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func init() {
	proto.RegisterType((*TokenServerConfig)(nil), "tokenserver.TokenServerConfig")
	proto.RegisterType((*CertificateAuthorityConfig)(nil), "tokenserver.CertificateAuthorityConfig")
	proto.RegisterType((*DomainConfig)(nil), "tokenserver.DomainConfig")
}

var fileDescriptor1 = []byte{
	// 318 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x52, 0x4f, 0x4b, 0xc3, 0x30,
	0x14, 0x67, 0x9d, 0x9b, 0xdb, 0x5b, 0x95, 0x2d, 0x28, 0xd6, 0x79, 0x91, 0x5e, 0xdc, 0x41, 0x2a,
	0xcc, 0x8b, 0x8a, 0x17, 0x99, 0x9e, 0x04, 0x1d, 0x55, 0x2f, 0x22, 0x86, 0x98, 0x65, 0xae, 0xb6,
	0x4b, 0x66, 0x9a, 0x4e, 0xfa, 0xd9, 0xfc, 0x72, 0x26, 0x69, 0xc5, 0x8a, 0x0a, 0xde, 0xde, 0xef,
	0xdf, 0x7b, 0xfd, 0xb5, 0x05, 0x97, 0x0a, 0x3e, 0x8d, 0x9e, 0x83, 0x85, 0x14, 0x4a, 0xa0, 0x8e,
	0x12, 0x31, 0xe3, 0x29, 0x93, 0x4b, 0x26, 0xfd, 0x57, 0xe8, 0xdd, 0x1a, 0x78, 0x63, 0xe1, 0xc8,
	0xfa, 0xd0, 0x03, 0x6c, 0x52, 0x26, 0x55, 0x34, 0x8d, 0x28, 0x51, 0x0c, 0x93, 0x4c, 0xcd, 0x84,
	0x8c, 0x54, 0xee, 0xd5, 0x76, 0xeb, 0x83, 0xce, 0x70, 0x2f, 0xa8, 0x6c, 0x08, 0x46, 0x5f, 0xce,
	0xb3, 0x4f, 0x63, 0xb1, 0x27, 0xdc, 0xa0, 0xbf, 0x68, 0xfe, 0xbb, 0x03, 0xfd, 0xbf, 0x43, 0x68,
	0x1d, 0x1c, 0xca, 0xf5, 0xa5, 0xda, 0xa0, 0x1d, 0xea, 0x09, 0xed, 0x40, 0xdb, 0xac, 0xc1, 0x0b,
	0xa2, 0x66, 0x9e, 0x63, 0xe9, 0x96, 0x21, 0xc6, 0x1a, 0xa3, 0x2d, 0x58, 0xa5, 0x32, 0xc1, 0x99,
	0x4c, 0xbc, 0xba, 0x95, 0x9a, 0x1a, 0xde, 0xc9, 0xc4, 0xa4, 0xb2, 0x94, 0x61, 0x61, 0x9e, 0xdd,
	0x5b, 0xd1, 0x52, 0x2b, 0x6c, 0x69, 0xe2, 0xda, 0x60, 0xf4, 0x08, 0x6b, 0x31, 0x17, 0x6f, 0x1c,
	0x4f, 0xc4, 0x9c, 0x44, 0x3c, 0xf5, 0x1a, 0xb6, 0xd7, 0xf1, 0x3f, 0x7b, 0x05, 0x97, 0x26, 0x7c,
	0x5e, 0x64, 0x2f, 0xb8, 0x92, 0x79, 0xe8, 0xc6, 0x15, 0xaa, 0x7f, 0x0f, 0xbd, 0x1f, 0x16, 0xd4,
	0x85, 0x7a, 0xcc, 0xf2, 0xb2, 0x98, 0x19, 0xd1, 0x01, 0x34, 0x96, 0x24, 0xc9, 0x98, 0x6d, 0xd5,
	0x19, 0x6e, 0x7f, 0x3b, 0x5f, 0x64, 0xcb, 0x17, 0x59, 0xf8, 0x4e, 0x9c, 0xa3, 0x9a, 0x7f, 0x0a,
	0x6e, 0x55, 0x42, 0xfb, 0x80, 0x68, 0x22, 0xb2, 0x09, 0xd6, 0x1f, 0xf7, 0x85, 0x51, 0x85, 0x39,
	0x99, 0xb3, 0xf2, 0x4a, 0xd7, 0x2a, 0xe3, 0x42, 0xb8, 0xd2, 0xfc, 0x53, 0xd3, 0xfe, 0x02, 0x87,
	0x1f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x99, 0xc0, 0x55, 0x2e, 0x12, 0x02, 0x00, 0x00,
}
