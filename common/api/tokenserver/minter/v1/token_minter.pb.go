// Code generated by protoc-gen-go.
// source: token_minter.proto
// DO NOT EDIT!

/*
Package minter is a generated protocol buffer package.

It is generated from these files:
	token_minter.proto

It has these top-level messages:
	MintMachineTokenRequest
	MachineTokenRequest
	MintMachineTokenResponse
	MachineTokenResponse
	OAuth2AccessToken
	LuciMachineToken
*/
package minter

import prpccommon "github.com/luci/luci-go/common/prpc"
import prpc "github.com/luci/luci-go/server/prpc"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/luci/luci-go/common/proto/google"
import tokenserver "github.com/luci/luci-go/common/api/tokenserver"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// The kinds of tokens the token server can mint.
type TokenType int32

const (
	TokenType_UNKNOWN_TYPE               TokenType = 0
	TokenType_GOOGLE_OAUTH2_ACCESS_TOKEN TokenType = 1
	TokenType_LUCI_MACHINE_TOKEN         TokenType = 2
)

var TokenType_name = map[int32]string{
	0: "UNKNOWN_TYPE",
	1: "GOOGLE_OAUTH2_ACCESS_TOKEN",
	2: "LUCI_MACHINE_TOKEN",
}
var TokenType_value = map[string]int32{
	"UNKNOWN_TYPE":               0,
	"GOOGLE_OAUTH2_ACCESS_TOKEN": 1,
	"LUCI_MACHINE_TOKEN":         2,
}

func (x TokenType) String() string {
	return proto.EnumName(TokenType_name, int32(x))
}
func (TokenType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Supported ways of singing the request.
type SignatureAlgorithm int32

const (
	SignatureAlgorithm_UNKNOWN_ALGO    SignatureAlgorithm = 0
	SignatureAlgorithm_SHA256_RSA_ALGO SignatureAlgorithm = 1
)

var SignatureAlgorithm_name = map[int32]string{
	0: "UNKNOWN_ALGO",
	1: "SHA256_RSA_ALGO",
}
var SignatureAlgorithm_value = map[string]int32{
	"UNKNOWN_ALGO":    0,
	"SHA256_RSA_ALGO": 1,
}

func (x SignatureAlgorithm) String() string {
	return proto.EnumName(SignatureAlgorithm_name, int32(x))
}
func (SignatureAlgorithm) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Possible kinds of fatal errors.
//
// Non fatal errors are returned as grpc.Internal errors instead.
type ErrorCode int32

const (
	ErrorCode_SUCCESS                ErrorCode = 0
	ErrorCode_UNSUPPORTED_SIGNATURE  ErrorCode = 1
	ErrorCode_UNSUPPORTED_TOKEN_TYPE ErrorCode = 2
	ErrorCode_BAD_TIMESTAMP          ErrorCode = 3
	ErrorCode_BAD_CERTIFICATE_FORMAT ErrorCode = 4
	ErrorCode_BAD_SIGNATURE          ErrorCode = 5
	ErrorCode_UNTRUSTED_CERTIFICATE  ErrorCode = 6
	ErrorCode_BAD_TOKEN_ARGUMENTS    ErrorCode = 7
	ErrorCode_TOKEN_MINTING_ERROR    ErrorCode = 8
)

var ErrorCode_name = map[int32]string{
	0: "SUCCESS",
	1: "UNSUPPORTED_SIGNATURE",
	2: "UNSUPPORTED_TOKEN_TYPE",
	3: "BAD_TIMESTAMP",
	4: "BAD_CERTIFICATE_FORMAT",
	5: "BAD_SIGNATURE",
	6: "UNTRUSTED_CERTIFICATE",
	7: "BAD_TOKEN_ARGUMENTS",
	8: "TOKEN_MINTING_ERROR",
}
var ErrorCode_value = map[string]int32{
	"SUCCESS":                0,
	"UNSUPPORTED_SIGNATURE":  1,
	"UNSUPPORTED_TOKEN_TYPE": 2,
	"BAD_TIMESTAMP":          3,
	"BAD_CERTIFICATE_FORMAT": 4,
	"BAD_SIGNATURE":          5,
	"UNTRUSTED_CERTIFICATE":  6,
	"BAD_TOKEN_ARGUMENTS":    7,
	"TOKEN_MINTING_ERROR":    8,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}
func (ErrorCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// MintMachineTokenRequest wraps a serialized and signed MachineTokenRequest
// message.
type MintMachineTokenRequest struct {
	// The protobuf-serialized MachineTokenRequest message, signed by the private
	// key that matches MachineTokenRequest.certificate.
	//
	// We have to send it as a byte blob to avoid dealing with possible protobuf
	// serialization inconsistencies when checking the signature.
	SerializedTokenRequest []byte `protobuf:"bytes,1,opt,name=serialized_token_request,json=serializedTokenRequest,proto3" json:"serialized_token_request,omitempty"`
	// The signature of 'serialized_token_parameters' blob.
	//
	// See MachineTokenRequest.signature_algorithm for exact meaning.
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *MintMachineTokenRequest) Reset()                    { *m = MintMachineTokenRequest{} }
func (m *MintMachineTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*MintMachineTokenRequest) ProtoMessage()               {}
func (*MintMachineTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// MachineTokenRequest contains the actual request parameters.
type MachineTokenRequest struct {
	// The certificate that identifies a caller (as ASN1-serialized blob).
	//
	// It will be used to extract machine FQDN (it's CN of the cert) and CA name
	// to use to check the cert.
	Certificate []byte `protobuf:"bytes,1,opt,name=certificate,proto3" json:"certificate,omitempty"`
	// The signature algorithm used to sign this request.
	//
	// Defines what's in MintMachineTokenRequest.signature field.
	SignatureAlgorithm SignatureAlgorithm `protobuf:"varint,2,opt,name=signature_algorithm,json=signatureAlgorithm,enum=tokenserver.minter.SignatureAlgorithm" json:"signature_algorithm,omitempty"`
	// Timestamp when this request was created, by the issuer clock.
	IssuedAt *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=issued_at,json=issuedAt" json:"issued_at,omitempty"`
	// The token type being requested.
	//
	// Defines what fields of the response are set.
	TokenType TokenType `protobuf:"varint,4,opt,name=token_type,json=tokenType,enum=tokenserver.minter.TokenType" json:"token_type,omitempty"`
	// The list of API scopes to grant to the OAuth2 token.
	//
	// It is validated against a whitelist specified in config.DomainConfig.
	Oauth2Scopes []string `protobuf:"bytes,5,rep,name=oauth2_scopes,json=oauth2Scopes" json:"oauth2_scopes,omitempty"`
}

func (m *MachineTokenRequest) Reset()                    { *m = MachineTokenRequest{} }
func (m *MachineTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*MachineTokenRequest) ProtoMessage()               {}
func (*MachineTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *MachineTokenRequest) GetIssuedAt() *google_protobuf.Timestamp {
	if m != nil {
		return m.IssuedAt
	}
	return nil
}

// MintMachineTokenResponse is returned by 'MintMachineToken' if the server
// processed the request.
//
// It's returned even if server refuses to mint a token. It contains the error
// details in that case.
type MintMachineTokenResponse struct {
	// Possible kinds of fatal errors.
	//
	// Non fatal errors are returned as grpc.Internal errors instead.
	ErrorCode ErrorCode `protobuf:"varint,1,opt,name=error_code,json=errorCode,enum=tokenserver.minter.ErrorCode" json:"error_code,omitempty"`
	// Optional detailed error message.
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
	// On success (SUCCESS error code) contains the produced token.
	TokenResponse *MachineTokenResponse `protobuf:"bytes,3,opt,name=token_response,json=tokenResponse" json:"token_response,omitempty"`
}

func (m *MintMachineTokenResponse) Reset()                    { *m = MintMachineTokenResponse{} }
func (m *MintMachineTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*MintMachineTokenResponse) ProtoMessage()               {}
func (*MintMachineTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *MintMachineTokenResponse) GetTokenResponse() *MachineTokenResponse {
	if m != nil {
		return m.TokenResponse
	}
	return nil
}

// MachineTokenResponse contains a token requested by MachineTokenRequest.
type MachineTokenResponse struct {
	// The service account associated with the returned token (if any).
	ServiceAccount *tokenserver.ServiceAccount `protobuf:"bytes,1,opt,name=service_account,json=serviceAccount" json:"service_account,omitempty"`
	// The generated token.
	//
	// The exact field set here depends on a requested type of the token, see
	// MachineTokenRequest.token_type.
	//
	// Types that are valid to be assigned to TokenType:
	//	*MachineTokenResponse_GoogleOauth2AccessToken
	//	*MachineTokenResponse_LuciMachineToken
	TokenType isMachineTokenResponse_TokenType `protobuf_oneof:"token_type"`
}

func (m *MachineTokenResponse) Reset()                    { *m = MachineTokenResponse{} }
func (m *MachineTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*MachineTokenResponse) ProtoMessage()               {}
func (*MachineTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isMachineTokenResponse_TokenType interface {
	isMachineTokenResponse_TokenType()
}

type MachineTokenResponse_GoogleOauth2AccessToken struct {
	GoogleOauth2AccessToken *OAuth2AccessToken `protobuf:"bytes,20,opt,name=google_oauth2_access_token,json=googleOauth2AccessToken,oneof"`
}
type MachineTokenResponse_LuciMachineToken struct {
	LuciMachineToken *LuciMachineToken `protobuf:"bytes,21,opt,name=luci_machine_token,json=luciMachineToken,oneof"`
}

func (*MachineTokenResponse_GoogleOauth2AccessToken) isMachineTokenResponse_TokenType() {}
func (*MachineTokenResponse_LuciMachineToken) isMachineTokenResponse_TokenType()        {}

func (m *MachineTokenResponse) GetTokenType() isMachineTokenResponse_TokenType {
	if m != nil {
		return m.TokenType
	}
	return nil
}

func (m *MachineTokenResponse) GetServiceAccount() *tokenserver.ServiceAccount {
	if m != nil {
		return m.ServiceAccount
	}
	return nil
}

func (m *MachineTokenResponse) GetGoogleOauth2AccessToken() *OAuth2AccessToken {
	if x, ok := m.GetTokenType().(*MachineTokenResponse_GoogleOauth2AccessToken); ok {
		return x.GoogleOauth2AccessToken
	}
	return nil
}

func (m *MachineTokenResponse) GetLuciMachineToken() *LuciMachineToken {
	if x, ok := m.GetTokenType().(*MachineTokenResponse_LuciMachineToken); ok {
		return x.LuciMachineToken
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MachineTokenResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MachineTokenResponse_OneofMarshaler, _MachineTokenResponse_OneofUnmarshaler, _MachineTokenResponse_OneofSizer, []interface{}{
		(*MachineTokenResponse_GoogleOauth2AccessToken)(nil),
		(*MachineTokenResponse_LuciMachineToken)(nil),
	}
}

func _MachineTokenResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MachineTokenResponse)
	// token_type
	switch x := m.TokenType.(type) {
	case *MachineTokenResponse_GoogleOauth2AccessToken:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GoogleOauth2AccessToken); err != nil {
			return err
		}
	case *MachineTokenResponse_LuciMachineToken:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LuciMachineToken); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MachineTokenResponse.TokenType has unexpected type %T", x)
	}
	return nil
}

func _MachineTokenResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MachineTokenResponse)
	switch tag {
	case 20: // token_type.google_oauth2_access_token
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OAuth2AccessToken)
		err := b.DecodeMessage(msg)
		m.TokenType = &MachineTokenResponse_GoogleOauth2AccessToken{msg}
		return true, err
	case 21: // token_type.luci_machine_token
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LuciMachineToken)
		err := b.DecodeMessage(msg)
		m.TokenType = &MachineTokenResponse_LuciMachineToken{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MachineTokenResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MachineTokenResponse)
	// token_type
	switch x := m.TokenType.(type) {
	case *MachineTokenResponse_GoogleOauth2AccessToken:
		s := proto.Size(x.GoogleOauth2AccessToken)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MachineTokenResponse_LuciMachineToken:
		s := proto.Size(x.LuciMachineToken)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// OAuth2AccessToken represent short lived OAuth2 access token that can be put
// into Authorization header.
//
// Usually it is standard OAuth2 tokens as understood by Google Cloud Platform.
//
// TODO(vadimsh): Remove.
type OAuth2AccessToken struct {
	AccessToken string                     `protobuf:"bytes,1,opt,name=access_token,json=accessToken" json:"access_token,omitempty"`
	TokenType   string                     `protobuf:"bytes,2,opt,name=token_type,json=tokenType" json:"token_type,omitempty"`
	Expiry      *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=expiry" json:"expiry,omitempty"`
}

func (m *OAuth2AccessToken) Reset()                    { *m = OAuth2AccessToken{} }
func (m *OAuth2AccessToken) String() string            { return proto.CompactTextString(m) }
func (*OAuth2AccessToken) ProtoMessage()               {}
func (*OAuth2AccessToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *OAuth2AccessToken) GetExpiry() *google_protobuf.Timestamp {
	if m != nil {
		return m.Expiry
	}
	return nil
}

// LuciMachineToken is short lived machine token.
//
// It is understood only by LUCI backends. It is a bearer token, that embeds
// machine hostname and details about the machine certificate it was issued for.
// It has short lifetime (usually 1h).
//
// It is expected to be sent to backends in 'X-Luci-Machine-Token' HTTP header.
//
// The token here is supposed to be treated as an opaque base64-encoded blob,
// but in reality it is serialized MachineTokenEnvelope, see machine_token.proto
// and read the comment there for more info about the token format.
type LuciMachineToken struct {
	MachineToken string                     `protobuf:"bytes,1,opt,name=machine_token,json=machineToken" json:"machine_token,omitempty"`
	Expiry       *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=expiry" json:"expiry,omitempty"`
}

func (m *LuciMachineToken) Reset()                    { *m = LuciMachineToken{} }
func (m *LuciMachineToken) String() string            { return proto.CompactTextString(m) }
func (*LuciMachineToken) ProtoMessage()               {}
func (*LuciMachineToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *LuciMachineToken) GetExpiry() *google_protobuf.Timestamp {
	if m != nil {
		return m.Expiry
	}
	return nil
}

func init() {
	proto.RegisterType((*MintMachineTokenRequest)(nil), "tokenserver.minter.MintMachineTokenRequest")
	proto.RegisterType((*MachineTokenRequest)(nil), "tokenserver.minter.MachineTokenRequest")
	proto.RegisterType((*MintMachineTokenResponse)(nil), "tokenserver.minter.MintMachineTokenResponse")
	proto.RegisterType((*MachineTokenResponse)(nil), "tokenserver.minter.MachineTokenResponse")
	proto.RegisterType((*OAuth2AccessToken)(nil), "tokenserver.minter.OAuth2AccessToken")
	proto.RegisterType((*LuciMachineToken)(nil), "tokenserver.minter.LuciMachineToken")
	proto.RegisterEnum("tokenserver.minter.TokenType", TokenType_name, TokenType_value)
	proto.RegisterEnum("tokenserver.minter.SignatureAlgorithm", SignatureAlgorithm_name, SignatureAlgorithm_value)
	proto.RegisterEnum("tokenserver.minter.ErrorCode", ErrorCode_name, ErrorCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for TokenMinter service

type TokenMinterClient interface {
	// MintMachineToken generates a new token for an authenticated machine.
	//
	// It checks that provided certificate was signed by some trusted CA, and it
	// is still valid (non-expired and hasn't been revoked). It then checks that
	// the request was signed by the corresponding private key. Finally it checks
	// that the caller is authorized to generate requested kind of token.
	//
	// If everything checks out, it generates and returns a new machine token.
	//
	// On fatal error it returns detailed error response via same
	// MintMachineTokenResponse. On transient errors it returns generic
	// grpc.Internal error.
	MintMachineToken(ctx context.Context, in *MintMachineTokenRequest, opts ...grpc.CallOption) (*MintMachineTokenResponse, error)
}
type tokenMinterPRPCClient struct {
	client *prpccommon.Client
}

func NewTokenMinterPRPCClient(client *prpccommon.Client) TokenMinterClient {
	return &tokenMinterPRPCClient{client}
}

func (c *tokenMinterPRPCClient) MintMachineToken(ctx context.Context, in *MintMachineTokenRequest, opts ...grpc.CallOption) (*MintMachineTokenResponse, error) {
	out := new(MintMachineTokenResponse)
	err := c.client.Call(ctx, "tokenserver.minter.TokenMinter", "MintMachineToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type tokenMinterClient struct {
	cc *grpc.ClientConn
}

func NewTokenMinterClient(cc *grpc.ClientConn) TokenMinterClient {
	return &tokenMinterClient{cc}
}

func (c *tokenMinterClient) MintMachineToken(ctx context.Context, in *MintMachineTokenRequest, opts ...grpc.CallOption) (*MintMachineTokenResponse, error) {
	out := new(MintMachineTokenResponse)
	err := grpc.Invoke(ctx, "/tokenserver.minter.TokenMinter/MintMachineToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TokenMinter service

type TokenMinterServer interface {
	// MintMachineToken generates a new token for an authenticated machine.
	//
	// It checks that provided certificate was signed by some trusted CA, and it
	// is still valid (non-expired and hasn't been revoked). It then checks that
	// the request was signed by the corresponding private key. Finally it checks
	// that the caller is authorized to generate requested kind of token.
	//
	// If everything checks out, it generates and returns a new machine token.
	//
	// On fatal error it returns detailed error response via same
	// MintMachineTokenResponse. On transient errors it returns generic
	// grpc.Internal error.
	MintMachineToken(context.Context, *MintMachineTokenRequest) (*MintMachineTokenResponse, error)
}

func RegisterTokenMinterServer(s prpc.Registrar, srv TokenMinterServer) {
	s.RegisterService(&_TokenMinter_serviceDesc, srv)
}

func _TokenMinter_MintMachineToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MintMachineTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenMinterServer).MintMachineToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenserver.minter.TokenMinter/MintMachineToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenMinterServer).MintMachineToken(ctx, req.(*MintMachineTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TokenMinter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tokenserver.minter.TokenMinter",
	HandlerType: (*TokenMinterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MintMachineToken",
			Handler:    _TokenMinter_MintMachineToken_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptor0 = []byte{
	// 835 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x55, 0xdd, 0x6e, 0xdb, 0x36,
	0x18, 0xad, 0x9d, 0x36, 0xad, 0x3f, 0x3b, 0xa9, 0xca, 0xb4, 0x89, 0xe7, 0xad, 0x5b, 0xe6, 0xfd,
	0x20, 0xc8, 0x36, 0x1b, 0xf0, 0xb0, 0x1f, 0x60, 0xbb, 0x61, 0x1d, 0xd5, 0x11, 0x1a, 0x49, 0x01,
	0x45, 0xa1, 0xd8, 0x15, 0xa1, 0x28, 0xac, 0x23, 0xd4, 0xb2, 0x5c, 0x89, 0x1a, 0xd6, 0x61, 0x2f,
	0xb0, 0x17, 0xd9, 0xd5, 0x9e, 0x65, 0x8f, 0xb0, 0x67, 0x19, 0x45, 0x5a, 0xb1, 0x6c, 0x6b, 0x40,
	0x6e, 0x12, 0xe9, 0x7c, 0x87, 0xe7, 0x7c, 0x7f, 0x94, 0x01, 0x89, 0xe4, 0x2d, 0x9f, 0xb3, 0x38,
	0x9a, 0x0b, 0x9e, 0x0e, 0x16, 0x69, 0x22, 0x12, 0xa4, 0xb1, 0x8c, 0xa7, 0xbf, 0x4a, 0x48, 0x47,
	0x7a, 0x9f, 0x4c, 0x93, 0x64, 0x3a, 0xe3, 0x43, 0xc5, 0xb8, 0xca, 0xdf, 0x0c, 0x45, 0x14, 0xf3,
	0x4c, 0x04, 0xf1, 0x42, 0x1f, 0xea, 0x9d, 0x4d, 0x23, 0x71, 0x93, 0x5f, 0x0d, 0xc2, 0x24, 0x1e,
	0xce, 0xf2, 0x30, 0x52, 0x7f, 0xbe, 0x99, 0x26, 0x43, 0x09, 0xc4, 0xc9, 0x7c, 0x18, 0x2c, 0xa2,
	0x61, 0x45, 0x77, 0x58, 0xfc, 0x8b, 0x42, 0xce, 0x82, 0x30, 0x4c, 0xf2, 0xb9, 0xd0, 0x2a, 0xfd,
	0x77, 0x70, 0x64, 0x4b, 0x43, 0x3b, 0x08, 0x6f, 0xa2, 0x39, 0xa7, 0x05, 0x9f, 0xf0, 0x77, 0xb9,
	0x74, 0x42, 0x3f, 0x42, 0x57, 0x9e, 0x89, 0x82, 0x59, 0xf4, 0x3b, 0xbf, 0x66, 0x3a, 0xed, 0x54,
	0xc7, 0xba, 0x8d, 0xe3, 0xc6, 0x49, 0x87, 0x1c, 0xae, 0xe2, 0x6b, 0x27, 0x3f, 0x82, 0x56, 0x16,
	0x4d, 0xe7, 0x81, 0xc8, 0x53, 0xde, 0x6d, 0x2a, 0xea, 0x0a, 0xe8, 0xff, 0xdd, 0x84, 0x83, 0x3a,
	0xbf, 0x63, 0x68, 0x87, 0x3c, 0x15, 0xd1, 0x9b, 0x28, 0x0c, 0x04, 0x5f, 0x5a, 0x54, 0x21, 0xf4,
	0x1a, 0x0e, 0x6e, 0x65, 0x58, 0x30, 0x9b, 0x26, 0xa9, 0x6c, 0x41, 0xac, 0x1c, 0xf6, 0x47, 0x5f,
	0x0e, 0xb6, 0xbb, 0x38, 0xf0, 0x4a, 0x3a, 0x2e, 0xd9, 0x04, 0x65, 0x5b, 0x18, 0xfa, 0x01, 0x5a,
	0x51, 0x96, 0xe5, 0xb2, 0xcc, 0x40, 0x74, 0x77, 0xa4, 0x5c, 0x7b, 0xd4, 0x1b, 0xe8, 0x01, 0x0c,
	0xca, 0x01, 0x0c, 0x68, 0x39, 0x00, 0xf2, 0x48, 0x93, 0xb1, 0x40, 0x3f, 0x03, 0xe8, 0xc6, 0x88,
	0xf7, 0x0b, 0xde, 0xbd, 0xaf, 0x12, 0x79, 0x5e, 0x97, 0x88, 0xaa, 0x94, 0x4a, 0x12, 0x69, 0x89,
	0xf2, 0x11, 0x7d, 0x06, 0x7b, 0x49, 0x90, 0x8b, 0x9b, 0x11, 0xcb, 0xc2, 0x64, 0xc1, 0xb3, 0xee,
	0x83, 0xe3, 0x9d, 0x93, 0x16, 0xe9, 0x68, 0xd0, 0x53, 0x58, 0xff, 0x9f, 0x06, 0x74, 0xb7, 0x47,
	0x94, 0x2d, 0x12, 0xe9, 0x50, 0xf8, 0xf3, 0x34, 0x4d, 0x52, 0x16, 0x26, 0xd7, 0xba, 0x65, 0xff,
	0xe3, 0x6f, 0x16, 0xac, 0xb1, 0x24, 0x91, 0x16, 0x2f, 0x1f, 0x0b, 0x7f, 0x7d, 0x5a, 0x16, 0x96,
	0x05, 0x53, 0x3d, 0x2b, 0xe9, 0xaf, 0x40, 0x5b, 0x63, 0xc8, 0x85, 0xfd, 0x72, 0xf6, 0xda, 0x74,
	0xd9, 0xa0, 0x93, 0x3a, 0x9b, 0xba, 0x24, 0xc9, 0x9e, 0xa8, 0xbe, 0xf6, 0xff, 0x6a, 0xc2, 0xd3,
	0xda, 0x62, 0xce, 0xe0, 0xf1, 0xc6, 0x92, 0xaa, 0x8a, 0xda, 0xa3, 0x0f, 0xd7, 0xac, 0x3c, 0xcd,
	0xc1, 0x9a, 0x42, 0xf6, 0xb3, 0xb5, 0x77, 0x74, 0x0d, 0x3d, 0x3d, 0x39, 0xb6, 0xec, 0xad, 0xd4,
	0x92, 0xa5, 0xe8, 0x05, 0xee, 0x3e, 0x55, 0x82, 0x5f, 0xd4, 0xe5, 0xee, 0xe2, 0x82, 0x8e, 0x15,
	0x5b, 0x25, 0x76, 0x7e, 0x8f, 0x1c, 0x69, 0x29, 0x37, 0xd8, 0x08, 0x21, 0x0a, 0xa8, 0xb8, 0x6f,
	0x2c, 0xd6, 0x85, 0x2c, 0xd5, 0x9f, 0x29, 0xf5, 0xcf, 0xeb, 0xd4, 0x2f, 0x24, 0xbb, 0x5a, 0xb5,
	0x14, 0x37, 0x66, 0x1b, 0xd8, 0x8b, 0x4e, 0x75, 0x9d, 0xfa, 0x7f, 0x36, 0xe0, 0xc9, 0x56, 0x52,
	0xe8, 0x53, 0xe8, 0xac, 0x55, 0xd4, 0x50, 0x33, 0x6b, 0x07, 0x15, 0xca, 0xf3, 0xb5, 0xad, 0xd4,
	0x43, 0xad, 0xac, 0xdd, 0x08, 0x76, 0xf9, 0x6f, 0x8b, 0x28, 0x7d, 0x7f, 0x87, 0x55, 0x5f, 0x32,
	0xfb, 0x6f, 0xc1, 0xd8, 0xac, 0xa0, 0x58, 0x9f, 0xf5, 0xf2, 0x75, 0x2a, 0x9d, 0xb8, 0x4a, 0x5a,
	0x99, 0x35, 0xef, 0x6a, 0x76, 0xea, 0x43, 0xeb, 0xf6, 0xbe, 0x20, 0x03, 0x3a, 0xbe, 0xf3, 0xca,
	0x71, 0x5f, 0x3b, 0x8c, 0xfe, 0x72, 0x69, 0x1a, 0xf7, 0xd0, 0xc7, 0xd0, 0x9b, 0xb8, 0xee, 0xe4,
	0xc2, 0x64, 0x2e, 0xf6, 0xe9, 0xf9, 0x88, 0xe1, 0xf1, 0xd8, 0xf4, 0x3c, 0x46, 0xdd, 0x57, 0xa6,
	0x63, 0x34, 0xd0, 0x21, 0xa0, 0x0b, 0x7f, 0x6c, 0x31, 0x1b, 0x8f, 0xcf, 0x2d, 0xc7, 0x5c, 0xe2,
	0xcd, 0xd3, 0x9f, 0x00, 0x6d, 0x7f, 0x0f, 0xaa, 0xfa, 0xf8, 0x62, 0xe2, 0x4a, 0xfd, 0x03, 0x78,
	0xec, 0x9d, 0xe3, 0xd1, 0x77, 0xdf, 0x33, 0xe2, 0x61, 0x0d, 0x36, 0x4e, 0xff, 0x6d, 0x40, 0xeb,
	0xf6, 0x12, 0xa1, 0x36, 0x3c, 0xf4, 0x7c, 0xe5, 0x2a, 0xf9, 0x1f, 0xc0, 0x33, 0xdf, 0xf1, 0xfc,
	0xcb, 0x4b, 0x97, 0x50, 0xf3, 0x8c, 0x79, 0xd6, 0xc4, 0xc1, 0xd4, 0x27, 0xa6, 0x4c, 0xa5, 0x07,
	0x87, 0xd5, 0x90, 0xca, 0x44, 0x97, 0xd1, 0x44, 0x4f, 0x60, 0xef, 0x05, 0x96, 0x98, 0x65, 0x9b,
	0x1e, 0xc5, 0xf6, 0xa5, 0xb1, 0x53, 0xd0, 0x0b, 0x68, 0x6c, 0x12, 0x6a, 0xbd, 0xb4, 0xc6, 0x98,
	0x9a, 0xec, 0xa5, 0x4b, 0x6c, 0x4c, 0x8d, 0xfb, 0x25, 0x7d, 0xa5, 0xfe, 0x40, 0x1b, 0x53, 0xe2,
	0x7b, 0x85, 0x76, 0xe5, 0x90, 0xb1, 0x8b, 0x8e, 0xe0, 0x40, 0x89, 0x2b, 0x43, 0x4c, 0x26, 0xbe,
	0x6d, 0x3a, 0xd4, 0x33, 0x1e, 0x16, 0x01, 0x0d, 0xda, 0x96, 0x43, 0x2d, 0x67, 0xc2, 0x4c, 0x42,
	0x5c, 0x62, 0x3c, 0x1a, 0xfd, 0x01, 0x6d, 0xd5, 0x74, 0x5b, 0xed, 0x2b, 0x8a, 0xc1, 0xd8, 0xfc,
	0xea, 0xa0, 0xaf, 0x6a, 0xaf, 0x7c, 0xfd, 0xcf, 0x47, 0xef, 0xeb, 0xbb, 0x91, 0xf5, 0xdd, 0xbf,
	0xda, 0x55, 0xeb, 0xf0, 0xed, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xbf, 0x2f, 0x1a, 0x94, 0x1f,
	0x07, 0x00, 0x00,
}
