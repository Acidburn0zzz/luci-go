// Code generated by protoc-gen-go.
// source: graph_data.proto
// DO NOT EDIT!

package dm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/luci/luci-go/common/proto/google"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Attempt_State int32

const (
	Attempt_NeedsExecution Attempt_State = 0
	Attempt_Executing      Attempt_State = 1
	Attempt_AddingDeps     Attempt_State = 2
	Attempt_Blocked        Attempt_State = 3
	Attempt_Finished       Attempt_State = 4
)

var Attempt_State_name = map[int32]string{
	0: "NeedsExecution",
	1: "Executing",
	2: "AddingDeps",
	3: "Blocked",
	4: "Finished",
}
var Attempt_State_value = map[string]int32{
	"NeedsExecution": 0,
	"Executing":      1,
	"AddingDeps":     2,
	"Blocked":        3,
	"Finished":       4,
}

func (x Attempt_State) String() string {
	return proto.EnumName(Attempt_State_name, int32(x))
}
func (Attempt_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor6, []int{1, 0} }

type Execution_State int32

const (
	Execution_Scheduled Execution_State = 0
	Execution_Running   Execution_State = 1
	Execution_Rejected  Execution_State = 2
	Execution_Finished  Execution_State = 3
	Execution_Crashed   Execution_State = 4
)

var Execution_State_name = map[int32]string{
	0: "Scheduled",
	1: "Running",
	2: "Rejected",
	3: "Finished",
	4: "Crashed",
}
var Execution_State_value = map[string]int32{
	"Scheduled": 0,
	"Running":   1,
	"Rejected":  2,
	"Finished":  3,
	"Crashed":   4,
}

func (x Execution_State) String() string {
	return proto.EnumName(Execution_State_name, int32(x))
}
func (Execution_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor6, []int{2, 0} }

type Quest struct {
	Id *Quest_ID `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// DNE is set to true if this Quest does not exist. None of the following
	// fields are valid if this is set to true.
	DNE  bool        `protobuf:"varint,2,opt,name=DNE" json:"DNE,omitempty"`
	Data *Quest_Data `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	// key is the `id` field of the Attempt.ID
	Attempts map[uint32]*Attempt `protobuf:"bytes,4,rep,name=attempts" json:"attempts,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Partial is true iff the request asked for QuestData, but wasn't able to
	// completely fill it.
	Partial bool `protobuf:"varint,16,opt,name=partial" json:"partial,omitempty"`
}

func (m *Quest) Reset()                    { *m = Quest{} }
func (m *Quest) String() string            { return proto.CompactTextString(m) }
func (*Quest) ProtoMessage()               {}
func (*Quest) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0} }

func (m *Quest) GetId() *Quest_ID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Quest) GetData() *Quest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Quest) GetAttempts() map[uint32]*Attempt {
	if m != nil {
		return m.Attempts
	}
	return nil
}

type Quest_ID struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *Quest_ID) Reset()                    { *m = Quest_ID{} }
func (m *Quest_ID) String() string            { return proto.CompactTextString(m) }
func (*Quest_ID) ProtoMessage()               {}
func (*Quest_ID) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0, 0} }

type Quest_Desc struct {
	DistributorConfigName string `protobuf:"bytes,1,opt,name=distributor_config_name" json:"distributor_config_name,omitempty"`
	JsonPayload           string `protobuf:"bytes,2,opt,name=json_payload" json:"json_payload,omitempty"`
}

func (m *Quest_Desc) Reset()                    { *m = Quest_Desc{} }
func (m *Quest_Desc) String() string            { return proto.CompactTextString(m) }
func (*Quest_Desc) ProtoMessage()               {}
func (*Quest_Desc) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0, 1} }

type Quest_Data struct {
	Created *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=created" json:"created,omitempty"`
	Desc    *Quest_Desc                `protobuf:"bytes,2,opt,name=desc" json:"desc,omitempty"`
}

func (m *Quest_Data) Reset()                    { *m = Quest_Data{} }
func (m *Quest_Data) String() string            { return proto.CompactTextString(m) }
func (*Quest_Data) ProtoMessage()               {}
func (*Quest_Data) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0, 2} }

func (m *Quest_Data) GetCreated() *google_protobuf.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *Quest_Data) GetDesc() *Quest_Desc {
	if m != nil {
		return m.Desc
	}
	return nil
}

type Attempt struct {
	Id *Attempt_ID `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// DNE is set to true if this Attempt does not exist. None of the following
	// fields are valid if this is set to true.
	DNE  bool          `protobuf:"varint,2,opt,name=DNE" json:"DNE,omitempty"`
	Data *Attempt_Data `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	// key is the `id` field of the Execution.ID
	Executions map[uint32]*Execution `protobuf:"bytes,4,rep,name=executions" json:"executions,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	FwdDeps    *AttemptList          `protobuf:"bytes,5,opt,name=fwd_deps" json:"fwd_deps,omitempty"`
	BackDeps   *AttemptList          `protobuf:"bytes,6,opt,name=back_deps" json:"back_deps,omitempty"`
	// Partial values are true iff the request asked for AttemptData, Executions
	// or Deps, but wasn't able to completely fill them. If Partial is omitted,
	// it means that no partial data exists in this Attempt.
	Partial *Attempt_Partial `protobuf:"bytes,16,opt,name=partial" json:"partial,omitempty"`
}

func (m *Attempt) Reset()                    { *m = Attempt{} }
func (m *Attempt) String() string            { return proto.CompactTextString(m) }
func (*Attempt) ProtoMessage()               {}
func (*Attempt) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{1} }

func (m *Attempt) GetId() *Attempt_ID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Attempt) GetData() *Attempt_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Attempt) GetExecutions() map[uint32]*Execution {
	if m != nil {
		return m.Executions
	}
	return nil
}

func (m *Attempt) GetFwdDeps() *AttemptList {
	if m != nil {
		return m.FwdDeps
	}
	return nil
}

func (m *Attempt) GetBackDeps() *AttemptList {
	if m != nil {
		return m.BackDeps
	}
	return nil
}

func (m *Attempt) GetPartial() *Attempt_Partial {
	if m != nil {
		return m.Partial
	}
	return nil
}

type Attempt_ID struct {
	Quest string `protobuf:"bytes,1,opt,name=quest" json:"quest,omitempty"`
	Id    uint32 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
}

func (m *Attempt_ID) Reset()                    { *m = Attempt_ID{} }
func (m *Attempt_ID) String() string            { return proto.CompactTextString(m) }
func (*Attempt_ID) ProtoMessage()               {}
func (*Attempt_ID) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{1, 0} }

type Attempt_Data struct {
	Created       *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=created" json:"created,omitempty"`
	Modified      *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=modified" json:"modified,omitempty"`
	NumExecutions uint32                     `protobuf:"varint,3,opt,name=num_executions" json:"num_executions,omitempty"`
	// Types that are valid to be assigned to AttemptType:
	//	*Attempt_Data_NeedsExecution_
	//	*Attempt_Data_Executing_
	//	*Attempt_Data_AddingDeps_
	//	*Attempt_Data_Blocked_
	//	*Attempt_Data_Finished_
	AttemptType isAttempt_Data_AttemptType `protobuf_oneof:"attempt_type"`
}

func (m *Attempt_Data) Reset()                    { *m = Attempt_Data{} }
func (m *Attempt_Data) String() string            { return proto.CompactTextString(m) }
func (*Attempt_Data) ProtoMessage()               {}
func (*Attempt_Data) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{1, 1} }

type isAttempt_Data_AttemptType interface {
	isAttempt_Data_AttemptType()
}

type Attempt_Data_NeedsExecution_ struct {
	NeedsExecution *Attempt_Data_NeedsExecution `protobuf:"bytes,4,opt,name=needs_execution,oneof"`
}
type Attempt_Data_Executing_ struct {
	Executing *Attempt_Data_Executing `protobuf:"bytes,5,opt,name=executing,oneof"`
}
type Attempt_Data_AddingDeps_ struct {
	AddingDeps *Attempt_Data_AddingDeps `protobuf:"bytes,6,opt,name=adding_deps,oneof"`
}
type Attempt_Data_Blocked_ struct {
	Blocked *Attempt_Data_Blocked `protobuf:"bytes,7,opt,name=blocked,oneof"`
}
type Attempt_Data_Finished_ struct {
	Finished *Attempt_Data_Finished `protobuf:"bytes,8,opt,name=finished,oneof"`
}

func (*Attempt_Data_NeedsExecution_) isAttempt_Data_AttemptType() {}
func (*Attempt_Data_Executing_) isAttempt_Data_AttemptType()      {}
func (*Attempt_Data_AddingDeps_) isAttempt_Data_AttemptType()     {}
func (*Attempt_Data_Blocked_) isAttempt_Data_AttemptType()        {}
func (*Attempt_Data_Finished_) isAttempt_Data_AttemptType()       {}

func (m *Attempt_Data) GetAttemptType() isAttempt_Data_AttemptType {
	if m != nil {
		return m.AttemptType
	}
	return nil
}

func (m *Attempt_Data) GetCreated() *google_protobuf.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *Attempt_Data) GetModified() *google_protobuf.Timestamp {
	if m != nil {
		return m.Modified
	}
	return nil
}

func (m *Attempt_Data) GetNeedsExecution() *Attempt_Data_NeedsExecution {
	if x, ok := m.GetAttemptType().(*Attempt_Data_NeedsExecution_); ok {
		return x.NeedsExecution
	}
	return nil
}

func (m *Attempt_Data) GetExecuting() *Attempt_Data_Executing {
	if x, ok := m.GetAttemptType().(*Attempt_Data_Executing_); ok {
		return x.Executing
	}
	return nil
}

func (m *Attempt_Data) GetAddingDeps() *Attempt_Data_AddingDeps {
	if x, ok := m.GetAttemptType().(*Attempt_Data_AddingDeps_); ok {
		return x.AddingDeps
	}
	return nil
}

func (m *Attempt_Data) GetBlocked() *Attempt_Data_Blocked {
	if x, ok := m.GetAttemptType().(*Attempt_Data_Blocked_); ok {
		return x.Blocked
	}
	return nil
}

func (m *Attempt_Data) GetFinished() *Attempt_Data_Finished {
	if x, ok := m.GetAttemptType().(*Attempt_Data_Finished_); ok {
		return x.Finished
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Attempt_Data) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Attempt_Data_OneofMarshaler, _Attempt_Data_OneofUnmarshaler, []interface{}{
		(*Attempt_Data_NeedsExecution_)(nil),
		(*Attempt_Data_Executing_)(nil),
		(*Attempt_Data_AddingDeps_)(nil),
		(*Attempt_Data_Blocked_)(nil),
		(*Attempt_Data_Finished_)(nil),
	}
}

func _Attempt_Data_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Attempt_Data)
	// attempt_type
	switch x := m.AttemptType.(type) {
	case *Attempt_Data_NeedsExecution_:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NeedsExecution); err != nil {
			return err
		}
	case *Attempt_Data_Executing_:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Executing); err != nil {
			return err
		}
	case *Attempt_Data_AddingDeps_:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AddingDeps); err != nil {
			return err
		}
	case *Attempt_Data_Blocked_:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Blocked); err != nil {
			return err
		}
	case *Attempt_Data_Finished_:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Finished); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Attempt_Data.AttemptType has unexpected type %T", x)
	}
	return nil
}

func _Attempt_Data_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Attempt_Data)
	switch tag {
	case 4: // attempt_type.needs_execution
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Attempt_Data_NeedsExecution)
		err := b.DecodeMessage(msg)
		m.AttemptType = &Attempt_Data_NeedsExecution_{msg}
		return true, err
	case 5: // attempt_type.executing
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Attempt_Data_Executing)
		err := b.DecodeMessage(msg)
		m.AttemptType = &Attempt_Data_Executing_{msg}
		return true, err
	case 6: // attempt_type.adding_deps
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Attempt_Data_AddingDeps)
		err := b.DecodeMessage(msg)
		m.AttemptType = &Attempt_Data_AddingDeps_{msg}
		return true, err
	case 7: // attempt_type.blocked
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Attempt_Data_Blocked)
		err := b.DecodeMessage(msg)
		m.AttemptType = &Attempt_Data_Blocked_{msg}
		return true, err
	case 8: // attempt_type.finished
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Attempt_Data_Finished)
		err := b.DecodeMessage(msg)
		m.AttemptType = &Attempt_Data_Finished_{msg}
		return true, err
	default:
		return false, nil
	}
}

type Attempt_Data_NeedsExecution struct {
	Pending *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=pending" json:"pending,omitempty"`
}

func (m *Attempt_Data_NeedsExecution) Reset()         { *m = Attempt_Data_NeedsExecution{} }
func (m *Attempt_Data_NeedsExecution) String() string { return proto.CompactTextString(m) }
func (*Attempt_Data_NeedsExecution) ProtoMessage()    {}
func (*Attempt_Data_NeedsExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor6, []int{1, 1, 0}
}

func (m *Attempt_Data_NeedsExecution) GetPending() *google_protobuf.Timestamp {
	if m != nil {
		return m.Pending
	}
	return nil
}

type Attempt_Data_Executing struct {
	CurExecutionId uint32 `protobuf:"varint,1,opt,name=cur_execution_id" json:"cur_execution_id,omitempty"`
}

func (m *Attempt_Data_Executing) Reset()                    { *m = Attempt_Data_Executing{} }
func (m *Attempt_Data_Executing) String() string            { return proto.CompactTextString(m) }
func (*Attempt_Data_Executing) ProtoMessage()               {}
func (*Attempt_Data_Executing) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{1, 1, 1} }

type Attempt_Data_AddingDeps struct {
	NumAdding  uint32 `protobuf:"varint,1,opt,name=num_adding" json:"num_adding,omitempty"`
	NumWaiting uint32 `protobuf:"varint,2,opt,name=num_waiting" json:"num_waiting,omitempty"`
}

func (m *Attempt_Data_AddingDeps) Reset()                    { *m = Attempt_Data_AddingDeps{} }
func (m *Attempt_Data_AddingDeps) String() string            { return proto.CompactTextString(m) }
func (*Attempt_Data_AddingDeps) ProtoMessage()               {}
func (*Attempt_Data_AddingDeps) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{1, 1, 2} }

type Attempt_Data_Blocked struct {
	NumWaiting uint32 `protobuf:"varint,1,opt,name=num_waiting" json:"num_waiting,omitempty"`
}

func (m *Attempt_Data_Blocked) Reset()                    { *m = Attempt_Data_Blocked{} }
func (m *Attempt_Data_Blocked) String() string            { return proto.CompactTextString(m) }
func (*Attempt_Data_Blocked) ProtoMessage()               {}
func (*Attempt_Data_Blocked) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{1, 1, 3} }

type Attempt_Data_Finished struct {
	Expiration *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=expiration" json:"expiration,omitempty"`
	JsonResult string                     `protobuf:"bytes,2,opt,name=json_result" json:"json_result,omitempty"`
}

func (m *Attempt_Data_Finished) Reset()                    { *m = Attempt_Data_Finished{} }
func (m *Attempt_Data_Finished) String() string            { return proto.CompactTextString(m) }
func (*Attempt_Data_Finished) ProtoMessage()               {}
func (*Attempt_Data_Finished) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{1, 1, 4} }

func (m *Attempt_Data_Finished) GetExpiration() *google_protobuf.Timestamp {
	if m != nil {
		return m.Expiration
	}
	return nil
}

type Attempt_Partial struct {
	// Data is true iff the AttemptData should have been filled, but wasn't
	Data bool `protobuf:"varint,1,opt,name=data" json:"data,omitempty"`
	// Executions is true iff the Executions were requested, but not all of
	// them could be loaded.
	Executions bool `protobuf:"varint,2,opt,name=executions" json:"executions,omitempty"`
	// FwdDeps is true iff FwdDeps were requested, but not all of them could be
	// loaded.
	FwdDeps bool `protobuf:"varint,3,opt,name=fwd_deps" json:"fwd_deps,omitempty"`
	// BackDeps is true iff BackDeps were requested, but not all of them could be
	// loaded.
	BackDeps bool `protobuf:"varint,4,opt,name=back_deps" json:"back_deps,omitempty"`
	// Result is true iff the AttemptResults were requested, and this Attempt is
	// Finished, but the result wasn't able to be loaded. This will also be
	// false in the case that the query is authenticated from an Execution whose
	// Attempt doesn't depend on this Attempt.
	Result bool `protobuf:"varint,5,opt,name=result" json:"result,omitempty"`
}

func (m *Attempt_Partial) Reset()                    { *m = Attempt_Partial{} }
func (m *Attempt_Partial) String() string            { return proto.CompactTextString(m) }
func (*Attempt_Partial) ProtoMessage()               {}
func (*Attempt_Partial) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{1, 3} }

type Execution struct {
	Id    *Execution_ID   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	State Execution_State `protobuf:"varint,2,opt,name=state,enum=dm.Execution_State" json:"state,omitempty"`
	Data  *Execution_Data `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	// Partial is true iff the request asked for Executions, but wasn't able to
	// completely fill them.
	Partial bool `protobuf:"varint,16,opt,name=partial" json:"partial,omitempty"`
}

func (m *Execution) Reset()                    { *m = Execution{} }
func (m *Execution) String() string            { return proto.CompactTextString(m) }
func (*Execution) ProtoMessage()               {}
func (*Execution) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{2} }

func (m *Execution) GetId() *Execution_ID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Execution) GetData() *Execution_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

// Execution_Auth is a tuple of the requesting ExecutionID and the activated
// Execution Token (see the ActivateExecution rpc).
type Execution_Auth struct {
	Id    *Execution_ID `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Token []byte        `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *Execution_Auth) Reset()                    { *m = Execution_Auth{} }
func (m *Execution_Auth) String() string            { return proto.CompactTextString(m) }
func (*Execution_Auth) ProtoMessage()               {}
func (*Execution_Auth) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{2, 0} }

func (m *Execution_Auth) GetId() *Execution_ID {
	if m != nil {
		return m.Id
	}
	return nil
}

type Execution_ID struct {
	Quest   string `protobuf:"bytes,1,opt,name=quest" json:"quest,omitempty"`
	Attempt uint32 `protobuf:"varint,2,opt,name=attempt" json:"attempt,omitempty"`
	Id      uint32 `protobuf:"varint,3,opt,name=id" json:"id,omitempty"`
}

func (m *Execution_ID) Reset()                    { *m = Execution_ID{} }
func (m *Execution_ID) String() string            { return proto.CompactTextString(m) }
func (*Execution_ID) ProtoMessage()               {}
func (*Execution_ID) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{2, 1} }

type Execution_Data struct {
	Created            *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=created" json:"created,omitempty"`
	DistributorToken   string                     `protobuf:"bytes,2,opt,name=distributor_token" json:"distributor_token,omitempty"`
	DistributorInfoUrl string                     `protobuf:"bytes,3,opt,name=distributor_info_url" json:"distributor_info_url,omitempty"`
}

func (m *Execution_Data) Reset()                    { *m = Execution_Data{} }
func (m *Execution_Data) String() string            { return proto.CompactTextString(m) }
func (*Execution_Data) ProtoMessage()               {}
func (*Execution_Data) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{2, 2} }

func (m *Execution_Data) GetCreated() *google_protobuf.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

// GraphData defines all of the DM graph data that may be returned from DM.
//
// Currently only WalkGraph returns GraphData, but in the future other APIs will
// explore the graph in other ways, and they'll return this same data structure.
//
// The design of this message is intended to allow clients to easily accumulate
// various GraphData from different sources in order to maintain an in-memory
// cache of data that exists in DM, where that data is discovered across
// multiple RPCs.
type GraphData struct {
	// Quests is the main entry point for all the graph data.
	// key is the `id` field of the QuestID
	Quests map[string]*Quest `protobuf:"bytes,1,rep,name=quests" json:"quests,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// HadErrors is set to true if the data represented here is a partial view
	// of the requested data due to internal errors. The request may be repeated
	// or the client may chose to make smaller queries into the portions of the
	// graph that are missing.
	//
	// If HadErrors is set HadMore will also be set.
	HadErrors bool `protobuf:"varint,2,opt,name=had_errors" json:"had_errors,omitempty"`
	// HadMore is set to true if the request stopped short of the full query
	// result set due to things like:
	//   * max response size limit
	//   * max time limit (e.g. WalkGraphReq.MaxTime) being hit
	//   * non-terminal errors encountered during the request (HadErrors will also
	//     be true in this case).
	//
	// Note that this is different than the Partial booleans: This refers
	// specifically to situations when Queries do not run to completion.
	HadMore bool `protobuf:"varint,3,opt,name=had_more" json:"had_more,omitempty"`
}

func (m *GraphData) Reset()                    { *m = GraphData{} }
func (m *GraphData) String() string            { return proto.CompactTextString(m) }
func (*GraphData) ProtoMessage()               {}
func (*GraphData) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{3} }

func (m *GraphData) GetQuests() map[string]*Quest {
	if m != nil {
		return m.Quests
	}
	return nil
}

func init() {
	proto.RegisterType((*Quest)(nil), "dm.Quest")
	proto.RegisterType((*Quest_ID)(nil), "dm.Quest.ID")
	proto.RegisterType((*Quest_Desc)(nil), "dm.Quest.Desc")
	proto.RegisterType((*Quest_Data)(nil), "dm.Quest.Data")
	proto.RegisterType((*Attempt)(nil), "dm.Attempt")
	proto.RegisterType((*Attempt_ID)(nil), "dm.Attempt.ID")
	proto.RegisterType((*Attempt_Data)(nil), "dm.Attempt.Data")
	proto.RegisterType((*Attempt_Data_NeedsExecution)(nil), "dm.Attempt.Data.NeedsExecution")
	proto.RegisterType((*Attempt_Data_Executing)(nil), "dm.Attempt.Data.Executing")
	proto.RegisterType((*Attempt_Data_AddingDeps)(nil), "dm.Attempt.Data.AddingDeps")
	proto.RegisterType((*Attempt_Data_Blocked)(nil), "dm.Attempt.Data.Blocked")
	proto.RegisterType((*Attempt_Data_Finished)(nil), "dm.Attempt.Data.Finished")
	proto.RegisterType((*Attempt_Partial)(nil), "dm.Attempt.Partial")
	proto.RegisterType((*Execution)(nil), "dm.Execution")
	proto.RegisterType((*Execution_Auth)(nil), "dm.Execution.Auth")
	proto.RegisterType((*Execution_ID)(nil), "dm.Execution.ID")
	proto.RegisterType((*Execution_Data)(nil), "dm.Execution.Data")
	proto.RegisterType((*GraphData)(nil), "dm.GraphData")
	proto.RegisterEnum("dm.Attempt_State", Attempt_State_name, Attempt_State_value)
	proto.RegisterEnum("dm.Execution_State", Execution_State_name, Execution_State_value)
}

var fileDescriptor6 = []byte{
	// 936 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x55, 0x6d, 0x8f, 0xdb, 0x44,
	0x10, 0xbe, 0xc4, 0xc9, 0x25, 0x9e, 0xbc, 0x9c, 0xeb, 0x56, 0x34, 0xdd, 0x9e, 0x7a, 0x47, 0x04,
	0x12, 0x08, 0xf0, 0xa1, 0xab, 0x90, 0xaa, 0x0a, 0x24, 0xae, 0xe4, 0xa0, 0x48, 0x55, 0xa1, 0x2d,
	0x7c, 0x36, 0x1b, 0x7b, 0x93, 0x73, 0xcf, 0x6f, 0xd8, 0x6b, 0xca, 0xfd, 0x0f, 0xc4, 0x1f, 0xe8,
	0xbf, 0xe3, 0x57, 0x30, 0xfb, 0x62, 0x7b, 0x7d, 0xa9, 0x7a, 0x52, 0xbf, 0x25, 0x3b, 0xcf, 0xec,
	0xce, 0x3c, 0xcf, 0x3c, 0x63, 0x70, 0xb6, 0x05, 0xcd, 0x2f, 0xfc, 0x90, 0x72, 0xea, 0xe5, 0x45,
	0xc6, 0x33, 0xb7, 0x1f, 0x26, 0xe4, 0x68, 0x9b, 0x65, 0xdb, 0x98, 0x9d, 0xc8, 0x93, 0x75, 0xb5,
	0x39, 0xe1, 0x51, 0xc2, 0x4a, 0x4e, 0x93, 0x5c, 0x81, 0xc8, 0x84, 0x5f, 0xe5, 0xac, 0x54, 0x7f,
	0x96, 0xff, 0xf5, 0x61, 0xf8, 0xa2, 0xc2, 0xb8, 0xbb, 0x80, 0x7e, 0x14, 0x2e, 0x7a, 0xc7, 0xbd,
	0xcf, 0x26, 0xa7, 0x53, 0x2f, 0x4c, 0x3c, 0x79, 0xec, 0xfd, 0xbc, 0x72, 0x27, 0x60, 0xad, 0x9e,
	0x9f, 0x2f, 0xfa, 0x18, 0x1a, 0xbb, 0x87, 0x30, 0x10, 0x0f, 0x2e, 0x2c, 0x09, 0x9c, 0xb7, 0xc0,
	0x15, 0x9e, 0xba, 0x9f, 0xc3, 0x98, 0x72, 0xce, 0x92, 0x9c, 0x97, 0x8b, 0xc1, 0xb1, 0x85, 0x88,
	0xbb, 0x2d, 0xe2, 0x4c, 0x47, 0xce, 0x53, 0x5e, 0x5c, 0xb9, 0x07, 0x30, 0xca, 0x69, 0xc1, 0x23,
	0x1a, 0x2f, 0x1c, 0x71, 0x33, 0x71, 0xa0, 0x8f, 0x8f, 0x41, 0x53, 0x86, 0x4d, 0xbe, 0x83, 0xc1,
	0x8a, 0x95, 0x81, 0x7b, 0x04, 0x77, 0xc3, 0xa8, 0xe4, 0x45, 0xb4, 0xae, 0x78, 0x56, 0xf8, 0x41,
	0x96, 0x6e, 0xa2, 0xad, 0x9f, 0xd2, 0x84, 0x29, 0xa0, 0x7b, 0x07, 0xa6, 0xaf, 0xcb, 0x2c, 0xf5,
	0x73, 0x7a, 0x15, 0x67, 0x34, 0x94, 0xa5, 0xda, 0xe4, 0x05, 0xa6, 0x8b, 0xa2, 0xbe, 0x80, 0x51,
	0x50, 0x30, 0xca, 0x59, 0xdd, 0x1e, 0xf1, 0x14, 0x47, 0x5e, 0xcd, 0x91, 0xf7, 0x5b, 0xcd, 0x91,
	0xec, 0x0f, 0xdf, 0x94, 0x57, 0x74, 0xfb, 0xc3, 0x53, 0xf2, 0x2d, 0xcc, 0xba, 0x5d, 0x20, 0x37,
	0x97, 0xec, 0x4a, 0xde, 0x3b, 0x73, 0x09, 0x0c, 0xff, 0xa2, 0x71, 0xc5, 0x74, 0xf2, 0x44, 0x24,
	0x6b, 0xf8, 0xe3, 0xfe, 0xa3, 0xde, 0xf2, 0xad, 0x0d, 0x23, 0xfd, 0x1f, 0xb1, 0x2d, 0xdd, 0x73,
	0x03, 0xb8, 0x43, 0xf8, 0x83, 0x0e, 0xe1, 0x8e, 0x09, 0x95, 0xdd, 0x9d, 0x00, 0xb0, 0xbf, 0x59,
	0x50, 0xf1, 0x28, 0x4b, 0x6b, 0xd2, 0xef, 0x9b, 0xa8, 0xf3, 0x26, 0xaa, 0x4a, 0xfe, 0x18, 0xc6,
	0x9b, 0x37, 0xa1, 0x1f, 0xb2, 0xbc, 0x5c, 0x0c, 0xe5, 0xa5, 0x07, 0x06, 0xfc, 0x19, 0x12, 0xed,
	0x2e, 0xc1, 0x5e, 0xd3, 0xe0, 0x52, 0x61, 0xf6, 0xdf, 0x8d, 0xf9, 0xa4, 0xab, 0xdf, 0xe4, 0xf4,
	0xb6, 0xf9, 0xe8, 0xaf, 0x2a, 0x44, 0x8e, 0xa4, 0xa8, 0x33, 0x18, 0xfe, 0x29, 0x48, 0xd4, 0x72,
	0x29, 0x8d, 0x45, 0x7b, 0x33, 0xf2, 0xcf, 0xf0, 0x43, 0x54, 0xfa, 0x12, 0xc6, 0x49, 0x16, 0x46,
	0x9b, 0x88, 0x85, 0x9a, 0xec, 0xf7, 0xa1, 0x3f, 0x82, 0x79, 0x5a, 0x25, 0xbe, 0x41, 0x93, 0x25,
	0xf5, 0x7a, 0x0c, 0x07, 0x29, 0x63, 0x61, 0xd9, 0x46, 0x90, 0x3f, 0x71, 0xd9, 0xd1, 0x75, 0x96,
	0xbd, 0xe7, 0x02, 0xd7, 0x30, 0xf9, 0x74, 0x0f, 0x69, 0xb7, 0x75, 0x56, 0xba, 0xd5, 0x34, 0x92,
	0x9d, 0xac, 0xf3, 0x1a, 0x81, 0x09, 0xa7, 0x30, 0xa1, 0x61, 0x88, 0xbf, 0x4d, 0x56, 0xef, 0xef,
	0xa4, 0x9c, 0x49, 0xcc, 0x0a, 0x21, 0x98, 0x83, 0x9c, 0xac, 0xe3, 0x2c, 0xb8, 0xc4, 0x2e, 0x47,
	0x12, 0xbf, 0xd8, 0xc1, 0x3f, 0x51, 0x71, 0x04, 0x7f, 0x85, 0xba, 0x46, 0x69, 0x54, 0x5e, 0x20,
	0x7a, 0x2c, 0xd1, 0xf7, 0x76, 0xd0, 0x3f, 0x6a, 0xc0, 0xd3, 0x3d, 0x34, 0xd7, 0xbc, 0xdb, 0x94,
	0x78, 0x2d, 0x67, 0xa9, 0x78, 0xfe, 0x66, 0x05, 0xc8, 0xa7, 0x60, 0x37, 0xdd, 0xe1, 0xee, 0x70,
	0x82, 0xaa, 0x68, 0x69, 0xf4, 0xf5, 0x68, 0xcf, 0xc8, 0x37, 0x00, 0x6d, 0x47, 0x2e, 0x2a, 0x2f,
	0x84, 0x50, 0x3c, 0x68, 0xd3, 0xdc, 0x86, 0x89, 0x38, 0x7b, 0x43, 0x23, 0x49, 0xa5, 0x9a, 0x8a,
	0x07, 0x30, 0xd2, 0x8d, 0x5d, 0x8f, 0xab, 0x6b, 0x7f, 0x81, 0x71, 0xdd, 0x8a, 0xeb, 0x09, 0x03,
	0xe4, 0x51, 0x41, 0xa5, 0x80, 0x37, 0xcf, 0x0e, 0x5e, 0x28, 0x97, 0x45, 0xc1, 0xca, 0x2a, 0xe6,
	0x6a, 0x57, 0x3c, 0x99, 0xc3, 0x54, 0x2f, 0x2e, 0x5f, 0xac, 0x47, 0xf2, 0x3d, 0x1c, 0x5c, 0xf7,
	0x4d, 0xc7, 0xea, 0x87, 0x5d, 0xab, 0xcf, 0x04, 0xd3, 0x4d, 0x82, 0x30, 0x3b, 0xf9, 0x03, 0x46,
	0xda, 0x04, 0xee, 0x54, 0x5b, 0xb8, 0x27, 0x0d, 0xed, 0x76, 0x0c, 0xab, 0x4c, 0xee, 0x18, 0x9e,
	0xb4, 0xe4, 0xc9, 0x2d, 0xd3, 0x82, 0x03, 0x79, 0x34, 0x87, 0x7d, 0x5d, 0xb3, 0x98, 0xb7, 0xf1,
	0xf2, 0x77, 0x18, 0xbe, 0xe2, 0x68, 0x18, 0xbc, 0xf1, 0x9a, 0x94, 0xce, 0x1e, 0x5a, 0xae, 0xd5,
	0xc7, 0xe9, 0x61, 0xae, 0xa1, 0x83, 0xd3, 0xc7, 0x66, 0x6a, 0x82, 0x1d, 0x0b, 0xeb, 0x6b, 0xd8,
	0x74, 0x06, 0xcb, 0xb7, 0x56, 0x93, 0x8a, 0x43, 0x71, 0x68, 0xec, 0x29, 0xa7, 0xd3, 0xa5, 0xd8,
	0x54, 0x4b, 0x18, 0x96, 0xa2, 0x04, 0xd9, 0xc6, 0x5c, 0xad, 0x80, 0x16, 0xa0, 0xaa, 0x3b, 0xee,
	0x2c, 0x30, 0xb7, 0x0b, 0x91, 0xd6, 0xdf, 0xf9, 0x14, 0x3c, 0x84, 0xc1, 0x59, 0xc5, 0x2f, 0x6e,
	0x78, 0x1c, 0xb7, 0x0a, 0xcf, 0x2e, 0x59, 0x2a, 0x1f, 0x9f, 0x92, 0xaf, 0xdf, 0xb5, 0x6a, 0xf0,
	0x6a, 0xad, 0xab, 0x9a, 0x2c, 0xbd, 0x7b, 0xa4, 0xff, 0x49, 0xfc, 0x21, 0xab, 0xe7, 0x1e, 0xdc,
	0x32, 0x3f, 0x46, 0x6d, 0x05, 0x36, 0x96, 0x7b, 0xc7, 0x0c, 0x45, 0xe9, 0x26, 0xf3, 0xab, 0x22,
	0x96, 0xaf, 0xd9, 0xcb, 0x67, 0xb5, 0x5c, 0x28, 0xcd, 0xab, 0x00, 0xb9, 0xae, 0x62, 0xe4, 0x7b,
	0x4f, 0x48, 0xf1, 0xb2, 0x4a, 0x53, 0xa5, 0x13, 0x4a, 0xf1, 0x92, 0xbd, 0x66, 0x01, 0xd6, 0x82,
	0x2a, 0x99, 0xc2, 0x58, 0x02, 0xf8, 0x43, 0x41, 0xb5, 0x4a, 0xff, 0xf6, 0xc0, 0xfe, 0x49, 0x7c,
	0xff, 0xf5, 0x77, 0x77, 0x5f, 0x76, 0x5d, 0x62, 0x03, 0x56, 0xed, 0xfc, 0x26, 0xac, 0xbe, 0x60,
	0x7a, 0x8c, 0x91, 0x81, 0x0b, 0x1a, 0xfa, 0xac, 0x28, 0xb2, 0xc2, 0x18, 0x3f, 0x71, 0x96, 0x64,
	0x05, 0x53, 0xe3, 0x47, 0x1e, 0xc1, 0xc4, 0x4c, 0x32, 0x66, 0xdf, 0x46, 0xb7, 0x77, 0x66, 0xdf,
	0x6e, 0xbe, 0x91, 0x62, 0xee, 0xd7, 0xfb, 0x92, 0xb3, 0x87, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff,
	0x81, 0xb7, 0xc3, 0xe5, 0x9e, 0x08, 0x00, 0x00,
}
