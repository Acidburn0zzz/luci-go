// Code generated by protoc-gen-go.
// source: graph_query.proto
// DO NOT EDIT!

package dm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type GraphQuery_Search_Domain int32

const (
	GraphQuery_Search_Quest   GraphQuery_Search_Domain = 0
	GraphQuery_Search_Attempt GraphQuery_Search_Domain = 1
)

var GraphQuery_Search_Domain_name = map[int32]string{
	0: "Quest",
	1: "Attempt",
}
var GraphQuery_Search_Domain_value = map[string]int32{
	"Quest":   0,
	"Attempt": 1,
}

func (x GraphQuery_Search_Domain) String() string {
	return proto.EnumName(GraphQuery_Search_Domain_name, int32(x))
}
func (GraphQuery_Search_Domain) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor7, []int{0, 1, 0}
}

// GraphQuery represents a single query into the state of DM's dependency graph.
// It's a required parameter for WalkGraphReq.
type GraphQuery struct {
	// AttemptList allows you to list one or more specific attempts as the result
	// of the query. If a quest contains the attempt number 0, or is empty, it
	// means 'all attempts for this quest'.
	AttemptList *AttemptList `protobuf:"bytes,1,opt,name=attempt_list" json:"attempt_list,omitempty"`
	// attempt_range allows you to list a range of attempts in a single quest.
	// low must be > 0, and high must be > low. The range is [low, high). High may
	// be higher than the highest attempt, and low may be lower than the lowest
	// attempt (but not 0).
	AttemptRange []*GraphQuery_AttemptRange `protobuf:"bytes,2,rep,name=attempt_range" json:"attempt_range,omitempty"`
	Search       []*GraphQuery_Search       `protobuf:"bytes,3,rep,name=search" json:"search,omitempty"`
}

func (m *GraphQuery) Reset()                    { *m = GraphQuery{} }
func (m *GraphQuery) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery) ProtoMessage()               {}
func (*GraphQuery) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{0} }

func (m *GraphQuery) GetAttemptList() *AttemptList {
	if m != nil {
		return m.AttemptList
	}
	return nil
}

func (m *GraphQuery) GetAttemptRange() []*GraphQuery_AttemptRange {
	if m != nil {
		return m.AttemptRange
	}
	return nil
}

func (m *GraphQuery) GetSearch() []*GraphQuery_Search {
	if m != nil {
		return m.Search
	}
	return nil
}

type GraphQuery_AttemptRange struct {
	Quest string `protobuf:"bytes,1,opt,name=quest" json:"quest,omitempty"`
	Low   uint32 `protobuf:"varint,2,opt,name=low" json:"low,omitempty"`
	High  uint32 `protobuf:"varint,3,opt,name=high" json:"high,omitempty"`
}

func (m *GraphQuery_AttemptRange) Reset()                    { *m = GraphQuery_AttemptRange{} }
func (m *GraphQuery_AttemptRange) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery_AttemptRange) ProtoMessage()               {}
func (*GraphQuery_AttemptRange) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{0, 0} }

// A Search allows you to query objects whose properties match all of the
// provided filters. Filters take the form of a dot-delimited path. For
// example, say that we had the following objects:
//
//   Quest(id=deadbeef):
//     created = <timestamp>  #sort
//     descriptor.distributor_config_name = "foo"
//     descriptor.json_payload = {
//       "key": "value",
//       "multi": ["some", 10, "values", true],
//       "sub": [{"msg": 11}, {"msg": 12}],
//     }
//
//   Attempt(id=deadbeef|1):
//     created = <timestamp>  #sort
//     attempt_type = Finished
//     finished.expiration = <timestamp>
//     finished.json_result = {
//       "rslt": "yes",
//       "ok": true,
//     }
//
// Then you could query (in pseudo-proto):
//   domain: Attempt
//   approx_filters: {
//     "attempt_type": ["Finished"],
//     "$quest.descriptor.json_payload.multi": [true, 10],
//     "$quest.descriptor.json_payload.sub.msg": [11, 10],
//     "finished.json_result.ok": [true],
//   }
//
// Or:
//
//   domain: Attempt
//   exact_filters: {
//     "$quest.descriptor.json_payload.multi[1]": [10],
//     "$quest.descriptor.json_payload.sub[0].msg": [11],
//   }
//
// Literal '.' and '[' characters may be escaped with a backslash.
type GraphQuery_Search struct {
	// Domain indicates which class of objects your query applies to. The fields
	// available to query are defined by the `data` field in the corresponding
	// GraphData message.
	//
	// Additionally `Attempt` has a special field $quest whose subfields are
	// queriable in the exact same way that a search in a Quest domain works.
	Domain GraphQuery_Search_Domain `protobuf:"varint,1,opt,name=domain,enum=dm.GraphQuery_Search_Domain" json:"domain,omitempty"`
	// Start and End are optional restrictions on the first sort property. For
	// now, these are just restrictions on the 'created' timestamp for either
	// the Quest or Attempt, depending on the SearchDomain.
	Start *PropertyValue `protobuf:"bytes,3,opt,name=start" json:"start,omitempty"`
	End   *PropertyValue `protobuf:"bytes,4,opt,name=end" json:"end,omitempty"`
	// ApproxFilters allows you to filter on 'approximate' fields. Approximate
	// fields are the json path to the value, without any array subscripts. For
	// example, if your document looked like:
	//
	//   {
	//     "some": ["list", {"of": ["data", "and", "stuff"]}],
	//   }
	//
	// Then the following approximate filters would match:
	//   "some" = ["list"]
	//   "some.of" = ["data"]
	//   "some.of" = ["and"]
	//   "some.of" = ["stuff"]
	//   "some.of" = ["stuff", "and"]
	//   "some.of" = ["stuff", "and", "data"]
	//
	// This is useful for filtering documents where the order of parameters
	// in a list or sublist isn't known, or doesn't matter.
	ApproxFilters map[string]*MultiPropertyValue `protobuf:"bytes,5,rep,name=approx_filters" json:"approx_filters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// ExactFilters allows you to filter on 'exact' fields. Exact fields are the
	// json path to the value, including array subscripts. For example if your
	// document looked like:
	//
	//   {
	//     "some": ["list", {"of": ["data", "and", "stuff"]}],
	//   }
	//
	// Then the following exact filters would match:
	//   "some[0]" = "list"
	//   "some[1].of[0]" = "data"
	//   "some[1].of[1]" = "and"
	//   "some[1].of[2]" = "stuff"
	//
	// This is useful for filtering documents where the order of parameters
	// in a list or sublist matters.
	ExactFilters map[string]*PropertyValue `protobuf:"bytes,6,rep,name=exact_filters" json:"exact_filters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *GraphQuery_Search) Reset()                    { *m = GraphQuery_Search{} }
func (m *GraphQuery_Search) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery_Search) ProtoMessage()               {}
func (*GraphQuery_Search) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{0, 1} }

func (m *GraphQuery_Search) GetStart() *PropertyValue {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *GraphQuery_Search) GetEnd() *PropertyValue {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *GraphQuery_Search) GetApproxFilters() map[string]*MultiPropertyValue {
	if m != nil {
		return m.ApproxFilters
	}
	return nil
}

func (m *GraphQuery_Search) GetExactFilters() map[string]*PropertyValue {
	if m != nil {
		return m.ExactFilters
	}
	return nil
}

func init() {
	proto.RegisterType((*GraphQuery)(nil), "dm.GraphQuery")
	proto.RegisterType((*GraphQuery_AttemptRange)(nil), "dm.GraphQuery.AttemptRange")
	proto.RegisterType((*GraphQuery_Search)(nil), "dm.GraphQuery.Search")
	proto.RegisterEnum("dm.GraphQuery_Search_Domain", GraphQuery_Search_Domain_name, GraphQuery_Search_Domain_value)
}

var fileDescriptor7 = []byte{
	// 391 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x74, 0x92, 0xdf, 0x8e, 0xd2, 0x40,
	0x14, 0x87, 0x6d, 0x4b, 0x8b, 0x9c, 0x52, 0x84, 0x49, 0x34, 0x4d, 0x35, 0xa6, 0x21, 0x21, 0x72,
	0x61, 0x7a, 0x51, 0x6f, 0x88, 0x17, 0x46, 0x12, 0xc1, 0xc4, 0x60, 0x22, 0x98, 0x78, 0xdb, 0x0c,
	0x74, 0x84, 0xc6, 0xfe, 0x73, 0x3a, 0xec, 0xd2, 0x77, 0xd8, 0x97, 0xda, 0x37, 0xdb, 0x99, 0x69,
	0xd9, 0xdd, 0x2e, 0xdd, 0xcb, 0x9e, 0xf9, 0xce, 0x77, 0xe6, 0xfc, 0xa6, 0x30, 0xda, 0x53, 0x9c,
	0x1f, 0x82, 0xff, 0x47, 0x42, 0x4b, 0x2f, 0xa7, 0x19, 0xcb, 0x90, 0x1a, 0x26, 0x8e, 0xc9, 0xca,
	0x9c, 0x14, 0x55, 0x61, 0x7c, 0xa3, 0x03, 0x7c, 0x17, 0xd8, 0x5a, 0x50, 0x68, 0x02, 0x7d, 0xcc,
	0x18, 0x49, 0x72, 0x16, 0xc4, 0x51, 0xc1, 0x6c, 0xc5, 0x55, 0xa6, 0xa6, 0xff, 0xca, 0x0b, 0x13,
	0x6f, 0x5e, 0xd5, 0x57, 0xbc, 0x8c, 0x7c, 0xb0, 0xce, 0x18, 0xc5, 0xe9, 0x9e, 0xd8, 0xaa, 0xab,
	0x71, 0xee, 0xad, 0xe0, 0x1e, 0x6c, 0xe7, 0x96, 0x8d, 0x40, 0xb8, 0xda, 0x28, 0x08, 0xa6, 0xbb,
	0x83, 0xad, 0x49, 0xf8, 0xf5, 0x13, 0xf8, 0xb7, 0x3c, 0x74, 0x66, 0xd0, 0x6f, 0xb4, 0x59, 0xa0,
	0xf3, 0x05, 0xea, 0xab, 0xf4, 0x90, 0x09, 0x5a, 0x9c, 0x5d, 0xf3, 0x79, 0xca, 0xd4, 0x42, 0x7d,
	0xe8, 0x1c, 0xa2, 0xbd, 0x10, 0xf2, 0x2f, 0xe7, 0x56, 0x03, 0xa3, 0x92, 0xa0, 0x8f, 0x60, 0x84,
	0x59, 0x82, 0xa3, 0x54, 0x76, 0x0d, 0xfc, 0x77, 0xad, 0xb3, 0xbc, 0x6f, 0x92, 0x41, 0x2e, 0xe8,
	0x05, 0xc3, 0x94, 0x49, 0x8f, 0xe9, 0x8f, 0x04, 0xfc, 0x8b, 0x66, 0x39, 0xa1, 0xac, 0xfc, 0x83,
	0xe3, 0x23, 0x41, 0xef, 0x41, 0x23, 0x69, 0x68, 0x77, 0x9e, 0x3b, 0xff, 0x0a, 0x03, 0x9c, 0xf3,
	0x40, 0x4f, 0xc1, 0xdf, 0x28, 0x66, 0x84, 0x16, 0xb6, 0x2e, 0x77, 0x9c, 0xb6, 0xcf, 0x9d, 0x4b,
	0x76, 0x59, 0xa1, 0x8b, 0x94, 0xf1, 0xe0, 0xbf, 0x80, 0x45, 0x4e, 0x78, 0xc7, 0xee, 0x05, 0x86,
	0x14, 0x7c, 0x68, 0x17, 0x2c, 0x04, 0xfa, 0xb8, 0xdf, 0x59, 0x01, 0x6a, 0xb1, 0xf2, 0xb4, 0xfe,
	0x91, 0xb2, 0x8e, 0x6e, 0x02, 0xfa, 0x95, 0xb8, 0xad, 0x0c, 0xcf, 0xf4, 0xdf, 0x08, 0xf5, 0xcf,
	0x63, 0xcc, 0xa2, 0xc6, 0x2e, 0x9f, 0xd5, 0x99, 0xe2, 0x2c, 0x61, 0x74, 0x31, 0xa2, 0x29, 0x73,
	0x9b, 0xb2, 0xcb, 0x4c, 0x84, 0x67, 0xec, 0x82, 0x51, 0x67, 0xdc, 0x03, 0x7d, 0x2d, 0x9e, 0x71,
	0xf8, 0x82, 0x7b, 0xba, 0xf5, 0x0b, 0x0f, 0x95, 0x1f, 0x9d, 0x97, 0xea, 0x50, 0xdb, 0x74, 0x8b,
	0x8c, 0xb2, 0x60, 0x5b, 0x6e, 0x0d, 0xf9, 0x57, 0x7e, 0xba, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x55,
	0x0b, 0x5a, 0x72, 0xbb, 0x02, 0x00, 0x00,
}
