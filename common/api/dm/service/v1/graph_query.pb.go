// Code generated by protoc-gen-go.
// source: graph_query.proto
// DO NOT EDIT!

package dm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type GraphQuery_Search_SearchDomain int32

const (
	GraphQuery_Search_Quest   GraphQuery_Search_SearchDomain = 0
	GraphQuery_Search_Attempt GraphQuery_Search_SearchDomain = 1
)

var GraphQuery_Search_SearchDomain_name = map[int32]string{
	0: "Quest",
	1: "Attempt",
}
var GraphQuery_Search_SearchDomain_value = map[string]int32{
	"Quest":   0,
	"Attempt": 1,
}

func (x GraphQuery_Search_SearchDomain) String() string {
	return proto.EnumName(GraphQuery_Search_SearchDomain_name, int32(x))
}
func (GraphQuery_Search_SearchDomain) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor7, []int{0, 2, 0}
}

// GraphQuery represents a single query into the state of DM's dependency graph.
// It's a required parameter for WalkGraphReq.
type GraphQuery struct {
	// Types that are valid to be assigned to Query:
	//	*GraphQuery_AttemptList_
	//	*GraphQuery_AttemptRange_
	//	*GraphQuery_Search_
	Query isGraphQuery_Query `protobuf_oneof:"query"`
}

func (m *GraphQuery) Reset()                    { *m = GraphQuery{} }
func (m *GraphQuery) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery) ProtoMessage()               {}
func (*GraphQuery) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{0} }

type isGraphQuery_Query interface {
	isGraphQuery_Query()
}

type GraphQuery_AttemptList_ struct {
	AttemptList *GraphQuery_AttemptList `protobuf:"bytes,1,opt,name=attempt_list,oneof"`
}
type GraphQuery_AttemptRange_ struct {
	AttemptRange *GraphQuery_AttemptRange `protobuf:"bytes,2,opt,name=attempt_range,oneof"`
}
type GraphQuery_Search_ struct {
	Search *GraphQuery_Search `protobuf:"bytes,3,opt,name=search,oneof"`
}

func (*GraphQuery_AttemptList_) isGraphQuery_Query()  {}
func (*GraphQuery_AttemptRange_) isGraphQuery_Query() {}
func (*GraphQuery_Search_) isGraphQuery_Query()       {}

func (m *GraphQuery) GetQuery() isGraphQuery_Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *GraphQuery) GetAttemptList() *GraphQuery_AttemptList {
	if x, ok := m.GetQuery().(*GraphQuery_AttemptList_); ok {
		return x.AttemptList
	}
	return nil
}

func (m *GraphQuery) GetAttemptRange() *GraphQuery_AttemptRange {
	if x, ok := m.GetQuery().(*GraphQuery_AttemptRange_); ok {
		return x.AttemptRange
	}
	return nil
}

func (m *GraphQuery) GetSearch() *GraphQuery_Search {
	if x, ok := m.GetQuery().(*GraphQuery_Search_); ok {
		return x.Search
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GraphQuery) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _GraphQuery_OneofMarshaler, _GraphQuery_OneofUnmarshaler, []interface{}{
		(*GraphQuery_AttemptList_)(nil),
		(*GraphQuery_AttemptRange_)(nil),
		(*GraphQuery_Search_)(nil),
	}
}

func _GraphQuery_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GraphQuery)
	// query
	switch x := m.Query.(type) {
	case *GraphQuery_AttemptList_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AttemptList); err != nil {
			return err
		}
	case *GraphQuery_AttemptRange_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AttemptRange); err != nil {
			return err
		}
	case *GraphQuery_Search_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Search); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GraphQuery.Query has unexpected type %T", x)
	}
	return nil
}

func _GraphQuery_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GraphQuery)
	switch tag {
	case 1: // query.attempt_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GraphQuery_AttemptList)
		err := b.DecodeMessage(msg)
		m.Query = &GraphQuery_AttemptList_{msg}
		return true, err
	case 2: // query.attempt_range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GraphQuery_AttemptRange)
		err := b.DecodeMessage(msg)
		m.Query = &GraphQuery_AttemptRange_{msg}
		return true, err
	case 3: // query.search
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GraphQuery_Search)
		err := b.DecodeMessage(msg)
		m.Query = &GraphQuery_Search_{msg}
		return true, err
	default:
		return false, nil
	}
}

// AttemptList allows you to list one or more specific attempts as the result
// of the query. If a quest contains the attempt number 0, or is empty, it
// means 'all attempts for this quest'.
type GraphQuery_AttemptList struct {
	Attempt *AttemptList `protobuf:"bytes,1,opt,name=attempt" json:"attempt,omitempty"`
}

func (m *GraphQuery_AttemptList) Reset()                    { *m = GraphQuery_AttemptList{} }
func (m *GraphQuery_AttemptList) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery_AttemptList) ProtoMessage()               {}
func (*GraphQuery_AttemptList) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{0, 0} }

func (m *GraphQuery_AttemptList) GetAttempt() *AttemptList {
	if m != nil {
		return m.Attempt
	}
	return nil
}

// AttemptRange allows you to list a range of attempts in a single quest.
// low must be > 0, and high must be > low. The range is [low, high). High
// may be higher than the highest attempt, and low may be lower than the
// lowest attempt.
type GraphQuery_AttemptRange struct {
	Quest string `protobuf:"bytes,1,opt,name=quest" json:"quest,omitempty"`
	Low   uint32 `protobuf:"varint,2,opt,name=low" json:"low,omitempty"`
	High  uint32 `protobuf:"varint,3,opt,name=high" json:"high,omitempty"`
}

func (m *GraphQuery_AttemptRange) Reset()                    { *m = GraphQuery_AttemptRange{} }
func (m *GraphQuery_AttemptRange) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery_AttemptRange) ProtoMessage()               {}
func (*GraphQuery_AttemptRange) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{0, 1} }

// A Search allows you to query objects whose properties match all of the
// provided filters. Filters take the form of a dot-delimited path. For
// example, say that we had the following objects:
//
//   Quest(id=deadbeef):
//     created = <timestamp>  #sort
//     descriptor.distributor_config_name = "foo"
//     descriptor.json_payload = {
//       "key": "value",
//       "multi": ["some", 10, "values", true],
//       "sub": [{"msg": 11}, {"msg": 12}],
//     }
//
//   Attempt(id=deadbeef|1):
//     created = <timestamp>  #sort
//     attempt_type = Finished
//     finished.expiration = <timestamp>
//     finished.json_result = {
//       "rslt": "yes",
//       "ok": true,
//     }
//
// Then you could query (in pseudo-proto):
//   domain: Attempt
//   approx_filters: {
//     "attempt_type": ["Finished"],
//     "$quest.descriptor.json_payload.multi": [true, 10],
//     "$quest.descriptor.json_payload.sub.msg": [11, 10],
//     "finished.json_result.ok": [true],
//   }
//
// Or:
//
//   domain: Attempt
//   exact_filters: {
//     "$quest.descriptor.json_payload.multi[1]": [10],
//     "$quest.descriptor.json_payload.sub[0].msg": [11],
//   }
//
// Literal '.' and '[' characters may be escaped with a backslash.
type GraphQuery_Search struct {
	// Domain indicates which class of objects your query applies to. The fields
	// available to query are defined by the `data` field in the corresponding
	// GraphData message.
	//
	// Additionally `Attempt` has a special field $quest whose subfields are
	// queriable in the exact same way that a search in a Quest domain works.
	Domain GraphQuery_Search_SearchDomain `protobuf:"varint,1,opt,name=domain,enum=dm.GraphQuery_Search_SearchDomain" json:"domain,omitempty"`
	// Start and End are optional restrictions on the first sort property. For
	// now, these are just restrictions on the 'created' timestamp for either
	// the Quest or Attempt, depending on the SearchDomain.
	Start *PropertyValue `protobuf:"bytes,3,opt,name=start" json:"start,omitempty"`
	End   *PropertyValue `protobuf:"bytes,4,opt,name=end" json:"end,omitempty"`
	// ApproxFilters allows you to filter on 'approximate' fields. Approximate
	// fields are the json path to the value, without any array subscripts. For
	// example, if your document looked like:
	//
	//   {
	//     "some": ["list", {"of": ["data", "and", "stuff"]}],
	//   }
	//
	// Then the following approximate filters would match:
	//   "some" = ["list"]
	//   "some.of" = ["data"]
	//   "some.of" = ["and"]
	//   "some.of" = ["stuff"]
	//   "some.of" = ["stuff", "and"]
	//   "some.of" = ["stuff", "and", "data"]
	//
	// This is useful for filtering documents where the order of parameters
	// in a list or sublist isn't known, or doesn't matter.
	ApproxFilters map[string]*MultiPropertyValue `protobuf:"bytes,5,rep,name=approx_filters" json:"approx_filters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// ExactFilters allows you to filter on 'exact' fields. Exact fields are the
	// json path to the value, including array subscripts. For example if your
	// document looked like:
	//
	//   {
	//     "some": ["list", {"of": ["data", "and", "stuff"]}],
	//   }
	//
	// Then the following exact filters would match:
	//   "some[0]" = "list"
	//   "some[1].of[0]" = "data"
	//   "some[1].of[1]" = "and"
	//   "some[1].of[2]" = "stuff"
	//
	// This is useful for filtering documents where the order of parameters
	// in a list or sublist matters.
	ExactFilters map[string]*PropertyValue `protobuf:"bytes,6,rep,name=exact_filters" json:"exact_filters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *GraphQuery_Search) Reset()                    { *m = GraphQuery_Search{} }
func (m *GraphQuery_Search) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery_Search) ProtoMessage()               {}
func (*GraphQuery_Search) Descriptor() ([]byte, []int) { return fileDescriptor7, []int{0, 2} }

func (m *GraphQuery_Search) GetStart() *PropertyValue {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *GraphQuery_Search) GetEnd() *PropertyValue {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *GraphQuery_Search) GetApproxFilters() map[string]*MultiPropertyValue {
	if m != nil {
		return m.ApproxFilters
	}
	return nil
}

func (m *GraphQuery_Search) GetExactFilters() map[string]*PropertyValue {
	if m != nil {
		return m.ExactFilters
	}
	return nil
}

func init() {
	proto.RegisterType((*GraphQuery)(nil), "dm.GraphQuery")
	proto.RegisterType((*GraphQuery_AttemptList)(nil), "dm.GraphQuery.AttemptList")
	proto.RegisterType((*GraphQuery_AttemptRange)(nil), "dm.GraphQuery.AttemptRange")
	proto.RegisterType((*GraphQuery_Search)(nil), "dm.GraphQuery.Search")
	proto.RegisterEnum("dm.GraphQuery_Search_SearchDomain", GraphQuery_Search_SearchDomain_name, GraphQuery_Search_SearchDomain_value)
}

var fileDescriptor7 = []byte{
	// 415 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x74, 0x92, 0x5f, 0x8b, 0xd3, 0x40,
	0x14, 0xc5, 0x9b, 0xa4, 0x49, 0xdc, 0x9b, 0x64, 0x6d, 0x07, 0x94, 0x10, 0x41, 0x42, 0x41, 0x77,
	0x9f, 0x22, 0x54, 0x1f, 0x16, 0x1f, 0xc4, 0x15, 0x77, 0x2d, 0x52, 0xc1, 0x56, 0xf0, 0x35, 0x4c,
	0x9b, 0xb1, 0x0d, 0xe6, 0x9f, 0x93, 0xa9, 0x36, 0x1f, 0xd2, 0x4f, 0xe1, 0x17, 0x71, 0x66, 0x32,
	0x6a, 0x62, 0xb3, 0x4f, 0x85, 0xce, 0xef, 0x9c, 0x7b, 0xef, 0x39, 0x81, 0xe9, 0x8e, 0xe2, 0x6a,
	0x1f, 0x7f, 0x3b, 0x10, 0xda, 0x44, 0x15, 0x2d, 0x59, 0x89, 0xf4, 0x24, 0x0f, 0x1c, 0xd6, 0x54,
	0xa4, 0x6e, 0xff, 0x98, 0xfd, 0x32, 0x01, 0xde, 0x09, 0x6c, 0x25, 0x28, 0x34, 0x07, 0x17, 0x33,
	0x46, 0xf2, 0x8a, 0xc5, 0x59, 0x5a, 0x33, 0x5f, 0x0b, 0xb5, 0x4b, 0x67, 0x1e, 0x44, 0x49, 0x1e,
	0xfd, 0xa3, 0xa2, 0xeb, 0x16, 0x59, 0x72, 0x62, 0x31, 0x42, 0x2f, 0xc0, 0xfb, 0xa3, 0xa1, 0xb8,
	0xd8, 0x11, 0x5f, 0x97, 0xa2, 0x47, 0xc3, 0xa2, 0xb5, 0x40, 0xb8, 0xea, 0x02, 0xac, 0x9a, 0x60,
	0xba, 0xdd, 0xfb, 0x86, 0xc4, 0x1f, 0xfc, 0x87, 0x7f, 0x92, 0x8f, 0x8b, 0x51, 0xf0, 0x0c, 0x9c,
	0xce, 0x3c, 0x14, 0x82, 0xad, 0xa6, 0xa9, 0xe5, 0xee, 0x0b, 0x61, 0x87, 0x08, 0xae, 0xc0, 0xed,
	0xce, 0x42, 0x1e, 0x98, 0x3c, 0x02, 0x75, 0xcc, 0x19, 0x72, 0xc0, 0xc8, 0xca, 0x1f, 0x72, 0x49,
	0x0f, 0xb9, 0x30, 0xde, 0xa7, 0xbb, 0x76, 0x07, 0x2f, 0xf8, 0x69, 0x80, 0xd5, 0xce, 0xe5, 0x41,
	0x58, 0x49, 0x99, 0xe3, 0xb4, 0x90, 0xaa, 0xf3, 0xf9, 0x6c, 0x70, 0x3d, 0xf5, 0xf3, 0x56, 0x92,
	0x7c, 0x35, 0xb3, 0x66, 0x98, 0x32, 0x75, 0xd1, 0x54, 0x48, 0x3e, 0xd2, 0xb2, 0x22, 0x94, 0x35,
	0x9f, 0x71, 0x76, 0x20, 0xe8, 0x31, 0x18, 0xa4, 0x48, 0xfc, 0xf1, 0x5d, 0xef, 0xaf, 0xe1, 0x1c,
	0x57, 0xbc, 0x98, 0x63, 0xfc, 0x25, 0xcd, 0x18, 0xa1, 0xb5, 0x6f, 0x86, 0x06, 0x47, 0x2f, 0x87,
	0xa7, 0x5f, 0x4b, 0xf6, 0xb6, 0x45, 0x6f, 0x0a, 0xc6, 0x0b, 0x7c, 0x05, 0x1e, 0x39, 0xe2, 0x2d,
	0xfb, 0x6b, 0x60, 0x49, 0x83, 0x8b, 0x61, 0x83, 0x1b, 0x81, 0x76, 0xf5, 0xc1, 0x12, 0xd0, 0x80,
	0x2b, 0xcf, 0xec, 0x2b, 0x69, 0x54, 0x80, 0x4f, 0xc0, 0xfc, 0x2e, 0xb6, 0x55, 0x3d, 0x3f, 0x14,
	0xd6, 0x1f, 0x0e, 0x19, 0x4b, 0x7b, 0xb7, 0xbc, 0xd4, 0xaf, 0xb4, 0xe0, 0x16, 0xa6, 0x27, 0x23,
	0xfa, 0x66, 0x61, 0xdf, 0xec, 0x34, 0x13, 0xe1, 0x33, 0x7b, 0x0a, 0x6e, 0x2f, 0xe9, 0x33, 0x30,
	0x57, 0xa2, 0xd2, 0xc9, 0x88, 0xbb, 0xd9, 0xaa, 0xed, 0x89, 0xf6, 0x7e, 0x7c, 0x4f, 0x9f, 0x18,
	0x6b, 0xbb, 0x2e, 0x29, 0x8b, 0x37, 0xcd, 0x1b, 0x5b, 0x36, 0x4f, 0x9b, 0x8d, 0x25, 0x3f, 0xf6,
	0xe7, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x57, 0x24, 0x15, 0xb2, 0x12, 0x03, 0x00, 0x00,
}
