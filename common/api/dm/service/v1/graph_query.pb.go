// Code generated by protoc-gen-go.
// source: graph_query.proto
// DO NOT EDIT!

package dm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type GraphQuery_Search_SearchDomain int32

const (
	GraphQuery_Search_Quest   GraphQuery_Search_SearchDomain = 0
	GraphQuery_Search_Attempt GraphQuery_Search_SearchDomain = 1
)

var GraphQuery_Search_SearchDomain_name = map[int32]string{
	0: "Quest",
	1: "Attempt",
}
var GraphQuery_Search_SearchDomain_value = map[string]int32{
	"Quest":   0,
	"Attempt": 1,
}

func (x GraphQuery_Search_SearchDomain) String() string {
	return proto.EnumName(GraphQuery_Search_SearchDomain_name, int32(x))
}
func (GraphQuery_Search_SearchDomain) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor6, []int{0, 4, 0}
}

type GraphQuery struct {
	// Types that are valid to be assigned to Query:
	//	*GraphQuery_AttemptRange_
	//	*GraphQuery_AttemptList_
	//	*GraphQuery_QuestRange_
	//	*GraphQuery_QuestList_
	//	*GraphQuery_Search_
	Query isGraphQuery_Query `protobuf_oneof:"query"`
}

func (m *GraphQuery) Reset()                    { *m = GraphQuery{} }
func (m *GraphQuery) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery) ProtoMessage()               {}
func (*GraphQuery) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0} }

type isGraphQuery_Query interface {
	isGraphQuery_Query()
}

type GraphQuery_AttemptRange_ struct {
	AttemptRange *GraphQuery_AttemptRange `protobuf:"bytes,1,opt,name=attempt_range,oneof"`
}
type GraphQuery_AttemptList_ struct {
	AttemptList *GraphQuery_AttemptList `protobuf:"bytes,2,opt,name=attempt_list,oneof"`
}
type GraphQuery_QuestRange_ struct {
	QuestRange *GraphQuery_QuestRange `protobuf:"bytes,3,opt,name=quest_range,oneof"`
}
type GraphQuery_QuestList_ struct {
	QuestList *GraphQuery_QuestList `protobuf:"bytes,4,opt,name=quest_list,oneof"`
}
type GraphQuery_Search_ struct {
	Search *GraphQuery_Search `protobuf:"bytes,5,opt,name=search,oneof"`
}

func (*GraphQuery_AttemptRange_) isGraphQuery_Query() {}
func (*GraphQuery_AttemptList_) isGraphQuery_Query()  {}
func (*GraphQuery_QuestRange_) isGraphQuery_Query()   {}
func (*GraphQuery_QuestList_) isGraphQuery_Query()    {}
func (*GraphQuery_Search_) isGraphQuery_Query()       {}

func (m *GraphQuery) GetQuery() isGraphQuery_Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *GraphQuery) GetAttemptRange() *GraphQuery_AttemptRange {
	if x, ok := m.GetQuery().(*GraphQuery_AttemptRange_); ok {
		return x.AttemptRange
	}
	return nil
}

func (m *GraphQuery) GetAttemptList() *GraphQuery_AttemptList {
	if x, ok := m.GetQuery().(*GraphQuery_AttemptList_); ok {
		return x.AttemptList
	}
	return nil
}

func (m *GraphQuery) GetQuestRange() *GraphQuery_QuestRange {
	if x, ok := m.GetQuery().(*GraphQuery_QuestRange_); ok {
		return x.QuestRange
	}
	return nil
}

func (m *GraphQuery) GetQuestList() *GraphQuery_QuestList {
	if x, ok := m.GetQuery().(*GraphQuery_QuestList_); ok {
		return x.QuestList
	}
	return nil
}

func (m *GraphQuery) GetSearch() *GraphQuery_Search {
	if x, ok := m.GetQuery().(*GraphQuery_Search_); ok {
		return x.Search
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GraphQuery) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _GraphQuery_OneofMarshaler, _GraphQuery_OneofUnmarshaler, []interface{}{
		(*GraphQuery_AttemptRange_)(nil),
		(*GraphQuery_AttemptList_)(nil),
		(*GraphQuery_QuestRange_)(nil),
		(*GraphQuery_QuestList_)(nil),
		(*GraphQuery_Search_)(nil),
	}
}

func _GraphQuery_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GraphQuery)
	// query
	switch x := m.Query.(type) {
	case *GraphQuery_AttemptRange_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AttemptRange); err != nil {
			return err
		}
	case *GraphQuery_AttemptList_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AttemptList); err != nil {
			return err
		}
	case *GraphQuery_QuestRange_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.QuestRange); err != nil {
			return err
		}
	case *GraphQuery_QuestList_:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.QuestList); err != nil {
			return err
		}
	case *GraphQuery_Search_:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Search); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GraphQuery.Query has unexpected type %T", x)
	}
	return nil
}

func _GraphQuery_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GraphQuery)
	switch tag {
	case 1: // query.attempt_range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GraphQuery_AttemptRange)
		err := b.DecodeMessage(msg)
		m.Query = &GraphQuery_AttemptRange_{msg}
		return true, err
	case 2: // query.attempt_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GraphQuery_AttemptList)
		err := b.DecodeMessage(msg)
		m.Query = &GraphQuery_AttemptList_{msg}
		return true, err
	case 3: // query.quest_range
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GraphQuery_QuestRange)
		err := b.DecodeMessage(msg)
		m.Query = &GraphQuery_QuestRange_{msg}
		return true, err
	case 4: // query.quest_list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GraphQuery_QuestList)
		err := b.DecodeMessage(msg)
		m.Query = &GraphQuery_QuestList_{msg}
		return true, err
	case 5: // query.search
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GraphQuery_Search)
		err := b.DecodeMessage(msg)
		m.Query = &GraphQuery_Search_{msg}
		return true, err
	default:
		return false, nil
	}
}

// AttemptRange represents a (quest, attempt) -> (quest, attempt) pair. All
// attempts within the range will be returned as the result of the query.
type GraphQuery_AttemptRange struct {
	Start *AttemptID `protobuf:"bytes,1,opt,name=start" json:"start,omitempty"`
	End   *AttemptID `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *GraphQuery_AttemptRange) Reset()                    { *m = GraphQuery_AttemptRange{} }
func (m *GraphQuery_AttemptRange) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery_AttemptRange) ProtoMessage()               {}
func (*GraphQuery_AttemptRange) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0, 0} }

func (m *GraphQuery_AttemptRange) GetStart() *AttemptID {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *GraphQuery_AttemptRange) GetEnd() *AttemptID {
	if m != nil {
		return m.End
	}
	return nil
}

// AttemptList allows you to list one or more specific attempts as the result
// of the query.
type GraphQuery_AttemptList struct {
	Attempt []*AttemptID `protobuf:"bytes,1,rep,name=attempt" json:"attempt,omitempty"`
}

func (m *GraphQuery_AttemptList) Reset()                    { *m = GraphQuery_AttemptList{} }
func (m *GraphQuery_AttemptList) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery_AttemptList) ProtoMessage()               {}
func (*GraphQuery_AttemptList) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0, 1} }

func (m *GraphQuery_AttemptList) GetAttempt() []*AttemptID {
	if m != nil {
		return m.Attempt
	}
	return nil
}

// QuestRange represents a quest->quest pair. All Attempts of all Quests
// within the range will be returned as the result of the query.
type GraphQuery_QuestRange struct {
	Start *QuestID `protobuf:"bytes,1,opt,name=start" json:"start,omitempty"`
	End   *QuestID `protobuf:"bytes,2,opt,name=end" json:"end,omitempty"`
}

func (m *GraphQuery_QuestRange) Reset()                    { *m = GraphQuery_QuestRange{} }
func (m *GraphQuery_QuestRange) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery_QuestRange) ProtoMessage()               {}
func (*GraphQuery_QuestRange) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0, 2} }

func (m *GraphQuery_QuestRange) GetStart() *QuestID {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *GraphQuery_QuestRange) GetEnd() *QuestID {
	if m != nil {
		return m.End
	}
	return nil
}

// QuestList allows you to list one or more specific quests as the result of
// the query.
type GraphQuery_QuestList struct {
	Quest []*QuestID `protobuf:"bytes,1,rep,name=quest" json:"quest,omitempty"`
}

func (m *GraphQuery_QuestList) Reset()                    { *m = GraphQuery_QuestList{} }
func (m *GraphQuery_QuestList) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery_QuestList) ProtoMessage()               {}
func (*GraphQuery_QuestList) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0, 3} }

func (m *GraphQuery_QuestList) GetQuest() []*QuestID {
	if m != nil {
		return m.Quest
	}
	return nil
}

// A Search allows you to query objects whose properties match all of the
// provided filters. Filters take the form of a dot-delimited path. For
// example, say that we had the following objects:
//
//   Quest(id=deadbeef):
//     created = <timestamp>  #sort
//     descriptor.distributor_config_name = "foo"
//     descriptor.json_payload = {
//       "key": "value",
//       "multi": ["some", 10, "values", true],
//       "sub": [{"msg": 11}, {"msg": 12}],
//     }
//
//   Attempt(id=deadbeef|1):
//     created = <timestamp>  #sort
//     attempt_type = Finished
//     finished.expiration = <timestamp>
//     finished.json_result = {
//       "rslt": "yes",
//       "ok": true,
//     }
//
// Then you could query (in pseudo-proto):
//   domain: Attempt
//   approx_filters: {
//     "attempt_type": ["Finished"],
//     "$quest.descriptor.json_payload.multi": [true, 10],
//     "$quest.descriptor.json_payload.sub.msg": [11, 10],
//     "finished.json_result.ok": [true],
//   }
//
// Or:
//
//   domain: Attempt
//   exact_filters: {
//     "$quest.descriptor.json_payload.multi[1]": [10],
//     "$quest.descriptor.json_payload.sub[0].msg": [11],
//   }
//
// Literal '.' and '[' characters may be escaped with a backslash.
type GraphQuery_Search struct {
	// Domain indicates which class of objects your query applies to. The fields
	// available to query are defined by the `data` field in the corresponding
	// GraphData message.
	//
	// Additionally `Attempt` has a special field $quest whose subfields are
	// queriable in the exact same way that a search in a Quest domain works.
	Domain GraphQuery_Search_SearchDomain `protobuf:"varint,1,opt,name=domain,enum=dm.GraphQuery_Search_SearchDomain" json:"domain,omitempty"`
	// Start and End are optional AttemptRange restrictions on the first sort
	// property.  For now, these are just restrictions on the 'created'
	// timestamp for either the Quest or Attempt, depending on the SearchDomain.
	Start *PropertyValue `protobuf:"bytes,3,opt,name=start" json:"start,omitempty"`
	End   *PropertyValue `protobuf:"bytes,4,opt,name=end" json:"end,omitempty"`
	// ApproxFilters allows you to filter on 'approximate' fields. Approximate
	// fields are the json path to the value, without any array subscripts. For
	// example, if your document looked like:
	//
	//   {
	//     "some": ["list", {"of": ["data", "and", "stuff"]}],
	//   }
	//
	// Then the following approximate filters would match:
	//   "some" = ["list"]
	//   "some.of" = ["data"]
	//   "some.of" = ["and"]
	//   "some.of" = ["stuff"]
	//   "some.of" = ["stuff", "and"]
	//   "some.of" = ["stuff", "and", "data"]
	//
	// This is useful for filtering documents where the order of parameters
	// in a list or sublist isn't know, or doesn't matter.
	ApproxFilters map[string]*MultiPropertyValue `protobuf:"bytes,5,rep,name=approx_filters" json:"approx_filters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// ExactFilters allows you to filter on 'exact' fields. Exact fields are the
	// json path to the value, including array subscripts. For example if your
	// document looked like:
	//
	//   {
	//     "some": ["list", {"of": ["data", "and", "stuff"]}],
	//   }
	//
	// Then the following exact filters would match:
	//   "some[0]" = "list"
	//   "some[1].of[0]" = "data"
	//   "some[1].of[1]" = "and"
	//   "some[1].of[2]" = "stuff"
	//
	// This is useful for filtering documents where the order of parameters
	// in a list or sublist matters.
	ExactFilters map[string]*PropertyValue `protobuf:"bytes,6,rep,name=exact_filters" json:"exact_filters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *GraphQuery_Search) Reset()                    { *m = GraphQuery_Search{} }
func (m *GraphQuery_Search) String() string            { return proto.CompactTextString(m) }
func (*GraphQuery_Search) ProtoMessage()               {}
func (*GraphQuery_Search) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0, 4} }

func (m *GraphQuery_Search) GetStart() *PropertyValue {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *GraphQuery_Search) GetEnd() *PropertyValue {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *GraphQuery_Search) GetApproxFilters() map[string]*MultiPropertyValue {
	if m != nil {
		return m.ApproxFilters
	}
	return nil
}

func (m *GraphQuery_Search) GetExactFilters() map[string]*PropertyValue {
	if m != nil {
		return m.ExactFilters
	}
	return nil
}

func init() {
	proto.RegisterType((*GraphQuery)(nil), "dm.GraphQuery")
	proto.RegisterType((*GraphQuery_AttemptRange)(nil), "dm.GraphQuery.AttemptRange")
	proto.RegisterType((*GraphQuery_AttemptList)(nil), "dm.GraphQuery.AttemptList")
	proto.RegisterType((*GraphQuery_QuestRange)(nil), "dm.GraphQuery.QuestRange")
	proto.RegisterType((*GraphQuery_QuestList)(nil), "dm.GraphQuery.QuestList")
	proto.RegisterType((*GraphQuery_Search)(nil), "dm.GraphQuery.Search")
	proto.RegisterEnum("dm.GraphQuery_Search_SearchDomain", GraphQuery_Search_SearchDomain_name, GraphQuery_Search_SearchDomain_value)
}

var fileDescriptor6 = []byte{
	// 469 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x74, 0x93, 0xcd, 0x6e, 0xd3, 0x40,
	0x14, 0x85, 0x93, 0x38, 0xb1, 0xc9, 0x75, 0x52, 0x25, 0x23, 0x81, 0xcc, 0x80, 0x50, 0x14, 0x09,
	0xd2, 0x0d, 0x16, 0x0a, 0x2c, 0x10, 0x0b, 0x44, 0xab, 0xb6, 0x04, 0x54, 0x24, 0x5a, 0x24, 0xb6,
	0xd6, 0xb4, 0x1e, 0x5a, 0x0b, 0xff, 0x31, 0x9e, 0xa0, 0xfa, 0xed, 0x78, 0x01, 0xde, 0x89, 0x99,
	0xeb, 0x71, 0x6b, 0x37, 0x66, 0x15, 0x29, 0xf7, 0x3b, 0xe7, 0xdc, 0x9f, 0x31, 0xcc, 0xaf, 0x04,
	0xcb, 0xaf, 0x83, 0x5f, 0x5b, 0x2e, 0x4a, 0x3f, 0x17, 0x99, 0xcc, 0xc8, 0x20, 0x4c, 0xa8, 0x2b,
	0xcb, 0x9c, 0x17, 0xd5, 0x1f, 0xcb, 0x3f, 0x0e, 0xc0, 0x47, 0x8d, 0x9d, 0x69, 0x8a, 0xbc, 0x81,
	0x29, 0x93, 0x92, 0x27, 0xb9, 0x0c, 0x04, 0x4b, 0xaf, 0xb8, 0xd7, 0x5f, 0xf4, 0xf7, 0xdd, 0xf5,
	0x13, 0x3f, 0x4c, 0xfc, 0x3b, 0xcc, 0x3f, 0xa8, 0x98, 0x73, 0x8d, 0x6c, 0x7a, 0x64, 0x0d, 0x93,
	0x5a, 0x15, 0x47, 0x85, 0xf4, 0x06, 0x28, 0xa2, 0xdd, 0xa2, 0x53, 0x45, 0x28, 0xcd, 0x2b, 0x70,
	0x55, 0x63, 0x45, 0x9d, 0x63, 0xa1, 0xe4, 0xf1, 0x3d, 0xc9, 0x99, 0x26, 0xea, 0x14, 0x1f, 0xa0,
	0x52, 0x60, 0xc6, 0x10, 0x05, 0x5e, 0x97, 0xc0, 0x24, 0xac, 0xc0, 0x2e, 0x38, 0x13, 0x97, 0xd7,
	0xde, 0x08, 0xd9, 0x87, 0xf7, 0xd8, 0x6f, 0x58, 0xdc, 0xf4, 0xe8, 0x06, 0x26, 0xcd, 0x81, 0xc8,
	0x53, 0x18, 0x15, 0x92, 0x09, 0x69, 0x86, 0x9f, 0x6a, 0x9d, 0x01, 0x3e, 0x1d, 0x11, 0x0a, 0x16,
	0x4f, 0x43, 0x33, 0x63, 0xbb, 0x46, 0x5f, 0x82, 0xdb, 0x98, 0x92, 0x3c, 0x03, 0xc7, 0xec, 0x45,
	0x59, 0x59, 0xbb, 0xf8, 0x21, 0xc0, 0xdd, 0x84, 0xca, 0xb8, 0x15, 0xeb, 0x6a, 0x16, 0xcb, 0x2a,
	0xd4, 0x6b, 0x86, 0x36, 0x2b, 0x74, 0x05, 0xe3, 0xdb, 0xa1, 0xb5, 0x05, 0xae, 0xc8, 0xc4, 0xb5,
	0xc0, 0xbf, 0x16, 0xd8, 0xd5, 0xc8, 0xea, 0x5e, 0x76, 0x98, 0x25, 0x2c, 0x4a, 0x31, 0x6a, 0x6f,
	0xbd, 0xec, 0xdc, 0x8c, 0xf9, 0x39, 0x42, 0x92, 0x2c, 0xea, 0xee, 0xaa, 0x4b, 0xcd, 0xb5, 0xe4,
	0xab, 0xc8, 0x72, 0x2e, 0x64, 0xf9, 0x9d, 0xc5, 0x5b, 0xae, 0xa6, 0xc5, 0x1e, 0x87, 0xff, 0xab,
	0x7f, 0x80, 0x3d, 0x96, 0xab, 0x57, 0x77, 0x13, 0xfc, 0x88, 0x62, 0xc9, 0x45, 0xa1, 0xee, 0xa2,
	0xbb, 0xdc, 0xef, 0x4e, 0x3f, 0x40, 0xf6, 0xa4, 0x42, 0x8f, 0x53, 0xa9, 0x5e, 0xe7, 0x7b, 0x98,
	0xf2, 0x1b, 0x76, 0x29, 0x6f, 0x0d, 0x6c, 0x34, 0x58, 0x75, 0x1b, 0x1c, 0x6b, 0xb4, 0xa9, 0xa7,
	0xa7, 0x40, 0x3a, 0x5c, 0x5d, 0xb0, 0x7e, 0xf2, 0x12, 0x57, 0x31, 0x26, 0xcf, 0x61, 0xf4, 0x5b,
	0x77, 0x6b, 0x56, 0xfd, 0x48, 0x5b, 0x7f, 0xd9, 0xc6, 0x32, 0x6a, 0xcd, 0xf2, 0x6e, 0xf0, 0xb6,
	0x4f, 0x4f, 0x60, 0xbe, 0x13, 0xd1, 0x36, 0x5b, 0xb4, 0xcd, 0x76, 0x77, 0xa2, 0x7d, 0x96, 0x2f,
	0x60, 0xd2, 0xda, 0xf4, 0x18, 0x46, 0x78, 0xb3, 0x59, 0x4f, 0xb9, 0x39, 0xe6, 0xb5, 0xcc, 0xfa,
	0x9f, 0x87, 0x0f, 0x06, 0x33, 0xeb, 0xdc, 0x29, 0x32, 0x21, 0x83, 0x8b, 0xf2, 0xd0, 0xc1, 0x5b,
	0x8b, 0xf2, 0xc2, 0xc6, 0x2f, 0xf9, 0xf5, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb3, 0x8a, 0x6d,
	0x2f, 0xef, 0x03, 0x00, 0x00,
}
