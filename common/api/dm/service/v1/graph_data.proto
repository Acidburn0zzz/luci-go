// Copyright 2016 The LUCI Authors. All rights reserved.
// Use of this source code is governed under the Apache License, Version 2.0
// that can be found in the LICENSE file.

syntax = "proto3";

import "google/protobuf/timestamp.proto";

import "github.com/luci/luci-go/common/api/template/template.proto";

import "types.proto";

package dm;

message Quest {
  message ID {
    string id = 1;
  }
  ID id = 1;

  // DNE is set to true if this Quest does not exist. None of the following
  // fields are valid if this is set to true.
  bool DNE = 2;

  message Desc {
    string distributor_config_name = 1;
    string json_payload = 2;
  }

  message TemplateSpec {
    string project = 1;
    string ref = 2;
    string version = 3;
    string name = 4;
  }

  message Data {
    google.protobuf.Timestamp created = 1;
    Quest.Desc desc = 2;
    repeated Quest.TemplateSpec built_by = 3;
  }
  Data data = 3;

  // key is the `id` field of the Attempt.ID
  map<uint32, Attempt> attempts = 4;

  // Partial is true iff the request asked for QuestData, but wasn't able to
  // completely fill it.
  bool partial = 16;
}

message Attempt {
  message ID {
    string quest = 1;
    uint32 id = 2;
  }
  ID id = 1;

  // DNE is set to true if this Attempt does not exist. None of the following
  // fields are valid if this is set to true.
  bool DNE = 2;

  enum State {
    NEEDS_EXECUTION = 0;
    EXECUTING = 1;
    ADDING_DEPS = 2;
    BLOCKED = 3;
    AWAITING_EXECUTION_STATE = 4;
    FINISHED = 5;
  }

  message Data {
    google.protobuf.Timestamp created = 1;
    google.protobuf.Timestamp modified = 2;
    uint32 num_executions = 3;

    message NeedsExecution {
      google.protobuf.Timestamp pending = 1;
    }

    message Executing {
      uint32 cur_execution_id = 1;
    }

    message AddingDeps {
      uint32 num_adding = 1;
      uint32 num_waiting = 2;
    }

    message Blocked {
      uint32 num_waiting = 1;
    }

    message Finished {
      google.protobuf.Timestamp expiration = 1;
      uint32 json_result_size = 2;
      string json_result = 3;
    }

    oneof attempt_type {
      NeedsExecution needs_execution = 4;
      Executing executing = 5;
      AddingDeps adding_deps = 6;
      Blocked blocked = 7;
      Finished finished = 8;
    }
  }
  Data data = 3;

  // key is the `id` field of the Execution.ID
  map<uint32, Execution> executions = 4;

  dm.AttemptList fwd_deps = 5;
  dm.AttemptList back_deps = 6;

  message Partial {
    // Data is true iff the AttemptData should have been filled, but wasn't
    bool data = 1;

    // Executions is true iff the Executions were requested, but not all of
    // them could be loaded.
    bool executions = 2;

    // FwdDeps is true iff FwdDeps were requested, but not all of them could be
    // loaded.
    bool fwd_deps = 3;

    // BackDeps is true iff BackDeps were requested, but not all of them could be
    // loaded.
    bool back_deps = 4;

    enum Result {
      // LOADED implies that the result was, in fact, loaded.
      LOADED = 0;

      // NOT_LOADED is set if the result failed to load because there was
      // a transient error or the request ran out of time.
      NOT_LOADED = 1;

      // NOT_AUTHORIZED is set if the query was authenticated from an Execution
      // whose Attempt doesn't depend on this one.
      NOT_AUTHORIZED = 2;

      // DATA_SIZE_LIMIT is set if the max_data_size limit was reached.
      DATA_SIZE_LIMIT = 3;
    }
    // result is set if AttemptResults were requested, and the attempt_type is
    // Finished, but for some reason the result but wasn't loaded.
    Result result = 5;
  }
  // Partial values are true iff the request asked for AttemptData, Executions
  // or Deps, but wasn't able to completely fill them. If Partial is omitted,
  // it means that no partial data exists in this Attempt.
  Partial partial = 16;
}

message Execution {
  // Execution_Auth is a tuple of the requesting ExecutionID and the activated
  // Execution Token (see the ActivateExecution rpc).
  message Auth {
    dm.Execution.ID id = 1;
    bytes token = 2;
  }

  message ID {
    string quest = 1;
    uint32 attempt = 2;
    uint32 id = 3;
  }
  ID id = 1;

  enum State {
    // The execution has been accepted by the distributor, but is not running yet
    SCHEDULED = 0;

    // The execution is running
    RUNNING = 1;

    // The execution was unable to be accepted by the distributor
    REJECTED = 2;

    // The execution was accepted by the distributor, but couldn't run in time.
    TIMED_OUT = 3;

    // The execution ran and completed
    FINISHED = 4;

    // The execution ran, but the distributor claims it did not complete
    FAILED = 5;

    // The distributor claims to not know anything about this execution
    MISSING = 6;

    // Some entity (DM, Human, Distributor) requested that this execution not run.
    CANCELLED = 7;
  }

  message Data {
    State state = 1;
    string state_reason = 2;

    google.protobuf.Timestamp created = 3;

    string distributor_token = 4;
    string distributor_info_url = 5;
  }
  Data data = 2;

  // Partial is true iff the request asked for Executions, but wasn't able to
  // completely fill them.
  bool partial = 16;
}

// GraphData defines all of the DM graph data that may be returned from DM.
//
// Currently only WalkGraph returns GraphData, but in the future other APIs will
// explore the graph in other ways, and they'll return this same data structure.
//
// The design of this message is intended to allow clients to easily accumulate
// various GraphData from different sources in order to maintain an in-memory
// cache of data that exists in DM, where that data is discovered across
// multiple RPCs.
message GraphData {
  // Quests is the main entry point for all the graph data.
  // key is the `id` field of the QuestID
  map<string, Quest> quests = 1;

  // HadErrors is set to true if the data represented here is a partial view
  // of the requested data due to internal errors. The request may be repeated
  // or the client may chose to make smaller queries into the portions of the
  // graph that are missing.
  //
  // If HadErrors is set HadMore will also be set.
  bool had_errors = 2;

  // HadMore is set to true if the request stopped short of the full query
  // result set due to things like:
  //   * max response size limit
  //   * max time limit (e.g. WalkGraphReq.MaxTime) being hit
  //   * non-terminal errors encountered during the request (HadErrors will also
  //     be true in this case).
  //
  // Note that this is different than the Partial booleans: This refers
  // specifically to situations when Queries do not run to completion.
  bool had_more = 3;
}

