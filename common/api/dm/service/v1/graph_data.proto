// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

import "google/protobuf/timestamp.proto";

import "types.proto";

package dm;

message Quest {
  message ID {
    string id = 1;
  }
  ID id = 1;

  // DNE is set to true if this Quest does not exist. None of the following
  // fields are valid if this is set to true.
  bool DNE = 2;

  message Desc {
    string distributor_config_name = 1;
    string json_payload = 2;
  }

  message Data {
    google.protobuf.Timestamp created = 1;
    Quest.Desc desc = 2;
  }
  Data data = 3;

  // key is the `id` field of the Attempt.ID
  map<uint32, Attempt> attempts = 4;

  // Partial is true iff the request asked for QuestData, but wasn't able to
  // completely fill it.
  bool partial = 16;
}

message Attempt {
  message ID {
    string quest = 1;
    uint32 id = 2;
  }
  ID id = 1;

  // DNE is set to true if this Attempt does not exist. None of the following
  // fields are valid if this is set to true.
  bool DNE = 2;

  enum State {
    NeedsExecution = 0;
    Executing = 1;
    AddingDeps = 2;
    Blocked = 3;
    Finished = 4;
  }

  message Data {
    google.protobuf.Timestamp created = 1;
    google.protobuf.Timestamp modified = 2;
    uint32 num_executions = 3;

    message NeedsExecution {
      google.protobuf.Timestamp pending = 1;
    }

    message Executing {
      uint32 cur_execution_id = 1;
    }

    message AddingDeps {
      uint32 num_adding = 1;
      uint32 num_waiting = 2;
    }

    message Blocked {
      uint32 num_waiting = 1;
    }

    message Finished {
      google.protobuf.Timestamp expiration = 1;
      string json_result = 2;
    }

    oneof attempt_type {
      NeedsExecution needs_execution = 4;
      Executing executing = 5;
      AddingDeps adding_deps = 6;
      Blocked blocked = 7;
      Finished finished = 8;
    }
  }
  Data data = 3;

  // key is the `id` field of the Execution.ID
  map<uint32, Execution> executions = 4;

  dm.AttemptFanout fwd_deps = 5;
  dm.AttemptFanout back_deps = 6;

  message Partial {
    // Data is true iff the AttemptData should have been filled, but wasn't
    bool data = 1;

    // Executions is true iff the Executions were requested, but not all of
    // them could be loaded.
    bool executions = 2;

    // FwdDeps is true iff FwdDeps were requested, but not all of them could be
    // loaded.
    bool fwd_deps = 3;

    // BackDeps is true iff BackDeps were requested, but not all of them could be
    // loaded.
    bool back_deps = 4;

    // Result is true iff the AttemptResults were requested, and this Attempt is
    // Finished, but the result wasn't able to be loaded. This will also be
    // false in the case that the query is authenticated from an Execution whose
    // Attempt doesn't depend on this Attempt.
    bool result = 5;
  }
  // Partial values are true iff the request asked for AttemptData, Executions
  // or Deps, but wasn't able to completely fill them. If Partial is omitted,
  // it means that no partial data exists in this Attempt.
  Partial partial = 16;
}

message Execution {
  // Execution_Auth is a tuple of the requesting ExecutionID and the activated
  // Execution Token (see the ActivateExecution rpc).
  message Auth {
    dm.Execution.ID id = 1;
    bytes token = 2;
  }

  message ID {
    string quest = 1;
    uint32 attempt = 2;
    uint32 id = 3;
  }
  ID id = 1;

  enum State {
    Scheduled = 0;
    Running = 1;

    Rejected = 2;
    Finished = 3;
    Crashed = 4;
  }
  State state = 2;

  message Data {
    google.protobuf.Timestamp created = 1;
    string distributor_token = 2;
    string distributor_info_url = 3;
  }
  Data data = 3;

  // Partial is true iff the request asked for Executions, but wasn't able to
  // completely fill them.
  bool partial = 16;
}

// GraphData defines all of the DM graph data that may be returned from DM.
//
// Currently only WalkGraph returns GraphData, but in the future other APIs will
// explore the graph in other ways, and they'll return this same data structure.
//
// The design of this message is intended to allow clients to easily accumulate
// various GraphData from different sources in order to maintain an in-memory
// cache of data that exists in DM, where that data is discovered across
// multiple RPCs.
message GraphData {
  // Quests is the main entry point for all the graph data.
  // key is the `id` field of the QuestID
  map<string, Quest> quests = 1;

  // HadErrors is set to true if the data represented here is a partial view
  // of the requested data due to internal errors. The request may be repeated
  // or the client may chose to make smaller queries into the portions of the
  // graph that are missing.
  //
  // If HadErrors is set HadMore will also be set.
  bool had_errors = 2;

  // HadMore is set to true if the request stopped short of the full query
  // result set due to things like:
  //   * max response size limit
  //   * max time limit (e.g. WalkGraphReq.MaxTime) being hit
  //   * non-terminal errors encountered during the request (HadErrors will also
  //     be true in this case).
  //
  // Note that this is different than the Partial booleans: This refers
  // specifically to situations when Queries do not run to completion.
  bool had_more = 3;
}

