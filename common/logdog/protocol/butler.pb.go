// Code generated by protoc-gen-go.
// source: butler.proto
// DO NOT EDIT!

package protocol

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/luci/luci-go/common/proto/google"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

//
// This enumerates the possible contents of published Butler data.
type ButlerMetadata_ContentType int32

const (
	// An invalid content type. Do not use.
	ButlerMetadata_Invalid ButlerMetadata_ContentType = 0
	// The published data is a ButlerLogBundle protobuf message.
	ButlerMetadata_ButlerLogBundle ButlerMetadata_ContentType = 1
)

var ButlerMetadata_ContentType_name = map[int32]string{
	0: "Invalid",
	1: "ButlerLogBundle",
}
var ButlerMetadata_ContentType_value = map[string]int32{
	"Invalid":         0,
	"ButlerLogBundle": 1,
}

func (x ButlerMetadata_ContentType) String() string {
	return proto.EnumName(ButlerMetadata_ContentType_name, int32(x))
}
func (ButlerMetadata_ContentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 0}
}

// Compression scheme of attached data.
type ButlerMetadata_Compression int32

const (
	ButlerMetadata_NONE ButlerMetadata_Compression = 0
	ButlerMetadata_ZLIB ButlerMetadata_Compression = 1
)

var ButlerMetadata_Compression_name = map[int32]string{
	0: "NONE",
	1: "ZLIB",
}
var ButlerMetadata_Compression_value = map[string]int32{
	"NONE": 0,
	"ZLIB": 1,
}

func (x ButlerMetadata_Compression) String() string {
	return proto.EnumName(ButlerMetadata_Compression_name, int32(x))
}
func (ButlerMetadata_Compression) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor1, []int{0, 1}
}

//
// ButlerMetadata appears as a frame at the beginning of Butler published data
// to describe the remainder of the contents.
type ButlerMetadata struct {
	// This is the type of data in the subsequent frame.
	Type        ButlerMetadata_ContentType `protobuf:"varint,1,opt,name=type,enum=protocol.ButlerMetadata_ContentType" json:"type,omitempty"`
	Compression ButlerMetadata_Compression `protobuf:"varint,2,opt,name=compression,enum=protocol.ButlerMetadata_Compression" json:"compression,omitempty"`
}

func (m *ButlerMetadata) Reset()                    { *m = ButlerMetadata{} }
func (m *ButlerMetadata) String() string            { return proto.CompactTextString(m) }
func (*ButlerMetadata) ProtoMessage()               {}
func (*ButlerMetadata) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

//
// A message containing log data in transit from the Butler.
//
// The Butler is capable of conserving bandwidth by bundling collected log
// messages together into this protocol buffer. Based on Butler bundling
// settings, this message can represent anything from a single LogRecord to
// multiple LogRecords belonging to several different streams.
//
// Entries in a Log Bundle are fully self-descriptive: no additional information
// is needed to fully associate the contained data with its proper place in
// the source log stream.
type ButlerLogBundle struct {
	//
	// String describing the source of this LogBundle.
	// This is an unstructured field, and is not intended to be parsed. An
	// example would be: "Butler @a33967 (Linux/amd64)".
	//
	// This field will be used for debugging and internal accounting.
	Source string `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// The timestamp when this bundle was generated.
	//
	// This field will be used for debugging and internal accounting.
	Timestamp *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// *
	// Each Entry is an individual set of log records for a given log stream.
	Entries []*ButlerLogBundle_Entry `protobuf:"bytes,3,rep,name=entries" json:"entries,omitempty"`
}

func (m *ButlerLogBundle) Reset()                    { *m = ButlerLogBundle{} }
func (m *ButlerLogBundle) String() string            { return proto.CompactTextString(m) }
func (*ButlerLogBundle) ProtoMessage()               {}
func (*ButlerLogBundle) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *ButlerLogBundle) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *ButlerLogBundle) GetEntries() []*ButlerLogBundle_Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

//
// A bundle Entry describes a set of LogEntry messages originating from the
// same log stream.
type ButlerLogBundle_Entry struct {
	//
	// The descriptor for this entry's log stream.
	//
	// Each LogEntry in the "logs" field is shares this common descriptor.
	Desc *LogStreamDescriptor `protobuf:"bytes,1,opt,name=desc" json:"desc,omitempty"`
	//
	// The log prefix's secret value (required).
	//
	// The secret is generated by the Butler and unique to this specific log
	// stream. The Coordinator will record the secret associated with a given
	// log Prefix/Stream, but will not share the secret with a client.
	//
	// The Collector will check the secret prior to ingesting logs. If the
	// secret doesn't match the value recorded by the Coordinator, the log
	// will be discarded.
	//
	// This ensures that only the Butler instance that generated the log stream
	// can emit log data for that stream.
	Secret []byte `protobuf:"bytes,2,opt,name=secret,proto3" json:"secret,omitempty"`
	//
	// Whether this log entry terminates its stream.
	//
	// If present and "true", this field declares that this Entry is the last
	// such entry in the stream. This fact is recorded by the Collector and
	// registered with the Coordinator. The largest stream prefix in this Entry
	// will be bound the stream's LogEntry records to [0:largest_prefix]. Once
	// all messages in that range have been received, the log may be archived.
	//
	// Further log entries belonging to this stream with stream indices
	// exceeding the terminal log's index will be discarded.
	Terminal bool `protobuf:"varint,3,opt,name=terminal" json:"terminal,omitempty"`
	//
	// If terminal is true, this is the terminal stream index; that is, the last
	// message index in the stream.
	TerminalIndex uint64 `protobuf:"varint,4,opt,name=terminal_index" json:"terminal_index,omitempty"`
	//
	// Log entries attached to this record. These must be sequential and in
	// order.
	//
	// This is the main log entry content.
	Logs []*LogEntry `protobuf:"bytes,5,rep,name=logs" json:"logs,omitempty"`
}

func (m *ButlerLogBundle_Entry) Reset()                    { *m = ButlerLogBundle_Entry{} }
func (m *ButlerLogBundle_Entry) String() string            { return proto.CompactTextString(m) }
func (*ButlerLogBundle_Entry) ProtoMessage()               {}
func (*ButlerLogBundle_Entry) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1, 0} }

func (m *ButlerLogBundle_Entry) GetDesc() *LogStreamDescriptor {
	if m != nil {
		return m.Desc
	}
	return nil
}

func (m *ButlerLogBundle_Entry) GetLogs() []*LogEntry {
	if m != nil {
		return m.Logs
	}
	return nil
}

func init() {
	proto.RegisterType((*ButlerMetadata)(nil), "protocol.ButlerMetadata")
	proto.RegisterType((*ButlerLogBundle)(nil), "protocol.ButlerLogBundle")
	proto.RegisterType((*ButlerLogBundle_Entry)(nil), "protocol.ButlerLogBundle.Entry")
	proto.RegisterEnum("protocol.ButlerMetadata_ContentType", ButlerMetadata_ContentType_name, ButlerMetadata_ContentType_value)
	proto.RegisterEnum("protocol.ButlerMetadata_Compression", ButlerMetadata_Compression_name, ButlerMetadata_Compression_value)
}

var fileDescriptor1 = []byte{
	// 356 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x91, 0x41, 0x4f, 0x83, 0x40,
	0x10, 0x85, 0xa5, 0xa5, 0x2d, 0x1d, 0x1a, 0x6c, 0xd6, 0xc4, 0x10, 0x12, 0xd3, 0xda, 0x78, 0x68,
	0x62, 0xdc, 0x1a, 0x3c, 0x79, 0xad, 0xf6, 0xd0, 0xa4, 0xd6, 0x83, 0x3d, 0x79, 0x31, 0x14, 0x46,
	0x42, 0x02, 0x2c, 0xd9, 0x5d, 0x8c, 0xfd, 0x17, 0x5e, 0xfc, 0x65, 0xfe, 0x21, 0xd7, 0x25, 0xa0,
	0xd5, 0x83, 0x27, 0x96, 0xc7, 0xf7, 0xe6, 0xbd, 0x1d, 0x60, 0xb0, 0x2d, 0x65, 0x8a, 0x9c, 0x16,
	0x9c, 0x49, 0x46, 0x2c, 0xfd, 0x08, 0x59, 0xea, 0xf5, 0x53, 0x16, 0x57, 0xa2, 0x37, 0x8a, 0x19,
	0x8b, 0x53, 0x9c, 0xe9, 0xb7, 0x6d, 0xf9, 0x3c, 0x93, 0x49, 0x86, 0x42, 0x06, 0x59, 0x51, 0x01,
	0x93, 0x0f, 0x03, 0x9c, 0xb9, 0x1e, 0x73, 0x87, 0x32, 0x88, 0x02, 0x19, 0x10, 0x1f, 0x4c, 0xb9,
	0x2b, 0xd0, 0x35, 0xc6, 0xc6, 0xd4, 0xf1, 0xcf, 0x68, 0x3d, 0x97, 0xee, 0x73, 0xf4, 0x86, 0xe5,
	0x12, 0x73, 0xb9, 0x51, 0x2c, 0xb9, 0x06, 0x3b, 0x64, 0x59, 0xc1, 0x51, 0x88, 0x84, 0xe5, 0x6e,
	0xeb, 0x5f, 0x6b, 0xc3, 0x4e, 0x66, 0x60, 0xff, 0x9c, 0x64, 0x43, 0x6f, 0x99, 0xbf, 0x04, 0x69,
	0x12, 0x0d, 0x0f, 0xc8, 0x11, 0x1c, 0x56, 0xce, 0x15, 0x8b, 0xe7, 0x65, 0x1e, 0xa5, 0x38, 0x34,
	0x26, 0xa7, 0x5f, 0x86, 0xc6, 0x4f, 0x2c, 0x30, 0xd7, 0xf7, 0xeb, 0x85, 0xa2, 0xd5, 0xe9, 0x71,
	0xb5, 0x9c, 0x2b, 0xe4, 0xbd, 0xf5, 0xc7, 0x48, 0x1c, 0xe8, 0x0a, 0x56, 0xf2, 0xb0, 0xba, 0x58,
	0x9f, 0x5c, 0x40, 0xbf, 0x59, 0x86, 0x2e, 0x6c, 0xfb, 0x1e, 0xad, 0xd6, 0x45, 0xeb, 0x75, 0xd1,
	0x4d, 0x4d, 0x90, 0x4b, 0xe8, 0xa9, 0x8a, 0x3c, 0x41, 0xe1, 0xb6, 0xc7, 0x6d, 0x05, 0x8f, 0x7e,
	0xdf, 0xae, 0x89, 0xa2, 0x0b, 0x05, 0xee, 0xbc, 0x37, 0x03, 0x3a, 0xfa, 0x44, 0xce, 0xc1, 0x8c,
	0x50, 0x84, 0x3a, 0xd8, 0xf6, 0x4f, 0xbe, 0x8d, 0xca, 0xf2, 0x20, 0x39, 0x06, 0xd9, 0xad, 0xfa,
	0xcc, 0x93, 0x42, 0x32, 0xae, 0x7b, 0x62, 0xc8, 0x51, 0xea, 0x52, 0x03, 0x32, 0x04, 0x4b, 0x22,
	0xcf, 0x92, 0x3c, 0x48, 0x55, 0xb2, 0x31, 0xb5, 0xc8, 0x31, 0x38, 0xb5, 0xf2, 0x94, 0xe4, 0x11,
	0xbe, 0xba, 0xa6, 0xd2, 0x4d, 0x32, 0x06, 0x53, 0xfd, 0x79, 0xe1, 0x76, 0x74, 0x3f, 0xb2, 0x17,
	0xa3, 0x8b, 0x6c, 0xbb, 0x5a, 0xba, 0xfa, 0x0c, 0x00, 0x00, 0xff, 0xff, 0x95, 0x60, 0x79, 0x4e,
	0x3a, 0x02, 0x00, 0x00,
}
