// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/common/proto/milo/manifest.proto

package milo

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// A Manifest attempts to make an accurate accounting of source/data directories
// during the execution of a LUCI task.
//
// These directories are primarily in the form of e.g. git checkouts of
// source, but also include things like isolated hashes and CIPD package
// deployments. In the future, other deployment forms may be supported (like
// other SCMs).
//
// The purpose of this manifest is so that other parts of the LUCI stack (e.g.
// Milo) can work with the descriptions of this deployed data as a first-class
// citizen. Initially this Manifest will be used to allow Milo to display diffs
// between jobs, but it will also be useful for tools and humans to get a
// record of exactly what data went into this LUCI task.
//
// Source Manifests can be emitted from recipes using the
// 'recipe_engine/source_manifest' module.
type Manifest struct {
	// Version will increment on backwards-incompatible changes only. Backwards
	// compatible changes will not alter this version number.
	//
	// Currently, the only valid version number is 0.
	Version int32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	// Map of local file system directory path (with forward slashes) to
	// a Directory message containing one or more deployments.
	//
	// The local path is relative to some job-specific root. This should be used
	// for informational/display/organization purposes, and should not be used as
	// a global primary key. i.e. if you depend on chromium/src.git being in
	// a folder called “src”, I will find you and make really angry faces at you
	// until you change it...（╬ಠ益ಠ). Instead, implementations should consider
	// indexing by e.g. git repository URL or cipd package name as better primary
	// keys.
	Directories map[string]*Manifest_Directory `protobuf:"bytes,2,rep,name=directories" json:"directories,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Manifest) Reset()                    { *m = Manifest{} }
func (m *Manifest) String() string            { return proto.CompactTextString(m) }
func (*Manifest) ProtoMessage()               {}
func (*Manifest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *Manifest) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Manifest) GetDirectories() map[string]*Manifest_Directory {
	if m != nil {
		return m.Directories
	}
	return nil
}

type Manifest_GitCheckout struct {
	// The canonicalized URL of the original repo that is considered the “source
	// of truth” for the source code. Ex.
	//   https://chromium.googlesource.com/chromium/tools/build.git
	//   https://chromium.googlesource.com/infra/luci/recipes-py.git
	RepoUrl string `protobuf:"bytes,1,opt,name=repo_url,json=repoUrl" json:"repo_url,omitempty"`
	// If different from repo_url, this can be the URL of the repo that the source
	// was actually fetched from (i.e. a mirror). Ex.
	//   https://github.com/luci/recipes-py
	//
	// If this is empty, it's presumed to be equal to repo_url.
	FetchUrl string `protobuf:"bytes,2,opt,name=fetch_url,json=fetchUrl" json:"fetch_url,omitempty"`
	// The fully resolved revision (commit hash) of the source. Ex.
	//   3617b0eea7ec74b8e731a23fed2f4070cbc284c4
	Revision string `protobuf:"bytes,3,opt,name=revision" json:"revision,omitempty"`
	// The ref that the task used to resolve/fetch the revision of the source
	// (if any). Ex.
	//   refs/heads/master
	//   refs/changes/04/511804/4
	//
	// This should always be a ref on the hosted repo (not any local alias
	// like 'refs/remotes/...').
	//
	// This should always be an absolute ref (i.e. starts with 'refs/'). An
	// example of a non-absolute ref would be 'master'.
	FetchRef string `protobuf:"bytes,4,opt,name=fetch_ref,json=fetchRef" json:"fetch_ref,omitempty"`
}

func (m *Manifest_GitCheckout) Reset()                    { *m = Manifest_GitCheckout{} }
func (m *Manifest_GitCheckout) String() string            { return proto.CompactTextString(m) }
func (*Manifest_GitCheckout) ProtoMessage()               {}
func (*Manifest_GitCheckout) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 0} }

func (m *Manifest_GitCheckout) GetRepoUrl() string {
	if m != nil {
		return m.RepoUrl
	}
	return ""
}

func (m *Manifest_GitCheckout) GetFetchUrl() string {
	if m != nil {
		return m.FetchUrl
	}
	return ""
}

func (m *Manifest_GitCheckout) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func (m *Manifest_GitCheckout) GetFetchRef() string {
	if m != nil {
		return m.FetchRef
	}
	return ""
}

type Manifest_CIPDPackage struct {
	// The canonicalized URL of the CIPD server which provided the package. Ex.
	//   https://chrome-infra-packages.appspot.com
	CipdServerUrl string `protobuf:"bytes,1,opt,name=cipd_server_url,json=cipdServerUrl" json:"cipd_server_url,omitempty"`
	// The fully resolved CIPD package name that was deployed. Ex.
	//   infra/tools/luci/led/linux-amd64
	CipdPackageName string `protobuf:"bytes,2,opt,name=cipd_package_name,json=cipdPackageName" json:"cipd_package_name,omitempty"`
	// The package pattern that was given to the CIPD client (if known). Ex.
	//   infra/tools/luci/led/${platform}
	CipdPackagePattern string `protobuf:"bytes,3,opt,name=cipd_package_pattern,json=cipdPackagePattern" json:"cipd_package_pattern,omitempty"`
	// The fully resolved instance ID of the deployed package. Ex.
	//   0cfafb3a705bd8f05f86c6444ff500397fbb711c
	CipdInstanceId string `protobuf:"bytes,4,opt,name=cipd_instance_id,json=cipdInstanceId" json:"cipd_instance_id,omitempty"`
	// The unresolved version ID of the deployed package (if known). Ex.
	//   git_revision:aaf3a2cfccc227b5141caa1b6b3502c9907d7420
	//   latest
	CipdVersion string `protobuf:"bytes,5,opt,name=cipd_version,json=cipdVersion" json:"cipd_version,omitempty"`
}

func (m *Manifest_CIPDPackage) Reset()                    { *m = Manifest_CIPDPackage{} }
func (m *Manifest_CIPDPackage) String() string            { return proto.CompactTextString(m) }
func (*Manifest_CIPDPackage) ProtoMessage()               {}
func (*Manifest_CIPDPackage) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 1} }

func (m *Manifest_CIPDPackage) GetCipdServerUrl() string {
	if m != nil {
		return m.CipdServerUrl
	}
	return ""
}

func (m *Manifest_CIPDPackage) GetCipdPackageName() string {
	if m != nil {
		return m.CipdPackageName
	}
	return ""
}

func (m *Manifest_CIPDPackage) GetCipdPackagePattern() string {
	if m != nil {
		return m.CipdPackagePattern
	}
	return ""
}

func (m *Manifest_CIPDPackage) GetCipdInstanceId() string {
	if m != nil {
		return m.CipdInstanceId
	}
	return ""
}

func (m *Manifest_CIPDPackage) GetCipdVersion() string {
	if m != nil {
		return m.CipdVersion
	}
	return ""
}

type Manifest_Isolated struct {
	// The canonicalized URL of the isolated server which hosts the isolated.
	// Ex.
	//   https://isolateserver.appspot.com
	IsolatedServerUrl string `protobuf:"bytes,1,opt,name=isolated_server_url,json=isolatedServerUrl" json:"isolated_server_url,omitempty"`
	// The namespace of the isolated document. Ex.
	//   default-gzip
	Namespace string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	// The hash of the isolated document. Ex.
	//   62a7df62ea122380afb306bb4d9cdac1bc7e9a96
	Hash string `protobuf:"bytes,3,opt,name=hash" json:"hash,omitempty"`
}

func (m *Manifest_Isolated) Reset()                    { *m = Manifest_Isolated{} }
func (m *Manifest_Isolated) String() string            { return proto.CompactTextString(m) }
func (*Manifest_Isolated) ProtoMessage()               {}
func (*Manifest_Isolated) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 2} }

func (m *Manifest_Isolated) GetIsolatedServerUrl() string {
	if m != nil {
		return m.IsolatedServerUrl
	}
	return ""
}

func (m *Manifest_Isolated) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Manifest_Isolated) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

// A Directory contains one or more descriptions of deployed artifacts. Note
// that due to the practical nature of jobs on bots, it may be the case that
// a given directory contains e.g. a git checkout and multiple cipd packages.
type Manifest_Directory struct {
	GitCheckout *Manifest_GitCheckout   `protobuf:"bytes,1,opt,name=git_checkout,json=gitCheckout" json:"git_checkout,omitempty"`
	CipdPackage []*Manifest_CIPDPackage `protobuf:"bytes,2,rep,name=cipd_package,json=cipdPackage" json:"cipd_package,omitempty"`
	Isolated    []*Manifest_Isolated    `protobuf:"bytes,3,rep,name=isolated" json:"isolated,omitempty"`
}

func (m *Manifest_Directory) Reset()                    { *m = Manifest_Directory{} }
func (m *Manifest_Directory) String() string            { return proto.CompactTextString(m) }
func (*Manifest_Directory) ProtoMessage()               {}
func (*Manifest_Directory) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 3} }

func (m *Manifest_Directory) GetGitCheckout() *Manifest_GitCheckout {
	if m != nil {
		return m.GitCheckout
	}
	return nil
}

func (m *Manifest_Directory) GetCipdPackage() []*Manifest_CIPDPackage {
	if m != nil {
		return m.CipdPackage
	}
	return nil
}

func (m *Manifest_Directory) GetIsolated() []*Manifest_Isolated {
	if m != nil {
		return m.Isolated
	}
	return nil
}

func init() {
	proto.RegisterType((*Manifest)(nil), "milo.Manifest")
	proto.RegisterType((*Manifest_GitCheckout)(nil), "milo.Manifest.GitCheckout")
	proto.RegisterType((*Manifest_CIPDPackage)(nil), "milo.Manifest.CIPDPackage")
	proto.RegisterType((*Manifest_Isolated)(nil), "milo.Manifest.Isolated")
	proto.RegisterType((*Manifest_Directory)(nil), "milo.Manifest.Directory")
}

func init() {
	proto.RegisterFile("go.chromium.org/luci/common/proto/milo/manifest.proto", fileDescriptor1)
}

var fileDescriptor1 = []byte{
	// 486 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x53, 0xdd, 0x8a, 0xd3, 0x40,
	0x14, 0xa6, 0x7f, 0xbb, 0xed, 0xc9, 0xaa, 0xdd, 0x51, 0x30, 0x46, 0xc1, 0xd5, 0x0b, 0x29, 0x5e,
	0x24, 0xd2, 0x45, 0x10, 0x61, 0x2f, 0x64, 0x57, 0xa4, 0x17, 0x4a, 0x89, 0x28, 0xde, 0x85, 0x71,
	0x72, 0x9a, 0x0c, 0x4d, 0x32, 0x61, 0x32, 0x29, 0xf4, 0xc6, 0x47, 0xf3, 0x25, 0x7c, 0x01, 0x1f,
	0x45, 0x66, 0x32, 0x63, 0x63, 0x65, 0xef, 0x32, 0xdf, 0xcf, 0xcc, 0xf9, 0xce, 0x39, 0x81, 0xd7,
	0x99, 0x08, 0x59, 0x2e, 0x45, 0xc9, 0xdb, 0x32, 0x14, 0x32, 0x8b, 0x8a, 0x96, 0xf1, 0x88, 0x89,
	0xb2, 0x14, 0x55, 0x54, 0x4b, 0xa1, 0x44, 0x54, 0xf2, 0x42, 0x44, 0x25, 0xad, 0xf8, 0x06, 0x1b,
	0x15, 0x1a, 0x8c, 0x8c, 0x35, 0xf8, 0xfc, 0xd7, 0x09, 0x4c, 0x3f, 0x5a, 0x82, 0xf8, 0x70, 0xba,
	0x43, 0xd9, 0x70, 0x51, 0xf9, 0x83, 0x8b, 0xc1, 0x62, 0x12, 0xbb, 0x23, 0x79, 0x07, 0x5e, 0xca,
	0x25, 0x32, 0x25, 0x24, 0xc7, 0xc6, 0x1f, 0x5e, 0x8c, 0x16, 0xde, 0xf2, 0x69, 0xa8, 0xaf, 0x08,
	0x9d, 0x3d, 0xbc, 0x39, 0x28, 0xde, 0x57, 0x4a, 0xee, 0xe3, 0xbe, 0x27, 0xf8, 0x01, 0xde, 0x07,
	0xae, 0xae, 0x73, 0x64, 0x5b, 0xd1, 0x2a, 0xf2, 0x08, 0xa6, 0x12, 0x6b, 0x91, 0xb4, 0xb2, 0x30,
	0x8f, 0xcd, 0xe2, 0x53, 0x7d, 0xfe, 0x22, 0x0b, 0xf2, 0x18, 0x66, 0x1b, 0x54, 0x2c, 0x37, 0xdc,
	0xd0, 0x70, 0x53, 0x03, 0x68, 0x32, 0xd0, 0xbe, 0x1d, 0x37, 0x45, 0x8e, 0x3a, 0xce, 0x9d, 0x0f,
	0x46, 0x89, 0x1b, 0x7f, 0xdc, 0x33, 0xc6, 0xb8, 0x09, 0x7e, 0x0f, 0xc0, 0xbb, 0x5e, 0xad, 0x6f,
	0xd6, 0x94, 0x6d, 0x69, 0x86, 0xe4, 0x05, 0xdc, 0x63, 0xbc, 0x4e, 0x93, 0x06, 0xe5, 0x0e, 0x65,
	0xaf, 0x8e, 0x3b, 0x1a, 0xfe, 0x6c, 0x50, 0xfd, 0xe0, 0x4b, 0x38, 0x37, 0xba, 0xba, 0xf3, 0x25,
	0x15, 0x2d, 0xd1, 0x56, 0x65, 0x2e, 0xb0, 0xf7, 0x7d, 0xa2, 0x25, 0x92, 0x57, 0xf0, 0xe0, 0x1f,
	0x6d, 0x4d, 0x95, 0x42, 0xe9, 0x0a, 0x25, 0x3d, 0xf9, 0xba, 0x63, 0xc8, 0x02, 0xe6, 0xc6, 0xc1,
	0xab, 0x46, 0xd1, 0x8a, 0x61, 0xc2, 0x53, 0x5b, 0xf9, 0x5d, 0x8d, 0xaf, 0x2c, 0xbc, 0x4a, 0xc9,
	0x33, 0x38, 0x33, 0x4a, 0x37, 0xa1, 0x89, 0x51, 0x79, 0x1a, 0xfb, 0xda, 0x41, 0x41, 0x01, 0xd3,
	0x55, 0x23, 0x0a, 0xaa, 0x30, 0x25, 0x21, 0xdc, 0xe7, 0xf6, 0xfb, 0xff, 0x88, 0xe7, 0x8e, 0x3a,
	0xc4, 0x7c, 0x02, 0x33, 0x9d, 0xac, 0xa9, 0x29, 0x73, 0xf1, 0x0e, 0x00, 0x21, 0x30, 0xce, 0x69,
	0x93, 0xdb, 0x20, 0xe6, 0x3b, 0xf8, 0x39, 0x80, 0x99, 0x1b, 0xf9, 0x9e, 0x5c, 0xc1, 0x59, 0xc6,
	0x55, 0xc2, 0xec, 0x7c, 0xcd, 0x43, 0xde, 0x32, 0x38, 0x5a, 0x91, 0xde, 0x06, 0xc4, 0x5e, 0xd6,
	0x5b, 0x87, 0x2b, 0x9b, 0xce, 0x76, 0xce, 0x6e, 0xd8, 0xb1, 0xbd, 0x37, 0xbf, 0x2e, 0xb9, 0x1b,
	0xe6, 0x25, 0x4c, 0x5d, 0x24, 0x7f, 0x64, 0xac, 0x0f, 0x8f, 0xac, 0xae, 0x31, 0xf1, 0x5f, 0x61,
	0xf0, 0x0d, 0xe6, 0xc7, 0x2b, 0x4b, 0xe6, 0x30, 0xda, 0xe2, 0xde, 0xb6, 0x49, 0x7f, 0x92, 0x10,
	0x26, 0x3b, 0x5a, 0xb4, 0x5d, 0x53, 0xbc, 0xa5, 0x7f, 0xcb, 0xd2, 0xef, 0xe3, 0x4e, 0xf6, 0x76,
	0xf8, 0x66, 0xf0, 0xfd, 0xc4, 0xfc, 0x62, 0x97, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xcd, 0xe1,
	0x8e, 0xc6, 0x9b, 0x03, 0x00, 0x00,
}
