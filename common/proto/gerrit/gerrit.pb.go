// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/common/proto/gerrit/gerrit.proto

/*
Package gerrit is a generated protocol buffer package.

It is generated from these files:
	go.chromium.org/luci/common/proto/gerrit/gerrit.proto

It has these top-level messages:
	CheckAccessRequest
	CheckAccessResponse
*/
package gerrit

import prpc "go.chromium.org/luci/grpc/prpc"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CheckAccessResponse_Status int32

const (
	// ALLOWED means user has the permission being checked.
	CheckAccessResponse_ALLOWED CheckAccessResponse_Status = 0
	// FORBIDDEN means user does not have the permission being checked.
	CheckAccessResponse_FORBIDDEN CheckAccessResponse_Status = 1
	// PROJECT_NOT_FOUND means project doesn't exist.
	CheckAccessResponse_PROJECT_NOT_FOUND CheckAccessResponse_Status = 2
)

var CheckAccessResponse_Status_name = map[int32]string{
	0: "ALLOWED",
	1: "FORBIDDEN",
	2: "PROJECT_NOT_FOUND",
}
var CheckAccessResponse_Status_value = map[string]int32{
	"ALLOWED":           0,
	"FORBIDDEN":         1,
	"PROJECT_NOT_FOUND": 2,
}

func (x CheckAccessResponse_Status) String() string {
	return proto.EnumName(CheckAccessResponse_Status_name, int32(x))
}
func (CheckAccessResponse_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{1, 0}
}

// Request message for gerrit.CheckAccess.
type CheckAccessRequest struct {
	// Gerrit project, e.g. "chromium/src" part in
	// https://chromium.googlesource.com/chromium/src/+/master
	// Required.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	// The ref for which to check access.
	// Required for most permissions.
	Ref string `protobuf:"bytes,2,opt,name=ref" json:"ref,omitempty"`
	// Gerrit permission.
	//
	// Frequently checked permissions are:
	//  * read
	//  * push
	//  * label-<Label>-<Name> (e.g., label-Code-Review)
	//  * submit
	// For others, consult Gerrit docs:
	// https://gerrit-review.googlesource.com/Documentation/access-control.html#access_categories
	//
	// Required.
	Permission string `protobuf:"bytes,3,opt,name=permission" json:"permission,omitempty"`
	// Gerrit account identifier such as email or account_id.
	Account string `protobuf:"bytes,4,opt,name=account" json:"account,omitempty"`
}

func (m *CheckAccessRequest) Reset()                    { *m = CheckAccessRequest{} }
func (m *CheckAccessRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckAccessRequest) ProtoMessage()               {}
func (*CheckAccessRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *CheckAccessRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *CheckAccessRequest) GetRef() string {
	if m != nil {
		return m.Ref
	}
	return ""
}

func (m *CheckAccessRequest) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

func (m *CheckAccessRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

// Response message for gerrit.CheckAccess.
type CheckAccessResponse struct {
	// Status is the status of the inquery.
	Status CheckAccessResponse_Status `protobuf:"varint,1,opt,name=status,enum=gerrit.CheckAccessResponse_Status" json:"status,omitempty"`
	// Reason is human readable clarifying message if not allowed.
	Reason string `protobuf:"bytes,2,opt,name=reason" json:"reason,omitempty"`
}

func (m *CheckAccessResponse) Reset()                    { *m = CheckAccessResponse{} }
func (m *CheckAccessResponse) String() string            { return proto.CompactTextString(m) }
func (*CheckAccessResponse) ProtoMessage()               {}
func (*CheckAccessResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *CheckAccessResponse) GetStatus() CheckAccessResponse_Status {
	if m != nil {
		return m.Status
	}
	return CheckAccessResponse_ALLOWED
}

func (m *CheckAccessResponse) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func init() {
	proto.RegisterType((*CheckAccessRequest)(nil), "gerrit.CheckAccessRequest")
	proto.RegisterType((*CheckAccessResponse)(nil), "gerrit.CheckAccessResponse")
	proto.RegisterEnum("gerrit.CheckAccessResponse_Status", CheckAccessResponse_Status_name, CheckAccessResponse_Status_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Gerrit service

type GerritClient interface {
	// Checks if a user has a permission on given repo and ref.
	//
	// Using this API requires ViewAccess capability on Gerrit server.
	// If and only if the caller doesn't have such capability, the result is error
	// forbidden.
	//
	// Note, providing non-existent project name is not an error, but resulting
	// CheckAccessResponse will state that project was not found.
	CheckAccess(ctx context.Context, in *CheckAccessRequest, opts ...grpc.CallOption) (*CheckAccessResponse, error)
}
type gerritPRPCClient struct {
	client *prpc.Client
}

func NewGerritPRPCClient(client *prpc.Client) GerritClient {
	return &gerritPRPCClient{client}
}

func (c *gerritPRPCClient) CheckAccess(ctx context.Context, in *CheckAccessRequest, opts ...grpc.CallOption) (*CheckAccessResponse, error) {
	out := new(CheckAccessResponse)
	err := c.client.Call(ctx, "gerrit.Gerrit", "CheckAccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type gerritClient struct {
	cc *grpc.ClientConn
}

func NewGerritClient(cc *grpc.ClientConn) GerritClient {
	return &gerritClient{cc}
}

func (c *gerritClient) CheckAccess(ctx context.Context, in *CheckAccessRequest, opts ...grpc.CallOption) (*CheckAccessResponse, error) {
	out := new(CheckAccessResponse)
	err := grpc.Invoke(ctx, "/gerrit.Gerrit/CheckAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Gerrit service

type GerritServer interface {
	// Checks if a user has a permission on given repo and ref.
	//
	// Using this API requires ViewAccess capability on Gerrit server.
	// If and only if the caller doesn't have such capability, the result is error
	// forbidden.
	//
	// Note, providing non-existent project name is not an error, but resulting
	// CheckAccessResponse will state that project was not found.
	CheckAccess(context.Context, *CheckAccessRequest) (*CheckAccessResponse, error)
}

func RegisterGerritServer(s prpc.Registrar, srv GerritServer) {
	s.RegisterService(&_Gerrit_serviceDesc, srv)
}

func _Gerrit_CheckAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GerritServer).CheckAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gerrit.Gerrit/CheckAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GerritServer).CheckAccess(ctx, req.(*CheckAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Gerrit_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gerrit.Gerrit",
	HandlerType: (*GerritServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckAccess",
			Handler:    _Gerrit_CheckAccess_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/common/proto/gerrit/gerrit.proto",
}

func init() {
	proto.RegisterFile("go.chromium.org/luci/common/proto/gerrit/gerrit.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 297 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x91, 0x5f, 0x4b, 0xc3, 0x30,
	0x14, 0xc5, 0xd7, 0x4d, 0x32, 0x76, 0x87, 0x52, 0xaf, 0x28, 0x65, 0x82, 0x48, 0x9f, 0x7c, 0x6a,
	0x61, 0xe2, 0x8b, 0x3e, 0xcd, 0x75, 0xf3, 0x0f, 0x63, 0x95, 0x38, 0xf1, 0x71, 0xcc, 0x10, 0xb7,
	0xaa, 0xed, 0xad, 0x49, 0xfa, 0xe2, 0x07, 0xf2, 0x73, 0xca, 0xd2, 0x08, 0x13, 0x86, 0x4f, 0xc9,
	0x39, 0x39, 0xb9, 0xe7, 0x47, 0x02, 0x17, 0x4b, 0x8a, 0xc4, 0x4a, 0x51, 0x9e, 0x55, 0x79, 0x44,
	0x6a, 0x19, 0x7f, 0x54, 0x22, 0x8b, 0x05, 0xe5, 0x39, 0x15, 0x71, 0xa9, 0xc8, 0x50, 0xbc, 0x94,
	0x4a, 0x65, 0xc6, 0x2d, 0x91, 0xf5, 0x90, 0xd5, 0x2a, 0xfc, 0x02, 0x1c, 0xae, 0xa4, 0x78, 0x1f,
	0x08, 0x21, 0xb5, 0xe6, 0xf2, 0xb3, 0x92, 0xda, 0x60, 0x00, 0xed, 0x52, 0xd1, 0x9b, 0x14, 0x26,
	0xf0, 0x4e, 0xbd, 0xb3, 0x0e, 0xff, 0x95, 0xe8, 0x43, 0x4b, 0xc9, 0xd7, 0xa0, 0x69, 0xdd, 0xf5,
	0x16, 0x4f, 0x00, 0x4a, 0xa9, 0xf2, 0x4c, 0xeb, 0x8c, 0x8a, 0xa0, 0x65, 0x0f, 0x36, 0x9c, 0xf5,
	0xac, 0x85, 0x10, 0x54, 0x15, 0x26, 0xd8, 0xa9, 0x67, 0x39, 0x19, 0x7e, 0x7b, 0x70, 0xf0, 0xa7,
	0x5c, 0x97, 0x54, 0x68, 0x89, 0x97, 0xc0, 0xb4, 0x59, 0x98, 0x4a, 0xdb, 0xf2, 0xbd, 0x7e, 0x18,
	0x39, 0xf4, 0x2d, 0xe1, 0xe8, 0xd1, 0x26, 0xb9, 0xbb, 0x81, 0x47, 0xc0, 0x94, 0x5c, 0x68, 0x2a,
	0x1c, 0xa2, 0x53, 0xe1, 0x15, 0xb0, 0x3a, 0x89, 0x5d, 0x68, 0x0f, 0x26, 0x93, 0xf4, 0x79, 0x94,
	0xf8, 0x0d, 0xdc, 0x85, 0xce, 0x38, 0xe5, 0xd7, 0x77, 0x49, 0x32, 0x9a, 0xfa, 0x1e, 0x1e, 0xc2,
	0xfe, 0x03, 0x4f, 0xef, 0x47, 0xc3, 0xd9, 0x7c, 0x9a, 0xce, 0xe6, 0xe3, 0xf4, 0x69, 0x9a, 0xf8,
	0xcd, 0x3e, 0x07, 0x76, 0x63, 0x09, 0xf0, 0x16, 0xba, 0x1b, 0x10, 0xd8, 0xdb, 0x4a, 0x66, 0xdf,
	0xb0, 0x77, 0xfc, 0x0f, 0x75, 0xd8, 0x78, 0x61, 0xf6, 0x1f, 0xce, 0x7f, 0x02, 0x00, 0x00, 0xff,
	0xff, 0xff, 0xbd, 0x5e, 0x41, 0xc0, 0x01, 0x00, 0x00,
}
