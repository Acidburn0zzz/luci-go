// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

syntax = "proto3";

package svcconfig;

import "transport.proto";
import "storage.proto";
import "google/protobuf/duration.proto";

// Config is the overall instance configuration.
message Config {
  // Configuration for the Pub/Sub instances.
  Transport transport = 10;
  // Configuration for Storage.
  Storage storage = 11;

  // Coordinator is the coordinator service configuration.
  Coordinator coordinator = 20;
  // Collector is the collector fleet configuration.
  Collector collector = 21;
  // Archivist microservice configuration.
  Archivist archivist = 22;
}

// Coordinator is the Coordinator service configuration.
message Coordinator {
  // Project is the name of the AppEngine Project that the Coordinator belongs
  // to.
  string project = 1;

  // The name of the authentication group for administrators.
  string admin_auth_group = 10;
  // The name of the authentication group for backend services.
  string service_auth_group = 11;

  // A list of origin URLs that are allowed to perform CORS RPC calls.
  repeated string rpc_allow_origins = 20;

  // The name of the archive task queue.
  string archive_task_queue = 30;
  // The amount of time after a log has been terminated before it is candidate
  // for archival.
  //
  // Archival triggered by this delay will NOT succeed if any log entries are
  // missing from intermediate storage.
  //
  // This should be based on a period of time where it's reasonable to expect
  // that all log messages in the transport have arrived for a given log stream.
  // Since the transport doesn't have to guarantee in-order delivery, this
  // should allow for the case where the terminal log entry arrives before some
  // of the intermediate log entries. This will help avoid triggering
  // archive attempts that are doomed to fail because of standard transport lag.
  google.protobuf.Duration archive_delay = 31;
  // The amount of time before a log stream is candidate for archival regardless
  // of whether or not it's been terminated or complete.
  //
  // This endpoint is a failsafe designed to ensure that log streams with
  // missing records or no terminal record (e.g., Butler crashed) are eventually
  // moved out of intermediate storage.
  //
  // This must be >= `archive_delay`, and should be fairly large (days) to allow
  // for the log stream to complete and for all available log entries to be
  // added to intermediate storage.
  google.protobuf.Duration archive_delay_max = 32;

  // The name of the storage cleanup task queue.
  string storage_cleanup_task_queue = 40;
  // The amount of time to wait before initiating a storage cleanup task.
  google.protobuf.Duration storage_cleanup_delay = 41;
}

// Collector is the set of configuration parameters for Collector instances.
message Collector {
  // Workers is the number of ingest workers to run.
  int32 workers = 1;

  // The number of transport worker goroutines to run.
  int32 transport_workers = 2;

  // The maximum number of log stream states to cache locally. If <= 0, a
  // default will be used.
  int32 state_cache_size = 3;

  // The maximum amount of time that cached stream state is valid. If <= 0, a
  // default will be used.
  google.protobuf.Duration state_cache_expiration = 4;
}

// Configuration for the Archivist microservice.
message Archivist {
  // The number of tasks to run at a time. If blank, the archivist will choose a
  // default value.
  int32 tasks = 1;

  // The name of the Google Storage bucket and optional base path to archive
  // into. For example: gs://foo/bar
  //
  // The bucket name must be included (e.g., "gs://foo"). The remainder of the
  // base path is optional based on desired archive location.
  string gs_base = 10;
  // If not zero, the maximum number of stream indices between index entries.
  int32 stream_index_range = 11;
  // If not zero, the maximum number of prefix indices between index entries.
  int32 prefix_index_range = 12;
  // If not zero, the maximum number of log data bytes between index entries.
  int32 byte_range = 13;
}
