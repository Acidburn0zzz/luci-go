// Code generated by protoc-gen-go.
// source: config.proto
// DO NOT EDIT!

/*
Package svcconfig is a generated protocol buffer package.

It is generated from these files:
	config.proto
	storage.proto
	transport.proto

It has these top-level messages:
	Config
	Coordinator
	Collector
	Archivist
	Storage
	Transport
*/
package svcconfig

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/luci/luci-go/common/proto/google"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// Config is the overall instance configuration.
type Config struct {
	// Configuration for the Pub/Sub instances.
	Transport *Transport `protobuf:"bytes,10,opt,name=transport" json:"transport,omitempty"`
	// Configuration for Storage.
	Storage *Storage `protobuf:"bytes,11,opt,name=storage" json:"storage,omitempty"`
	// Coordinator is the coordinator service configuration.
	Coordinator *Coordinator `protobuf:"bytes,20,opt,name=coordinator" json:"coordinator,omitempty"`
	// Collector is the collector fleet configuration.
	Collector *Collector `protobuf:"bytes,21,opt,name=collector" json:"collector,omitempty"`
	// Archivist microservice configuration.
	Archivist *Archivist `protobuf:"bytes,22,opt,name=archivist" json:"archivist,omitempty"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Config) GetTransport() *Transport {
	if m != nil {
		return m.Transport
	}
	return nil
}

func (m *Config) GetStorage() *Storage {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *Config) GetCoordinator() *Coordinator {
	if m != nil {
		return m.Coordinator
	}
	return nil
}

func (m *Config) GetCollector() *Collector {
	if m != nil {
		return m.Collector
	}
	return nil
}

func (m *Config) GetArchivist() *Archivist {
	if m != nil {
		return m.Archivist
	}
	return nil
}

// Coordinator is the Coordinator service configuration.
type Coordinator struct {
	// Project is the name of the AppEngine Project that the Coordinator belongs
	// to.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	// The name of the authentication group for administrators.
	AdminAuthGroup string `protobuf:"bytes,10,opt,name=admin_auth_group,json=adminAuthGroup" json:"admin_auth_group,omitempty"`
	// The name of the authentication group for backend services.
	ServiceAuthGroup string `protobuf:"bytes,11,opt,name=service_auth_group,json=serviceAuthGroup" json:"service_auth_group,omitempty"`
	// A list of origin URLs that are allowed to perform CORS RPC calls.
	RpcAllowOrigins []string `protobuf:"bytes,20,rep,name=rpc_allow_origins,json=rpcAllowOrigins" json:"rpc_allow_origins,omitempty"`
	// The full path of the archival Pub/Sub topic.
	//
	// The Coordinator must have permission to publish to this topic.
	ArchiveTopic string `protobuf:"bytes,30,opt,name=archive_topic,json=archiveTopic" json:"archive_topic,omitempty"`
	// The amount of time after an archive request has been dispatched before it
	// should be executed.
	//
	// Since terminal messages can arrive out of order, the archival request may
	// be kicked off before all of the log stream data has been loaded into
	// intermediate storage. If this happens, the Archivist will retry archival
	// later autometically.
	//
	// This parameter is an optimization to stop the archivist from wasting its
	// time until the log stream has a reasonable expectation of being available.
	ArchiveSettleDelay *google_protobuf.Duration `protobuf:"bytes,31,opt,name=archive_settle_delay,json=archiveSettleDelay" json:"archive_settle_delay,omitempty"`
	// The amount of time before a log stream is candidate for archival regardless
	// of whether or not it's been terminated or complete.
	//
	// This is a failsafe designed to ensure that log streams with missing records
	// or no terminal record (e.g., Butler crashed) are eventually archived.
	//
	// This should be fairly large (days) to avoid prematurely archiving
	// long-running streams, but should be considerably smaller than the
	// intermediate storage data retention period.
	ArchiveDelayMax *google_protobuf.Duration `protobuf:"bytes,32,opt,name=archive_delay_max,json=archiveDelayMax" json:"archive_delay_max,omitempty"`
}

func (m *Coordinator) Reset()                    { *m = Coordinator{} }
func (m *Coordinator) String() string            { return proto.CompactTextString(m) }
func (*Coordinator) ProtoMessage()               {}
func (*Coordinator) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Coordinator) GetArchiveSettleDelay() *google_protobuf.Duration {
	if m != nil {
		return m.ArchiveSettleDelay
	}
	return nil
}

func (m *Coordinator) GetArchiveDelayMax() *google_protobuf.Duration {
	if m != nil {
		return m.ArchiveDelayMax
	}
	return nil
}

// Collector is the set of configuration parameters for Collector instances.
type Collector struct {
	// The maximum number of concurrent transport messages to process. If <= 0,
	// a default will be chosen based on the transport.
	MaxConcurrentMessages int32 `protobuf:"varint,1,opt,name=max_concurrent_messages,json=maxConcurrentMessages" json:"max_concurrent_messages,omitempty"`
	// The maximum number of concurrent workers to process each ingested message.
	// If <= 0, collector.DefaultMaxMessageWorkers will be used.
	MaxMessageWorkers int32 `protobuf:"varint,2,opt,name=max_message_workers,json=maxMessageWorkers" json:"max_message_workers,omitempty"`
	// The maximum number of log stream states to cache locally. If <= 0, a
	// default will be used.
	StateCacheSize int32 `protobuf:"varint,3,opt,name=state_cache_size,json=stateCacheSize" json:"state_cache_size,omitempty"`
	// The maximum amount of time that cached stream state is valid. If <= 0, a
	// default will be used.
	StateCacheExpiration *google_protobuf.Duration `protobuf:"bytes,4,opt,name=state_cache_expiration,json=stateCacheExpiration" json:"state_cache_expiration,omitempty"`
}

func (m *Collector) Reset()                    { *m = Collector{} }
func (m *Collector) String() string            { return proto.CompactTextString(m) }
func (*Collector) ProtoMessage()               {}
func (*Collector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Collector) GetStateCacheExpiration() *google_protobuf.Duration {
	if m != nil {
		return m.StateCacheExpiration
	}
	return nil
}

// Configuration for the Archivist microservice.
type Archivist struct {
	// The name of the archival Pub/Sub subscription.
	//
	// This should be connected to "archive_topic", and the Archivist must have
	// permission to consume from this subscription.
	Subscription string `protobuf:"bytes,1,opt,name=subscription" json:"subscription,omitempty"`
	// The number of tasks to run at a time. If blank, the archivist will choose a
	// default value.
	Tasks int32 `protobuf:"varint,2,opt,name=tasks" json:"tasks,omitempty"`
	// The name of the Google Storage bucket and optional base path to archive
	// into. For example: gs://foo/bar
	//
	// The bucket name must be included (e.g., "gs://foo"). The remainder of the
	// base path is optional based on desired archive location.
	GsBase string `protobuf:"bytes,3,opt,name=gs_base,json=gsBase" json:"gs_base,omitempty"`
	// The name of the staging storage bucket. Uses same notation as "gs_base".
	GsStagingBase string `protobuf:"bytes,4,opt,name=gs_staging_base,json=gsStagingBase" json:"gs_staging_base,omitempty"`
	// If not zero, the maximum number of stream indices between index entries.
	StreamIndexRange int32 `protobuf:"varint,10,opt,name=stream_index_range,json=streamIndexRange" json:"stream_index_range,omitempty"`
	// If not zero, the maximum number of prefix indices between index entries.
	PrefixIndexRange int32 `protobuf:"varint,11,opt,name=prefix_index_range,json=prefixIndexRange" json:"prefix_index_range,omitempty"`
	// If not zero, the maximum number of log data bytes between index entries.
	ByteRange int32 `protobuf:"varint,12,opt,name=byte_range,json=byteRange" json:"byte_range,omitempty"`
}

func (m *Archivist) Reset()                    { *m = Archivist{} }
func (m *Archivist) String() string            { return proto.CompactTextString(m) }
func (*Archivist) ProtoMessage()               {}
func (*Archivist) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func init() {
	proto.RegisterType((*Config)(nil), "svcconfig.Config")
	proto.RegisterType((*Coordinator)(nil), "svcconfig.Coordinator")
	proto.RegisterType((*Collector)(nil), "svcconfig.Collector")
	proto.RegisterType((*Archivist)(nil), "svcconfig.Archivist")
}

var fileDescriptor0 = []byte{
	// 619 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x93, 0x5d, 0x4b, 0x1b, 0x4f,
	0x18, 0xc5, 0x31, 0xbe, 0xb1, 0x4f, 0xa2, 0xd1, 0xf9, 0x47, 0x9d, 0xbf, 0x50, 0x2b, 0x29, 0x14,
	0x29, 0x65, 0x05, 0x0b, 0xa5, 0xb7, 0x36, 0x4a, 0x29, 0x45, 0x84, 0x8d, 0xd0, 0xcb, 0x61, 0x32,
	0x19, 0xd7, 0xa9, 0x9b, 0x9d, 0x65, 0x66, 0x12, 0x63, 0xef, 0x7a, 0xdf, 0x8f, 0xd9, 0xeb, 0x7e,
	0x86, 0xce, 0xcb, 0xbe, 0x89, 0x17, 0x5e, 0xce, 0x39, 0xbf, 0x73, 0x76, 0xf6, 0xd9, 0x67, 0xa1,
	0xc7, 0x64, 0x7e, 0x2b, 0xd2, 0xb8, 0x50, 0xd2, 0x48, 0x14, 0xe9, 0x05, 0x0b, 0xc2, 0x61, 0xdf,
	0x28, 0x9a, 0xeb, 0x42, 0x2a, 0x13, 0xbc, 0xc3, 0x2d, 0x6d, 0xa4, 0xa2, 0x29, 0x2f, 0x8f, 0x47,
	0xa9, 0x94, 0x69, 0xc6, 0x4f, 0xfd, 0x69, 0x32, 0xbf, 0x3d, 0x9d, 0xce, 0x15, 0x35, 0x42, 0xe6,
	0xc1, 0x1f, 0xfe, 0xee, 0xc0, 0xc6, 0xc8, 0x57, 0xa1, 0x33, 0x88, 0xea, 0x32, 0x0c, 0xc7, 0x2b,
	0x27, 0xdd, 0xb3, 0x41, 0x5c, 0x3f, 0x29, 0xbe, 0xa9, 0xbc, 0xa4, 0xc1, 0xd0, 0x7b, 0xd8, 0x2c,
	0x9f, 0x87, 0xbb, 0x3e, 0x81, 0x5a, 0x89, 0x71, 0x70, 0x92, 0x0a, 0x41, 0x9f, 0xa0, 0xcb, 0xa4,
	0x54, 0x53, 0x91, 0x53, 0xab, 0xe0, 0x81, 0x4f, 0xec, 0xb7, 0x12, 0xa3, 0xc6, 0x4d, 0xda, 0xa8,
	0xbb, 0x1b, 0x93, 0x59, 0xc6, 0x99, 0xcb, 0xed, 0x3d, 0xbb, 0xdb, 0xa8, 0xf2, 0x92, 0x06, 0x73,
	0x19, 0xaa, 0xd8, 0x9d, 0x58, 0x08, 0x6d, 0xf0, 0xfe, 0xb3, 0xcc, 0x79, 0xe5, 0x25, 0x0d, 0x36,
	0xfc, 0xd3, 0x81, 0x6e, 0xeb, 0x12, 0x08, 0xc3, 0xa6, 0x9d, 0xd3, 0x0f, 0x5b, 0x88, 0x57, 0x6c,
	0x43, 0x94, 0x54, 0x47, 0x74, 0x02, 0x3b, 0x74, 0x3a, 0x13, 0x39, 0xa1, 0x73, 0x73, 0x47, 0x52,
	0x25, 0xe7, 0x85, 0x1f, 0x5a, 0x94, 0x6c, 0x7b, 0xfd, 0xdc, 0xca, 0x5f, 0x9c, 0x6a, 0x67, 0x84,
	0x34, 0x57, 0x0b, 0xc1, 0x78, 0x9b, 0xed, 0x7a, 0x76, 0xa7, 0x74, 0x1a, 0xfa, 0x1d, 0xec, 0xaa,
	0x82, 0x11, 0x9a, 0x65, 0xf2, 0x81, 0x48, 0x25, 0x52, 0x91, 0x6b, 0x3b, 0xa9, 0x55, 0x0b, 0xf7,
	0xad, 0x71, 0xee, 0xf4, 0xeb, 0x20, 0xa3, 0x37, 0xb0, 0x15, 0xae, 0xce, 0x89, 0x91, 0x85, 0x60,
	0xf8, 0xc8, 0x97, 0xf6, 0x4a, 0xf1, 0xc6, 0x69, 0xe8, 0x1b, 0x0c, 0x2a, 0x48, 0x73, 0x63, 0x32,
	0x4e, 0xa6, 0x3c, 0xa3, 0x8f, 0xf8, 0xb5, 0x9f, 0xc8, 0xff, 0x71, 0x58, 0x90, 0xb8, 0x5a, 0x90,
	0xf8, 0xa2, 0x5c, 0x90, 0x04, 0x95, 0xb1, 0xb1, 0x4f, 0x5d, 0xb8, 0x10, 0xba, 0x84, 0xdd, 0xaa,
	0xcc, 0xb7, 0x90, 0x19, 0x5d, 0xe2, 0xe3, 0x97, 0x9a, 0xfa, 0x65, 0xc6, 0x77, 0x5c, 0xd1, 0xe5,
	0xf0, 0xef, 0x0a, 0x44, 0xf5, 0x37, 0x43, 0x1f, 0xe1, 0xc0, 0xd6, 0x10, 0xfb, 0x5d, 0xd8, 0x5c,
	0x29, 0x9e, 0x1b, 0x32, 0xe3, 0x5a, 0xdb, 0x85, 0xd1, 0x7e, 0xe8, 0xeb, 0xc9, 0x9e, 0xb5, 0x47,
	0xb5, 0x7b, 0x55, 0x9a, 0x28, 0x86, 0xff, 0x5c, 0xae, 0x84, 0xc9, 0x83, 0x54, 0xf7, 0x5c, 0x69,
	0xdc, 0xf1, 0x99, 0x5d, 0x6b, 0x95, 0xe4, 0xf7, 0x60, 0xb8, 0x4f, 0xa6, 0x0d, 0x35, 0x9c, 0x30,
	0xca, 0xee, 0xec, 0x34, 0xc4, 0x4f, 0x8e, 0x57, 0x3d, 0xbc, 0xed, 0xf5, 0x91, 0x93, 0xc7, 0x56,
	0x45, 0xd7, 0xb0, 0xdf, 0x26, 0xf9, 0xb2, 0x10, 0xe1, 0x55, 0xf0, 0xda, 0x4b, 0xef, 0x3a, 0x68,
	0xaa, 0x2e, 0xeb, 0xd8, 0xf0, 0x57, 0x07, 0xa2, 0x7a, 0xe1, 0xd0, 0x10, 0x7a, 0x7a, 0x3e, 0xd1,
	0x4c, 0x89, 0xc2, 0x97, 0x86, 0xd5, 0x7a, 0xa2, 0xa1, 0x01, 0xac, 0x1b, 0xaa, 0xef, 0xab, 0xd7,
	0x09, 0x07, 0x74, 0x00, 0x9b, 0xa9, 0x26, 0x13, 0xaa, 0xc3, 0xcd, 0xa3, 0x64, 0x23, 0xd5, 0x9f,
	0xed, 0x09, 0xbd, 0x85, 0xbe, 0x35, 0xec, 0xb3, 0xed, 0x62, 0xa4, 0x01, 0x58, 0xf3, 0xc0, 0x56,
	0xaa, 0xc7, 0x41, 0xf5, 0x9c, 0x5b, 0x46, 0xa3, 0x38, 0x9d, 0x11, 0x91, 0x4f, 0xf9, 0x92, 0xd8,
	0x3f, 0xd9, 0xfe, 0xbb, 0xe0, 0x9f, 0xb1, 0x13, 0x9c, 0xaf, 0xce, 0x48, 0x9c, 0xee, 0xe8, 0x42,
	0xf1, 0x5b, 0xb1, 0x7c, 0x42, 0x77, 0x03, 0x1d, 0x9c, 0x16, 0xfd, 0x0a, 0x60, 0xf2, 0x68, 0x87,
	0x16, 0xa8, 0x9e, 0xa7, 0x22, 0xa7, 0x78, 0x7b, 0xb2, 0xe1, 0x87, 0xf5, 0xe1, 0x5f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xd7, 0xf6, 0xf2, 0x8f, 0xcc, 0x04, 0x00, 0x00,
}
