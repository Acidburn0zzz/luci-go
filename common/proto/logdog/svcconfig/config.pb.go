// Code generated by protoc-gen-go.
// source: config.proto
// DO NOT EDIT!

/*
Package svcconfig is a generated protocol buffer package.

It is generated from these files:
	config.proto
	storage.proto
	transport.proto

It has these top-level messages:
	Config
	Coordinator
	Collector
	Archivist
	Storage
	Transport
*/
package svcconfig

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/luci/luci-go/common/proto/google"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// Config is the overall instance configuration.
type Config struct {
	// Configuration for the Pub/Sub instances.
	Transport *Transport `protobuf:"bytes,10,opt,name=transport" json:"transport,omitempty"`
	// Configuration for Storage.
	Storage *Storage `protobuf:"bytes,11,opt,name=storage" json:"storage,omitempty"`
	// Coordinator is the coordinator service configuration.
	Coordinator *Coordinator `protobuf:"bytes,20,opt,name=coordinator" json:"coordinator,omitempty"`
	// Collector is the collector fleet configuration.
	Collector *Collector `protobuf:"bytes,21,opt,name=collector" json:"collector,omitempty"`
	// Archivist microservice configuration.
	Archivist *Archivist `protobuf:"bytes,22,opt,name=archivist" json:"archivist,omitempty"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Config) GetTransport() *Transport {
	if m != nil {
		return m.Transport
	}
	return nil
}

func (m *Config) GetStorage() *Storage {
	if m != nil {
		return m.Storage
	}
	return nil
}

func (m *Config) GetCoordinator() *Coordinator {
	if m != nil {
		return m.Coordinator
	}
	return nil
}

func (m *Config) GetCollector() *Collector {
	if m != nil {
		return m.Collector
	}
	return nil
}

func (m *Config) GetArchivist() *Archivist {
	if m != nil {
		return m.Archivist
	}
	return nil
}

// Coordinator is the Coordinator service configuration.
type Coordinator struct {
	// Project is the name of the AppEngine Project that the Coordinator belongs
	// to.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	// The name of the authentication group for administrators.
	AdminAuthGroup string `protobuf:"bytes,10,opt,name=admin_auth_group" json:"admin_auth_group,omitempty"`
	// The name of the authentication group for backend services.
	ServiceAuthGroup string `protobuf:"bytes,11,opt,name=service_auth_group" json:"service_auth_group,omitempty"`
	// A list of origin URLs that are allowed to perform CORS RPC calls.
	RpcAllowOrigins []string `protobuf:"bytes,20,rep,name=rpc_allow_origins" json:"rpc_allow_origins,omitempty"`
	// The name of the archive task queue.
	ArchiveTaskQueue string `protobuf:"bytes,30,opt,name=archive_task_queue" json:"archive_task_queue,omitempty"`
	// The amount of time after a log has been terminated before it is candidate
	// for archival.
	//
	// Archival triggered by this delay will NOT succeed if any log entries are
	// missing from intermediate storage.
	//
	// This should be based on a period of time where it's reasonable to expect
	// that all log messages in the transport have arrived for a given log stream.
	// Since the transport doesn't have to guarantee in-order delivery, this
	// should allow for the case where the terminal log entry arrives before some
	// of the intermediate log entries. This will help avoid triggering
	// archive attempts that are doomed to fail because of standard transport lag.
	ArchiveDelay *google_protobuf.Duration `protobuf:"bytes,31,opt,name=archive_delay" json:"archive_delay,omitempty"`
	// The amount of time before a log stream is candidate for archival regardless
	// of whether or not it's been terminated or complete.
	//
	// This endpoint is a failsafe designed to ensure that log streams with
	// missing records or no terminal record (e.g., Butler crashed) are eventually
	// moved out of intermediate storage.
	//
	// This must be >= `archive_delay`, and should be fairly large (days) to allow
	// for the log stream to complete and for all available log entries to be
	// added to intermediate storage.
	ArchiveDelayMax *google_protobuf.Duration `protobuf:"bytes,32,opt,name=archive_delay_max" json:"archive_delay_max,omitempty"`
}

func (m *Coordinator) Reset()                    { *m = Coordinator{} }
func (m *Coordinator) String() string            { return proto.CompactTextString(m) }
func (*Coordinator) ProtoMessage()               {}
func (*Coordinator) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Coordinator) GetArchiveDelay() *google_protobuf.Duration {
	if m != nil {
		return m.ArchiveDelay
	}
	return nil
}

func (m *Coordinator) GetArchiveDelayMax() *google_protobuf.Duration {
	if m != nil {
		return m.ArchiveDelayMax
	}
	return nil
}

// Collector is the set of configuration parameters for Collector instances.
type Collector struct {
	// The maximum number of concurrent transport messages to process. If <= 0,
	// a default will be chosen based on the transport.
	MaxConcurrentMessages int32 `protobuf:"varint,1,opt,name=max_concurrent_messages" json:"max_concurrent_messages,omitempty"`
	// The maximum number of concurrent workers to process each ingested message.
	// If <= 0, collector.DefaultMaxMessageWorkers will be used.
	MaxMessageWorkers int32 `protobuf:"varint,2,opt,name=max_message_workers" json:"max_message_workers,omitempty"`
	// The maximum number of log stream states to cache locally. If <= 0, a
	// default will be used.
	StateCacheSize int32 `protobuf:"varint,3,opt,name=state_cache_size" json:"state_cache_size,omitempty"`
	// The maximum amount of time that cached stream state is valid. If <= 0, a
	// default will be used.
	StateCacheExpiration *google_protobuf.Duration `protobuf:"bytes,4,opt,name=state_cache_expiration" json:"state_cache_expiration,omitempty"`
}

func (m *Collector) Reset()                    { *m = Collector{} }
func (m *Collector) String() string            { return proto.CompactTextString(m) }
func (*Collector) ProtoMessage()               {}
func (*Collector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Collector) GetStateCacheExpiration() *google_protobuf.Duration {
	if m != nil {
		return m.StateCacheExpiration
	}
	return nil
}

// Configuration for the Archivist microservice.
type Archivist struct {
	// The number of tasks to run at a time. If blank, the archivist will choose a
	// default value.
	Tasks int32 `protobuf:"varint,1,opt,name=tasks" json:"tasks,omitempty"`
	// The name of the Google Storage bucket and optional base path to archive
	// into. For example: gs://foo/bar
	//
	// The bucket name must be included (e.g., "gs://foo"). The remainder of the
	// base path is optional based on desired archive location.
	GsBase string `protobuf:"bytes,10,opt,name=gs_base" json:"gs_base,omitempty"`
	// If not zero, the maximum number of stream indices between index entries.
	StreamIndexRange int32 `protobuf:"varint,11,opt,name=stream_index_range" json:"stream_index_range,omitempty"`
	// If not zero, the maximum number of prefix indices between index entries.
	PrefixIndexRange int32 `protobuf:"varint,12,opt,name=prefix_index_range" json:"prefix_index_range,omitempty"`
	// If not zero, the maximum number of log data bytes between index entries.
	ByteRange int32 `protobuf:"varint,13,opt,name=byte_range" json:"byte_range,omitempty"`
}

func (m *Archivist) Reset()                    { *m = Archivist{} }
func (m *Archivist) String() string            { return proto.CompactTextString(m) }
func (*Archivist) ProtoMessage()               {}
func (*Archivist) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func init() {
	proto.RegisterType((*Config)(nil), "svcconfig.Config")
	proto.RegisterType((*Coordinator)(nil), "svcconfig.Coordinator")
	proto.RegisterType((*Collector)(nil), "svcconfig.Collector")
	proto.RegisterType((*Archivist)(nil), "svcconfig.Archivist")
}

var fileDescriptor0 = []byte{
	// 455 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x92, 0xd1, 0x6e, 0xd3, 0x30,
	0x14, 0x86, 0x15, 0x46, 0x37, 0xe5, 0x64, 0xd5, 0x98, 0x19, 0xc5, 0x2b, 0xd2, 0x36, 0x95, 0x0b,
	0x90, 0x90, 0x32, 0x04, 0xdc, 0x70, 0x89, 0xca, 0x1b, 0xc0, 0xbd, 0xe5, 0x3a, 0xa7, 0xa9, 0x59,
	0x1a, 0x87, 0x63, 0xa7, 0xed, 0x78, 0x18, 0xde, 0x8a, 0x27, 0xe1, 0x05, 0xe6, 0x38, 0x49, 0x97,
	0x69, 0x17, 0xbb, 0xf4, 0xf9, 0xfe, 0xe3, 0xf3, 0xfb, 0xfc, 0x86, 0x63, 0x65, 0xca, 0xa5, 0xce,
	0xd3, 0x8a, 0x8c, 0x33, 0x2c, 0xb6, 0x1b, 0xd5, 0x16, 0xa6, 0x27, 0x8e, 0x64, 0x69, 0x2b, 0x43,
	0xae, 0x65, 0xd3, 0xb1, 0x75, 0x86, 0x64, 0x8e, 0xdd, 0xf1, 0x22, 0x37, 0x26, 0x2f, 0xf0, 0x3a,
	0x9c, 0x16, 0xf5, 0xf2, 0x3a, 0xab, 0x49, 0x3a, 0x6d, 0xca, 0x96, 0xcf, 0xfe, 0x45, 0x70, 0x38,
	0x0f, 0x57, 0xb1, 0x77, 0x10, 0xef, 0x2f, 0xe3, 0x70, 0x15, 0xbd, 0x4f, 0x3e, 0x9d, 0xa5, 0xfb,
	0x49, 0xe9, 0xcf, 0x9e, 0xb1, 0xb7, 0x70, 0xd4, 0x0d, 0xe1, 0x49, 0x90, 0xb1, 0x81, 0xec, 0x47,
	0x4b, 0xd8, 0x07, 0x48, 0x94, 0x31, 0x94, 0xe9, 0x52, 0xfa, 0x0a, 0x3f, 0x0b, 0xc2, 0xc9, 0x40,
	0x38, 0xbf, 0xa7, 0xcd, 0x68, 0x65, 0x8a, 0x02, 0x55, 0x23, 0x7d, 0xf5, 0x68, 0xf4, 0xbc, 0x67,
	0x8d, 0x50, 0x92, 0x5a, 0xe9, 0x8d, 0xb6, 0x8e, 0x4f, 0x1e, 0x09, 0xbf, 0xf5, 0x6c, 0xf6, 0x3f,
	0x82, 0x64, 0x38, 0xe1, 0x04, 0x8e, 0xfc, 0x83, 0x7f, 0xf9, 0x5b, 0x78, 0xe4, 0xdb, 0x62, 0xc6,
	0xe1, 0x85, 0xcc, 0xd6, 0xba, 0x14, 0xb2, 0x76, 0x2b, 0x91, 0x93, 0xa9, 0xab, 0xf0, 0xe8, 0x98,
	0x4d, 0x81, 0x59, 0xa4, 0x8d, 0x56, 0x38, 0x64, 0x49, 0x60, 0xe7, 0x70, 0x4a, 0x95, 0x12, 0xb2,
	0x28, 0xcc, 0x56, 0x18, 0xd2, 0xb9, 0x2e, 0xad, 0x7f, 0xdb, 0x41, 0xdb, 0xd6, 0x5a, 0x43, 0xe1,
	0xa4, 0xbd, 0x11, 0xbf, 0x6b, 0xac, 0x91, 0x5f, 0x84, 0xb6, 0x8f, 0x30, 0xee, 0x59, 0x86, 0x85,
	0xbc, 0xe5, 0x97, 0xc1, 0xfa, 0x79, 0xda, 0xa6, 0x93, 0xf6, 0xe9, 0xa4, 0xdf, 0xbb, 0x74, 0xd8,
	0x17, 0x38, 0x7d, 0xd0, 0x21, 0xd6, 0x72, 0xc7, 0xaf, 0x9e, 0xe8, 0x9a, 0xfd, 0x8d, 0x20, 0xbe,
	0x5f, 0xd6, 0x25, 0xbc, 0xf6, 0x5d, 0xc2, 0xef, 0x46, 0xd5, 0x44, 0x58, 0x3a, 0xb1, 0x46, 0x6b,
	0x7d, 0x38, 0x36, 0xec, 0x60, 0xc4, 0xde, 0xc0, 0xcb, 0x46, 0xd0, 0x55, 0xc5, 0xd6, 0xd0, 0x0d,
	0x92, 0xe5, 0xcf, 0x02, 0xf4, 0x0b, 0xb2, 0x4e, 0x3a, 0x14, 0x4a, 0xaa, 0x15, 0x0a, 0xab, 0xff,
	0x20, 0x3f, 0x08, 0xe4, 0x2b, 0x4c, 0x86, 0x04, 0x77, 0x95, 0x6e, 0xe7, 0xf3, 0xe7, 0x4f, 0x19,
	0xdc, 0x42, 0xbc, 0xcf, 0x88, 0x8d, 0x61, 0xd4, 0x6c, 0xaa, 0x77, 0xe3, 0x23, 0xca, 0xad, 0x58,
	0x48, 0x8b, 0x83, 0x20, 0x1c, 0xa1, 0x5c, 0x0b, 0x5d, 0x66, 0xb8, 0x13, 0xfe, 0x03, 0x76, 0x5f,
	0x6e, 0xd4, 0xb0, 0x8a, 0x70, 0xa9, 0x77, 0x0f, 0xd8, 0x71, 0x60, 0x0c, 0x60, 0x71, 0xeb, 0xed,
	0xb5, 0xb5, 0x71, 0x53, 0x5b, 0x1c, 0x06, 0x2f, 0x9f, 0xef, 0x02, 0x00, 0x00, 0xff, 0xff, 0x0e,
	0xbd, 0xb7, 0x0f, 0x49, 0x03, 0x00, 0x00,
}
