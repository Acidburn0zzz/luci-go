// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/common/proto/gitiles/gitiles.proto

/*
Package gitiles is a generated protocol buffer package.

It is generated from these files:
	go.chromium.org/luci/common/proto/gitiles/gitiles.proto

It has these top-level messages:
	LogRequest
	LogResponse
	RefsRequest
	RefsResponse
*/
package gitiles

import prpc "go.chromium.org/luci/grpc/prpc"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import git "go.chromium.org/luci/common/proto/git"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// LogRequest is request message for Gitiles.Log rpc.
type LogRequest struct {
	// Gitiles project, e.g. "chromium/src" part in
	// https://chromium.googlesource.com/chromium/src/+/master
	// Required.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	// The commit where to start the listing from.
	// The value can be:
	//   - a git revision as 40-char string or its prefix so long as its unique in repo.
	//   - a ref such as "refs/heads/branch" or just "branch"
	//   - a ref defined as n-th parent of R in the form "R~n".
	//     For example, "master~2" or "deadbeef~1".
	// Required.
	Treeish string `protobuf:"bytes,3,opt,name=treeish" json:"treeish,omitempty"`
	// The commit where to stop listing at. Together with treeish,
	// the represent git's "ancestor..treeish" notation.
	Ancestor string `protobuf:"bytes,2,opt,name=ancestor" json:"ancestor,omitempty"`
	// If true, include tree diff in commits.
	TreeDiff bool `protobuf:"varint,4,opt,name=tree_diff,json=treeDiff" json:"tree_diff,omitempty"`
	// Value of next_page_token in LogResponse to continue.
	PageToken string `protobuf:"bytes,10,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
	// If > 0, number of commits to retrieve.
	PageSize int32 `protobuf:"varint,11,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
}

func (m *LogRequest) Reset()                    { *m = LogRequest{} }
func (m *LogRequest) String() string            { return proto.CompactTextString(m) }
func (*LogRequest) ProtoMessage()               {}
func (*LogRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *LogRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *LogRequest) GetTreeish() string {
	if m != nil {
		return m.Treeish
	}
	return ""
}

func (m *LogRequest) GetAncestor() string {
	if m != nil {
		return m.Ancestor
	}
	return ""
}

func (m *LogRequest) GetTreeDiff() bool {
	if m != nil {
		return m.TreeDiff
	}
	return false
}

func (m *LogRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *LogRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// LogRequest is response message for Gitiles.Log rpc.
type LogResponse struct {
	// Retrieved commits.
	Log []*git.Commit `protobuf:"bytes,1,rep,name=log" json:"log,omitempty"`
	// A page token for next LogRequest to fetch next page of commits.
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken" json:"next_page_token,omitempty"`
}

func (m *LogResponse) Reset()                    { *m = LogResponse{} }
func (m *LogResponse) String() string            { return proto.CompactTextString(m) }
func (*LogResponse) ProtoMessage()               {}
func (*LogResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *LogResponse) GetLog() []*git.Commit {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *LogResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// RefsRequest is a request message of Gitiles.Refs RPC.
type RefsRequest struct {
	// Gitiles project, e.g. "chromium/src" part in
	// https://chromium.googlesource.com/chromium/src/+/master
	// Required.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	// Limits which refs to resolve to only those matching {refsPath}/*.
	//
	// Must be "refs" or start with "refs/".
	// Must not include glob '*'.
	// Use "refs/heads" to retrieve all branches.
	//
	// To fetch **all** refs in a repo, specify just "refs" but beware of two
	// caveats:
	//  * refs returned include a ref for each patchset for each Gerrit change
	//    associated with the repo.
	//  * returned map will contain special "HEAD" ref whose value in resulting map
	//    will be name of the actual ref to which "HEAD" points, which is typically
	//    "refs/heads/master".
	//
	// Thus, if you are looking for all tags and all branches of repo, it's
	// recommended to issue two Refs calls limited to "refs/tags" and "refs/heads"
	// instead of one call for "refs".
	//
	// Since Gerrit allows per-ref ACLs, it is possible that some refs matching
	// refPrefix would not be present in results because current user isn't granted
	// read permission on them.
	RefsPath string `protobuf:"bytes,2,opt,name=refs_path,json=refsPath" json:"refs_path,omitempty"`
}

func (m *RefsRequest) Reset()                    { *m = RefsRequest{} }
func (m *RefsRequest) String() string            { return proto.CompactTextString(m) }
func (*RefsRequest) ProtoMessage()               {}
func (*RefsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *RefsRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *RefsRequest) GetRefsPath() string {
	if m != nil {
		return m.RefsPath
	}
	return ""
}

// RefsResponse is a response message of Gitiles.Refs RPC.
type RefsResponse struct {
	// revisions maps a ref to a revision.
	// Git branches have keys start with "refs/heads/".
	Revisions map[string]string `protobuf:"bytes,2,rep,name=revisions" json:"revisions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RefsResponse) Reset()                    { *m = RefsResponse{} }
func (m *RefsResponse) String() string            { return proto.CompactTextString(m) }
func (*RefsResponse) ProtoMessage()               {}
func (*RefsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *RefsResponse) GetRevisions() map[string]string {
	if m != nil {
		return m.Revisions
	}
	return nil
}

func init() {
	proto.RegisterType((*LogRequest)(nil), "gitiles.LogRequest")
	proto.RegisterType((*LogResponse)(nil), "gitiles.LogResponse")
	proto.RegisterType((*RefsRequest)(nil), "gitiles.RefsRequest")
	proto.RegisterType((*RefsResponse)(nil), "gitiles.RefsResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Gitiles service

type GitilesClient interface {
	// Log retrieves commit log.
	Log(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// Refs retrieves repo refs.
	Refs(ctx context.Context, in *RefsRequest, opts ...grpc.CallOption) (*RefsResponse, error)
}
type gitilesPRPCClient struct {
	client *prpc.Client
}

func NewGitilesPRPCClient(client *prpc.Client) GitilesClient {
	return &gitilesPRPCClient{client}
}

func (c *gitilesPRPCClient) Log(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.client.Call(ctx, "gitiles.Gitiles", "Log", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitilesPRPCClient) Refs(ctx context.Context, in *RefsRequest, opts ...grpc.CallOption) (*RefsResponse, error) {
	out := new(RefsResponse)
	err := c.client.Call(ctx, "gitiles.Gitiles", "Refs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type gitilesClient struct {
	cc *grpc.ClientConn
}

func NewGitilesClient(cc *grpc.ClientConn) GitilesClient {
	return &gitilesClient{cc}
}

func (c *gitilesClient) Log(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := grpc.Invoke(ctx, "/gitiles.Gitiles/Log", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gitilesClient) Refs(ctx context.Context, in *RefsRequest, opts ...grpc.CallOption) (*RefsResponse, error) {
	out := new(RefsResponse)
	err := grpc.Invoke(ctx, "/gitiles.Gitiles/Refs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Gitiles service

type GitilesServer interface {
	// Log retrieves commit log.
	Log(context.Context, *LogRequest) (*LogResponse, error)
	// Refs retrieves repo refs.
	Refs(context.Context, *RefsRequest) (*RefsResponse, error)
}

func RegisterGitilesServer(s prpc.Registrar, srv GitilesServer) {
	s.RegisterService(&_Gitiles_serviceDesc, srv)
}

func _Gitiles_Log_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitilesServer).Log(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitiles.Gitiles/Log",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitilesServer).Log(ctx, req.(*LogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gitiles_Refs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GitilesServer).Refs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitiles.Gitiles/Refs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GitilesServer).Refs(ctx, req.(*RefsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Gitiles_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gitiles.Gitiles",
	HandlerType: (*GitilesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Log",
			Handler:    _Gitiles_Log_Handler,
		},
		{
			MethodName: "Refs",
			Handler:    _Gitiles_Refs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/common/proto/gitiles/gitiles.proto",
}

func init() {
	proto.RegisterFile("go.chromium.org/luci/common/proto/gitiles/gitiles.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 410 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0xcd, 0x6e, 0xd4, 0x30,
	0x10, 0x80, 0xeb, 0x4d, 0xcb, 0xee, 0x4e, 0xf8, 0x93, 0x59, 0x24, 0x6b, 0xab, 0x4a, 0xab, 0x08,
	0xa1, 0x3d, 0x65, 0xa5, 0x20, 0x04, 0x42, 0x9c, 0xa0, 0x88, 0x4b, 0x0f, 0x95, 0xe9, 0x3d, 0x0a,
	0x61, 0xe2, 0x98, 0x26, 0x71, 0xb0, 0x9d, 0x8a, 0xf6, 0x29, 0x78, 0x19, 0xde, 0x0f, 0xd9, 0x4e,
	0xfa, 0x83, 0x90, 0xe8, 0x29, 0x99, 0x6f, 0x66, 0x3c, 0xdf, 0xc4, 0x81, 0x37, 0x42, 0xa5, 0x65,
	0xad, 0x55, 0x2b, 0x87, 0x36, 0x55, 0x5a, 0xec, 0x9a, 0xa1, 0x94, 0xbb, 0x52, 0xb5, 0xad, 0xea,
	0x76, 0xbd, 0x56, 0x56, 0xed, 0x84, 0xb4, 0xb2, 0x41, 0x33, 0x3d, 0x53, 0x4f, 0xe9, 0x7c, 0x0c,
	0xd7, 0xd9, 0xbd, 0x4e, 0xf0, 0x40, 0xda, 0xd0, 0x9c, 0xfc, 0x26, 0x00, 0x27, 0x4a, 0x70, 0xfc,
	0x31, 0xa0, 0xb1, 0x94, 0xc1, 0xbc, 0xd7, 0xea, 0x3b, 0x96, 0x96, 0x91, 0x0d, 0xd9, 0x2e, 0xf9,
	0x14, 0xba, 0x8c, 0xd5, 0x88, 0xd2, 0xd4, 0x2c, 0x0a, 0x99, 0x31, 0xa4, 0x6b, 0x58, 0x14, 0x5d,
	0x89, 0xc6, 0x2a, 0xcd, 0x66, 0x3e, 0x75, 0x1d, 0xd3, 0x43, 0x58, 0xba, 0xb2, 0xfc, 0x9b, 0xac,
	0x2a, 0xb6, 0xbf, 0x21, 0xdb, 0x05, 0x5f, 0x38, 0x70, 0x2c, 0xab, 0x8a, 0x1e, 0x01, 0xf4, 0x85,
	0xc0, 0xdc, 0xaa, 0x73, 0xec, 0x18, 0xf8, 0xd6, 0xa5, 0x23, 0x67, 0x0e, 0xb8, 0x5e, 0x9f, 0x36,
	0xf2, 0x0a, 0x59, 0xbc, 0x21, 0xdb, 0x03, 0xbe, 0x70, 0xe0, 0x8b, 0xbc, 0xc2, 0xe4, 0x0c, 0x62,
	0xaf, 0x6d, 0x7a, 0xd5, 0x19, 0xa4, 0x47, 0x10, 0x35, 0x4a, 0x30, 0xb2, 0x89, 0xb6, 0x71, 0x16,
	0xa7, 0x42, 0xda, 0xf4, 0xa3, 0x5f, 0x93, 0x3b, 0x4e, 0x5f, 0xc2, 0x93, 0x0e, 0x7f, 0xda, 0xfc,
	0xd6, 0xb8, 0x60, 0xfa, 0xc8, 0xe1, 0xd3, 0x69, 0x64, 0x72, 0x0c, 0x31, 0xc7, 0xca, 0xfc, 0xff,
	0x6b, 0x1c, 0xc2, 0x52, 0x63, 0x65, 0xf2, 0xbe, 0xb0, 0xf5, 0xb4, 0xb4, 0x03, 0xa7, 0x85, 0xad,
	0x93, 0x5f, 0x04, 0x1e, 0x86, 0x63, 0x46, 0xbb, 0x0f, 0xae, 0xfa, 0x42, 0x1a, 0xa9, 0x3a, 0xc3,
	0x66, 0xde, 0xf1, 0x45, 0x3a, 0x5d, 0xe2, 0xed, 0xca, 0x94, 0x4f, 0x65, 0x9f, 0x3a, 0xab, 0x2f,
	0xf9, 0x4d, 0xdb, 0xfa, 0x3d, 0x3c, 0xbe, 0x9b, 0xa4, 0x4f, 0x21, 0x3a, 0xc7, 0xcb, 0xd1, 0xcc,
	0xbd, 0xd2, 0x15, 0x1c, 0x5c, 0x14, 0xcd, 0x80, 0xa3, 0x51, 0x08, 0xde, 0xcd, 0xde, 0x92, 0xcc,
	0xc2, 0xfc, 0x73, 0x98, 0x47, 0x33, 0x88, 0x4e, 0x94, 0xa0, 0xcf, 0xae, 0x05, 0x6e, 0xae, 0x7f,
	0xbd, 0xba, 0x0b, 0x83, 0x54, 0xb2, 0x47, 0x5f, 0xc3, 0xbe, 0xd3, 0xa4, 0xab, 0xbf, 0xac, 0x43,
	0xd7, 0xf3, 0x7f, 0xee, 0x92, 0xec, 0x7d, 0x7d, 0xe0, 0xff, 0xb1, 0x57, 0x7f, 0x02, 0x00, 0x00,
	0xff, 0xff, 0x2f, 0x52, 0xc6, 0x1d, 0xdb, 0x02, 0x00, 0x00,
}
