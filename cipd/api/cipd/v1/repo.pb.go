// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/cipd/api/cipd/v1/repo.proto

package api

import prpc "go.chromium.org/luci/grpc/prpc"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Roles used in package prefix ACLs.
//
// A user can have one or more such roles for a package prefix. They get
// inherited by all subprefixes.
type Role int32

const (
	Role_ROLE_UNSPECIFIED Role = 0
	// Readers can fetch package instances and package metadata (e.g. list of
	// instances, all tags, all refs), but not prefix metadata (e.g. ACLs).
	Role_READER Role = 1
	// Writers can do everything that readers can, plus create new packages,
	// upload package instances, attach tags, move refs.
	Role_WRITER Role = 2
	// Owners can do everything that writers can, plus read prefix metadata for
	// all parent prefixes and all subprefixes, and modify prefix metadata for
	// all subprefixes.
	Role_OWNER Role = 3
)

var Role_name = map[int32]string{
	0: "ROLE_UNSPECIFIED",
	1: "READER",
	2: "WRITER",
	3: "OWNER",
}
var Role_value = map[string]int32{
	"ROLE_UNSPECIFIED": 0,
	"READER":           1,
	"WRITER":           2,
	"OWNER":            3,
}

func (x Role) String() string {
	return proto.EnumName(Role_name, int32(x))
}
func (Role) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

// RegistrationStatus is part of RegisterInstance RPC response.
type RegistrationStatus int32

const (
	RegistrationStatus_REGISTRATION_STATUS_UNSPECIFIED RegistrationStatus = 0
	RegistrationStatus_REGISTERED                      RegistrationStatus = 1
	RegistrationStatus_ALREADY_REGISTERED              RegistrationStatus = 2
	RegistrationStatus_NOT_UPLOADED                    RegistrationStatus = 3
)

var RegistrationStatus_name = map[int32]string{
	0: "REGISTRATION_STATUS_UNSPECIFIED",
	1: "REGISTERED",
	2: "ALREADY_REGISTERED",
	3: "NOT_UPLOADED",
}
var RegistrationStatus_value = map[string]int32{
	"REGISTRATION_STATUS_UNSPECIFIED": 0,
	"REGISTERED":                      1,
	"ALREADY_REGISTERED":              2,
	"NOT_UPLOADED":                    3,
}

func (x RegistrationStatus) String() string {
	return proto.EnumName(RegistrationStatus_name, int32(x))
}
func (RegistrationStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

type PrefixRequest struct {
	// A prefix within the repository, e.g. "a/b/c".
	Prefix string `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
}

func (m *PrefixRequest) Reset()                    { *m = PrefixRequest{} }
func (m *PrefixRequest) String() string            { return proto.CompactTextString(m) }
func (*PrefixRequest) ProtoMessage()               {}
func (*PrefixRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *PrefixRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

// PrefixMetadata is metadata defined at some concrete package prefix.
//
// It applies to this prefix and all subprefixes, recursively.
type PrefixMetadata struct {
	// Prefix this metadata is defined at, e.g. "a/b/c".
	//
	// Note: there's no metadata at the root, so prefix must never be "".
	Prefix string `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	// An opaque string that identifies a particular version of this metadata.
	//
	// Used by UpdatePrefixMetadata to prevent an accidental overwrite of changes.
	Fingerprint string `protobuf:"bytes,2,opt,name=fingerprint" json:"fingerprint,omitempty"`
	// When the metadata was modified the last time.
	//
	// Managed by the server, ignored when passed to UpdatePrefixMetadata.
	UpdateTime *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=update_time,json=updateTime" json:"update_time,omitempty"`
	// Identity string of whoever modified the metadata the last time.
	//
	// Managed by the server, ignored when passed to UpdatePrefixMetadata.
	UpdateUser string `protobuf:"bytes,4,opt,name=update_user,json=updateUser" json:"update_user,omitempty"`
	// ACLs that apply to this prefix and all subprefixes, as a mapping from
	// a role to a list of users and groups that have it.
	Acls []*PrefixMetadata_ACL `protobuf:"bytes,5,rep,name=acls" json:"acls,omitempty"`
}

func (m *PrefixMetadata) Reset()                    { *m = PrefixMetadata{} }
func (m *PrefixMetadata) String() string            { return proto.CompactTextString(m) }
func (*PrefixMetadata) ProtoMessage()               {}
func (*PrefixMetadata) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *PrefixMetadata) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *PrefixMetadata) GetFingerprint() string {
	if m != nil {
		return m.Fingerprint
	}
	return ""
}

func (m *PrefixMetadata) GetUpdateTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

func (m *PrefixMetadata) GetUpdateUser() string {
	if m != nil {
		return m.UpdateUser
	}
	return ""
}

func (m *PrefixMetadata) GetAcls() []*PrefixMetadata_ACL {
	if m != nil {
		return m.Acls
	}
	return nil
}

type PrefixMetadata_ACL struct {
	// Role that this ACL describes.
	Role Role `protobuf:"varint,1,opt,name=role,enum=cipd.Role" json:"role,omitempty"`
	// Users and groups that have the specified role.
	//
	// Each entry has a form "<kind>:<value>", e.g "group:..." or "user:...".
	Principals []string `protobuf:"bytes,2,rep,name=principals" json:"principals,omitempty"`
}

func (m *PrefixMetadata_ACL) Reset()                    { *m = PrefixMetadata_ACL{} }
func (m *PrefixMetadata_ACL) String() string            { return proto.CompactTextString(m) }
func (*PrefixMetadata_ACL) ProtoMessage()               {}
func (*PrefixMetadata_ACL) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1, 0} }

func (m *PrefixMetadata_ACL) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return Role_ROLE_UNSPECIFIED
}

func (m *PrefixMetadata_ACL) GetPrincipals() []string {
	if m != nil {
		return m.Principals
	}
	return nil
}

type InheritedPrefixMetadata struct {
	// Per-prefix metadata that applies to a prefix, ordered by prefix length.
	//
	// For example, when requesting metadata for prefix "a/b/c/d" the reply may
	// contain entries for "a", "a/b", "a/b/c/d" (in that order, with "a/b/c"
	// skipped in this example as not having any metadata attached).
	PerPrefixMetadata []*PrefixMetadata `protobuf:"bytes,1,rep,name=per_prefix_metadata,json=perPrefixMetadata" json:"per_prefix_metadata,omitempty"`
}

func (m *InheritedPrefixMetadata) Reset()                    { *m = InheritedPrefixMetadata{} }
func (m *InheritedPrefixMetadata) String() string            { return proto.CompactTextString(m) }
func (*InheritedPrefixMetadata) ProtoMessage()               {}
func (*InheritedPrefixMetadata) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *InheritedPrefixMetadata) GetPerPrefixMetadata() []*PrefixMetadata {
	if m != nil {
		return m.PerPrefixMetadata
	}
	return nil
}

// Instance is a pointer to an instance of some package.
type Instance struct {
	// A name of the package, e.g. "a/b/c/d".
	Package string `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
	// A reference to the instance file in the storage.
	Instance *ObjectRef `protobuf:"bytes,2,opt,name=instance" json:"instance,omitempty"`
	// User who registered the instance (output only).
	RegisteredBy string `protobuf:"bytes,3,opt,name=registered_by,json=registeredBy" json:"registered_by,omitempty"`
	// When the instance was registered (output only).
	RegisteredTs *google_protobuf.Timestamp `protobuf:"bytes,4,opt,name=registered_ts,json=registeredTs" json:"registered_ts,omitempty"`
}

func (m *Instance) Reset()                    { *m = Instance{} }
func (m *Instance) String() string            { return proto.CompactTextString(m) }
func (*Instance) ProtoMessage()               {}
func (*Instance) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *Instance) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *Instance) GetInstance() *ObjectRef {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *Instance) GetRegisteredBy() string {
	if m != nil {
		return m.RegisteredBy
	}
	return ""
}

func (m *Instance) GetRegisteredTs() *google_protobuf.Timestamp {
	if m != nil {
		return m.RegisteredTs
	}
	return nil
}

// RegisterInstanceResponse is returned by RegisterInstance RPC.
type RegisterInstanceResponse struct {
	// Outcome of the operation, see the enum for possibilities.
	//
	// Defines what other fields are present.
	Status RegistrationStatus `protobuf:"varint,1,opt,name=status,enum=cipd.RegistrationStatus" json:"status,omitempty"`
	// For statuses REGISTERED and ALREADY_REGISTERED contains details about the
	// instance. Not set for NOT_UPLOADED status.
	Instance *Instance `protobuf:"bytes,2,opt,name=instance" json:"instance,omitempty"`
	// For status NOT_UPLOADED contains a new upload operation that can be used
	// together with Storage service to upload the instance file. Not set for
	// other statuses.
	UploadOp *UploadOperation `protobuf:"bytes,3,opt,name=upload_op,json=uploadOp" json:"upload_op,omitempty"`
}

func (m *RegisterInstanceResponse) Reset()                    { *m = RegisterInstanceResponse{} }
func (m *RegisterInstanceResponse) String() string            { return proto.CompactTextString(m) }
func (*RegisterInstanceResponse) ProtoMessage()               {}
func (*RegisterInstanceResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *RegisterInstanceResponse) GetStatus() RegistrationStatus {
	if m != nil {
		return m.Status
	}
	return RegistrationStatus_REGISTRATION_STATUS_UNSPECIFIED
}

func (m *RegisterInstanceResponse) GetInstance() *Instance {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *RegisterInstanceResponse) GetUploadOp() *UploadOperation {
	if m != nil {
		return m.UploadOp
	}
	return nil
}

func init() {
	proto.RegisterType((*PrefixRequest)(nil), "cipd.PrefixRequest")
	proto.RegisterType((*PrefixMetadata)(nil), "cipd.PrefixMetadata")
	proto.RegisterType((*PrefixMetadata_ACL)(nil), "cipd.PrefixMetadata.ACL")
	proto.RegisterType((*InheritedPrefixMetadata)(nil), "cipd.InheritedPrefixMetadata")
	proto.RegisterType((*Instance)(nil), "cipd.Instance")
	proto.RegisterType((*RegisterInstanceResponse)(nil), "cipd.RegisterInstanceResponse")
	proto.RegisterEnum("cipd.Role", Role_name, Role_value)
	proto.RegisterEnum("cipd.RegistrationStatus", RegistrationStatus_name, RegistrationStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Repository service

type RepositoryClient interface {
	// Returns metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// If the caller has OWNER permission in any of parent prefixes, but the
	// requested prefix has no metadata associated with it, the call fails with
	// NOT_FOUND error.
	GetPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*PrefixMetadata, error)
	// Returns metadata associated with the given prefix and all parent prefixes.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// Note that if the caller has permission to see the metadata for the
	// requested prefix, they will also see metadata for all parent prefixes,
	// since it is needed to assemble the final metadata for the prefix (it
	// includes inherited properties from all parent prefixes).
	GetInheritedPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*InheritedPrefixMetadata, error)
	// Updates or creates metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// This method checks 'fingerprint' field of the PrefixMetadata object. If the
	// metadata for the given prefix already exists, and the fingerprint in the
	// request doesn't match the current fingerprint, the request fails with
	// FAILED_PRECONDITION error.
	//
	// If the metadata doesn't exist yet, its fingerprint is assumed to be empty
	// string. So pass empty fingerprint when creating initial metadata objects.
	//
	// If the caller passes empty fingerprint, but the metadata already exists,
	// the request fails with ALREADY_EXISTS error.
	//
	// Note that there's no way to delete metadata once it was created. Passing
	// empty PrefixMetadata object is the best that can be done.
	//
	// On success returns PrefixMetadata object with the updated fingerprint.
	UpdatePrefixMetadata(ctx context.Context, in *PrefixMetadata, opts ...grpc.CallOption) (*PrefixMetadata, error)
	// Registers a package instance in the repository (if it was uploaded to the
	// storage already and wasn't registered yet) or initiates a new upload
	// operation.
	//
	// Callers are expected to execute the following protocol:
	//   1. Attempt to register a package instance by calling RegisterInstance.
	//   2. On NOT_UPLOADED status, upload the package data and finalize the
	//      upload operation using Storage RPC service and upload_op from the
	//      response.
	//   3. Once the upload operation is finalized, call RegisterInstance again,
	//      it should succeed with status REGISTERED now.
	//
	// If such instance is already registered by someone else, returns
	// ALREADY_REGISTERED status. This is not an error.
	//
	// Callers must have roles WRITER or OWNER for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	RegisterInstance(ctx context.Context, in *Instance, opts ...grpc.CallOption) (*RegisterInstanceResponse, error)
}
type repositoryPRPCClient struct {
	client *prpc.Client
}

func NewRepositoryPRPCClient(client *prpc.Client) RepositoryClient {
	return &repositoryPRPCClient{client}
}

func (c *repositoryPRPCClient) GetPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*PrefixMetadata, error) {
	out := new(PrefixMetadata)
	err := c.client.Call(ctx, "cipd.Repository", "GetPrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) GetInheritedPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*InheritedPrefixMetadata, error) {
	out := new(InheritedPrefixMetadata)
	err := c.client.Call(ctx, "cipd.Repository", "GetInheritedPrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) UpdatePrefixMetadata(ctx context.Context, in *PrefixMetadata, opts ...grpc.CallOption) (*PrefixMetadata, error) {
	out := new(PrefixMetadata)
	err := c.client.Call(ctx, "cipd.Repository", "UpdatePrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) RegisterInstance(ctx context.Context, in *Instance, opts ...grpc.CallOption) (*RegisterInstanceResponse, error) {
	out := new(RegisterInstanceResponse)
	err := c.client.Call(ctx, "cipd.Repository", "RegisterInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type repositoryClient struct {
	cc *grpc.ClientConn
}

func NewRepositoryClient(cc *grpc.ClientConn) RepositoryClient {
	return &repositoryClient{cc}
}

func (c *repositoryClient) GetPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*PrefixMetadata, error) {
	out := new(PrefixMetadata)
	err := grpc.Invoke(ctx, "/cipd.Repository/GetPrefixMetadata", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) GetInheritedPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*InheritedPrefixMetadata, error) {
	out := new(InheritedPrefixMetadata)
	err := grpc.Invoke(ctx, "/cipd.Repository/GetInheritedPrefixMetadata", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) UpdatePrefixMetadata(ctx context.Context, in *PrefixMetadata, opts ...grpc.CallOption) (*PrefixMetadata, error) {
	out := new(PrefixMetadata)
	err := grpc.Invoke(ctx, "/cipd.Repository/UpdatePrefixMetadata", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) RegisterInstance(ctx context.Context, in *Instance, opts ...grpc.CallOption) (*RegisterInstanceResponse, error) {
	out := new(RegisterInstanceResponse)
	err := grpc.Invoke(ctx, "/cipd.Repository/RegisterInstance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Repository service

type RepositoryServer interface {
	// Returns metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// If the caller has OWNER permission in any of parent prefixes, but the
	// requested prefix has no metadata associated with it, the call fails with
	// NOT_FOUND error.
	GetPrefixMetadata(context.Context, *PrefixRequest) (*PrefixMetadata, error)
	// Returns metadata associated with the given prefix and all parent prefixes.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// Note that if the caller has permission to see the metadata for the
	// requested prefix, they will also see metadata for all parent prefixes,
	// since it is needed to assemble the final metadata for the prefix (it
	// includes inherited properties from all parent prefixes).
	GetInheritedPrefixMetadata(context.Context, *PrefixRequest) (*InheritedPrefixMetadata, error)
	// Updates or creates metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// This method checks 'fingerprint' field of the PrefixMetadata object. If the
	// metadata for the given prefix already exists, and the fingerprint in the
	// request doesn't match the current fingerprint, the request fails with
	// FAILED_PRECONDITION error.
	//
	// If the metadata doesn't exist yet, its fingerprint is assumed to be empty
	// string. So pass empty fingerprint when creating initial metadata objects.
	//
	// If the caller passes empty fingerprint, but the metadata already exists,
	// the request fails with ALREADY_EXISTS error.
	//
	// Note that there's no way to delete metadata once it was created. Passing
	// empty PrefixMetadata object is the best that can be done.
	//
	// On success returns PrefixMetadata object with the updated fingerprint.
	UpdatePrefixMetadata(context.Context, *PrefixMetadata) (*PrefixMetadata, error)
	// Registers a package instance in the repository (if it was uploaded to the
	// storage already and wasn't registered yet) or initiates a new upload
	// operation.
	//
	// Callers are expected to execute the following protocol:
	//   1. Attempt to register a package instance by calling RegisterInstance.
	//   2. On NOT_UPLOADED status, upload the package data and finalize the
	//      upload operation using Storage RPC service and upload_op from the
	//      response.
	//   3. Once the upload operation is finalized, call RegisterInstance again,
	//      it should succeed with status REGISTERED now.
	//
	// If such instance is already registered by someone else, returns
	// ALREADY_REGISTERED status. This is not an error.
	//
	// Callers must have roles WRITER or OWNER for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	RegisterInstance(context.Context, *Instance) (*RegisterInstanceResponse, error)
}

func RegisterRepositoryServer(s prpc.Registrar, srv RepositoryServer) {
	s.RegisterService(&_Repository_serviceDesc, srv)
}

func _Repository_GetPrefixMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).GetPrefixMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/GetPrefixMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).GetPrefixMetadata(ctx, req.(*PrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_GetInheritedPrefixMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).GetInheritedPrefixMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/GetInheritedPrefixMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).GetInheritedPrefixMetadata(ctx, req.(*PrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_UpdatePrefixMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).UpdatePrefixMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/UpdatePrefixMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).UpdatePrefixMetadata(ctx, req.(*PrefixMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_RegisterInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Instance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).RegisterInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/RegisterInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).RegisterInstance(ctx, req.(*Instance))
	}
	return interceptor(ctx, in, info, handler)
}

var _Repository_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cipd.Repository",
	HandlerType: (*RepositoryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPrefixMetadata",
			Handler:    _Repository_GetPrefixMetadata_Handler,
		},
		{
			MethodName: "GetInheritedPrefixMetadata",
			Handler:    _Repository_GetInheritedPrefixMetadata_Handler,
		},
		{
			MethodName: "UpdatePrefixMetadata",
			Handler:    _Repository_UpdatePrefixMetadata_Handler,
		},
		{
			MethodName: "RegisterInstance",
			Handler:    _Repository_RegisterInstance_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/cipd/api/cipd/v1/repo.proto",
}

func init() { proto.RegisterFile("go.chromium.org/luci/cipd/api/cipd/v1/repo.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 692 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0x4d, 0x6f, 0x1a, 0x3b,
	0x14, 0x7d, 0x03, 0x84, 0x17, 0x2e, 0x09, 0x6f, 0xe2, 0xe4, 0xe5, 0x8d, 0x90, 0x5e, 0x82, 0xc8,
	0xa2, 0x51, 0x5a, 0x0d, 0x29, 0x5d, 0x56, 0x6a, 0x04, 0x61, 0x1a, 0x21, 0x51, 0x40, 0x66, 0x50,
	0xd4, 0x6e, 0x46, 0x66, 0xb8, 0x90, 0x69, 0x01, 0xbb, 0xb6, 0xa7, 0x6a, 0x7e, 0x4c, 0xb7, 0x5d,
	0x75, 0xdf, 0xbf, 0x57, 0xcd, 0x07, 0x09, 0x21, 0xa4, 0xea, 0xce, 0x3e, 0x3e, 0xf7, 0xe3, 0xdc,
	0x7b, 0x0c, 0xe7, 0x53, 0x6e, 0xfb, 0x37, 0x92, 0xcf, 0x83, 0x70, 0x6e, 0x73, 0x39, 0xad, 0xcd,
	0x42, 0x3f, 0xa8, 0xf9, 0x81, 0x18, 0xd7, 0x98, 0x48, 0x0f, 0x5f, 0x5e, 0xd6, 0x24, 0x0a, 0x6e,
	0x0b, 0xc9, 0x35, 0x27, 0xb9, 0x08, 0x2b, 0x1f, 0x4f, 0x39, 0x9f, 0xce, 0xb0, 0x16, 0x63, 0xa3,
	0x70, 0x52, 0xd3, 0xc1, 0x1c, 0x95, 0x66, 0x73, 0x91, 0xd0, 0xca, 0xb5, 0x3f, 0x4b, 0xec, 0x33,
	0x95, 0x04, 0x54, 0x9f, 0xc1, 0x6e, 0x5f, 0xe2, 0x24, 0xf8, 0x4a, 0xf1, 0x73, 0x88, 0x4a, 0x93,
	0x43, 0xc8, 0x8b, 0x18, 0xb0, 0x8c, 0x8a, 0x71, 0x5a, 0xa0, 0xe9, 0xad, 0xfa, 0x2d, 0x03, 0xa5,
	0x84, 0xf9, 0x0e, 0x35, 0x1b, 0x33, 0xcd, 0x9e, 0xa2, 0x92, 0x0a, 0x14, 0x27, 0xc1, 0x62, 0x8a,
	0x52, 0xc8, 0x60, 0xa1, 0xad, 0x4c, 0xfc, 0xb8, 0x0a, 0x91, 0xd7, 0x50, 0x0c, 0xc5, 0x98, 0x69,
	0xf4, 0x22, 0x01, 0x56, 0xb6, 0x62, 0x9c, 0x16, 0xeb, 0x65, 0x3b, 0x51, 0x67, 0x2f, 0xd5, 0xd9,
	0xee, 0x52, 0x1d, 0x85, 0x84, 0x1e, 0x01, 0xe4, 0xf8, 0x2e, 0x38, 0x54, 0x28, 0xad, 0x5c, 0x9c,
	0x3e, 0x25, 0x0c, 0x15, 0x4a, 0xf2, 0x02, 0x72, 0xcc, 0x9f, 0x29, 0x6b, 0xab, 0x92, 0x3d, 0x2d,
	0xd6, 0x2d, 0x3b, 0x52, 0x6d, 0x3f, 0xec, 0xdd, 0x6e, 0x5c, 0x76, 0x68, 0xcc, 0x2a, 0x3b, 0x90,
	0x6d, 0x5c, 0x76, 0xc8, 0x11, 0xe4, 0x24, 0x9f, 0x61, 0x2c, 0xa5, 0x54, 0x87, 0x24, 0x88, 0xf2,
	0x19, 0xd2, 0x18, 0x27, 0x47, 0x00, 0x51, 0xef, 0x7e, 0x20, 0xd8, 0x4c, 0x59, 0x99, 0x4a, 0x36,
	0x2a, 0x7a, 0x8f, 0x54, 0x3d, 0xf8, 0xaf, 0xbd, 0xb8, 0x41, 0x19, 0x68, 0x1c, 0xaf, 0xcd, 0xa9,
	0x05, 0xfb, 0x02, 0xa5, 0x97, 0x4c, 0xc7, 0x9b, 0xa7, 0xb0, 0x65, 0xc4, 0xed, 0x1d, 0x6c, 0x6a,
	0x8f, 0xee, 0x09, 0x94, 0x0f, 0xa1, 0xea, 0x4f, 0x03, 0xb6, 0xdb, 0x0b, 0xa5, 0xd9, 0xc2, 0x47,
	0x62, 0xc1, 0xdf, 0x82, 0xf9, 0x9f, 0xd8, 0x14, 0xd3, 0xd9, 0x2f, 0xaf, 0xe4, 0x39, 0x6c, 0x07,
	0x29, 0x2b, 0x9e, 0x7c, 0xb1, 0xfe, 0x4f, 0x52, 0xa1, 0x37, 0xfa, 0x88, 0xbe, 0xa6, 0x38, 0xa1,
	0x77, 0x04, 0x72, 0x02, 0xbb, 0x12, 0xa7, 0x81, 0xd2, 0x28, 0x71, 0xec, 0x8d, 0x6e, 0xe3, 0x4d,
	0x14, 0xe8, 0xce, 0x3d, 0xd8, 0xbc, 0x25, 0x17, 0x0f, 0x48, 0x5a, 0xc5, 0x13, 0xff, 0xfd, 0xba,
	0x56, 0x12, 0xb8, 0xaa, 0xfa, 0xc3, 0x00, 0x8b, 0xa6, 0xc0, 0x52, 0x01, 0x45, 0x25, 0xf8, 0x42,
	0x21, 0x39, 0x87, 0xbc, 0xd2, 0x4c, 0x87, 0x2a, 0x9d, 0x7c, 0xba, 0xae, 0x84, 0x2f, 0x99, 0x0e,
	0xf8, 0x62, 0x10, 0xbf, 0xd3, 0x94, 0x47, 0xce, 0x1e, 0x29, 0x2c, 0x25, 0x31, 0x77, 0xb9, 0xef,
	0x05, 0xd6, 0xa1, 0x10, 0x8a, 0x19, 0x67, 0x63, 0x8f, 0x8b, 0xd4, 0x66, 0xff, 0x26, 0xe4, 0x61,
	0x0c, 0xf7, 0x04, 0x26, 0x35, 0xe8, 0x76, 0x98, 0x02, 0x67, 0x17, 0x90, 0x8b, 0xf6, 0x4e, 0x0e,
	0xc0, 0xa4, 0xbd, 0x8e, 0xe3, 0x0d, 0xbb, 0x83, 0xbe, 0x73, 0xd9, 0x7e, 0xdb, 0x76, 0x5a, 0xe6,
	0x5f, 0x04, 0x20, 0x4f, 0x9d, 0x46, 0xcb, 0xa1, 0xa6, 0x11, 0x9d, 0xaf, 0x69, 0xdb, 0x75, 0xa8,
	0x99, 0x21, 0x05, 0xd8, 0xea, 0x5d, 0x77, 0x1d, 0x6a, 0x66, 0xcf, 0x14, 0x90, 0xc7, 0xed, 0x93,
	0x13, 0x38, 0xa6, 0xce, 0x55, 0x7b, 0xe0, 0xd2, 0x86, 0xdb, 0xee, 0x75, 0xbd, 0x81, 0xdb, 0x70,
	0x87, 0x83, 0xb5, 0xec, 0x25, 0x80, 0x84, 0xe4, 0x50, 0xa7, 0x65, 0x1a, 0xe4, 0x10, 0x48, 0xa3,
	0x13, 0xd5, 0x7b, 0xef, 0xad, 0xe0, 0x19, 0x62, 0xc2, 0x4e, 0xb7, 0xe7, 0x7a, 0xc3, 0x7e, 0xa7,
	0xd7, 0x68, 0x39, 0x2d, 0x33, 0x5b, 0xff, 0x9e, 0x01, 0xa0, 0x28, 0xb8, 0x0a, 0x34, 0x97, 0xb7,
	0xe4, 0x0d, 0xec, 0x5d, 0xa1, 0x5e, 0x33, 0xe2, 0xfe, 0xaa, 0xd7, 0xd2, 0x0f, 0x5f, 0xde, 0x68,
	0x40, 0xd2, 0x87, 0xf2, 0x15, 0xea, 0xa7, 0x1c, 0xbd, 0x31, 0xd1, 0xff, 0xcb, 0x2d, 0x6c, 0x8e,
	0x69, 0xc2, 0xc1, 0x30, 0xfe, 0xa3, 0x6b, 0xf8, 0xc6, 0xfa, 0x4f, 0x74, 0xd5, 0x04, 0x73, 0xdd,
	0x48, 0x64, 0x6d, 0xf9, 0xe5, 0xa3, 0x55, 0x03, 0x3d, 0x36, 0x5c, 0x73, 0xeb, 0x43, 0x96, 0x89,
	0x60, 0x94, 0x8f, 0x6d, 0xfb, 0xea, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9f, 0x51, 0x01, 0x07,
	0x8b, 0x05, 0x00, 0x00,
}
