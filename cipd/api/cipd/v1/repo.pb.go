// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/cipd/api/cipd/v1/repo.proto

package api

import prpc "go.chromium.org/luci/grpc/prpc"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import empty "github.com/golang/protobuf/ptypes/empty"
import timestamp "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Roles used in package prefix ACLs.
//
// A user can have one or more such roles for a package prefix. They get
// inherited by all subprefixes.
type Role int32

const (
	Role_ROLE_UNSPECIFIED Role = 0
	// Readers can fetch package instances and package metadata (e.g. list of
	// instances, all tags, all refs), but not prefix metadata (e.g. ACLs).
	Role_READER Role = 1
	// Writers can do everything that readers can, plus create new packages,
	// upload package instances, attach tags, move refs.
	Role_WRITER Role = 2
	// Owners can do everything that writers can, plus read prefix metadata for
	// all parent prefixes and all subprefixes, and modify prefix metadata for
	// all subprefixes.
	Role_OWNER Role = 3
)

var Role_name = map[int32]string{
	0: "ROLE_UNSPECIFIED",
	1: "READER",
	2: "WRITER",
	3: "OWNER",
}
var Role_value = map[string]int32{
	"ROLE_UNSPECIFIED": 0,
	"READER":           1,
	"WRITER":           2,
	"OWNER":            3,
}

func (x Role) String() string {
	return proto.EnumName(Role_name, int32(x))
}
func (Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{0}
}

// RegistrationStatus is part of RegisterInstance RPC response.
type RegistrationStatus int32

const (
	RegistrationStatus_REGISTRATION_STATUS_UNSPECIFIED RegistrationStatus = 0
	RegistrationStatus_REGISTERED                      RegistrationStatus = 1
	RegistrationStatus_ALREADY_REGISTERED              RegistrationStatus = 2
	RegistrationStatus_NOT_UPLOADED                    RegistrationStatus = 3
)

var RegistrationStatus_name = map[int32]string{
	0: "REGISTRATION_STATUS_UNSPECIFIED",
	1: "REGISTERED",
	2: "ALREADY_REGISTERED",
	3: "NOT_UPLOADED",
}
var RegistrationStatus_value = map[string]int32{
	"REGISTRATION_STATUS_UNSPECIFIED": 0,
	"REGISTERED":                      1,
	"ALREADY_REGISTERED":              2,
	"NOT_UPLOADED":                    3,
}

func (x RegistrationStatus) String() string {
	return proto.EnumName(RegistrationStatus_name, int32(x))
}
func (RegistrationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{1}
}

type PrefixRequest struct {
	// A prefix within the repository, e.g. "a/b/c".
	Prefix               string   `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrefixRequest) Reset()         { *m = PrefixRequest{} }
func (m *PrefixRequest) String() string { return proto.CompactTextString(m) }
func (*PrefixRequest) ProtoMessage()    {}
func (*PrefixRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{0}
}
func (m *PrefixRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PrefixRequest.Unmarshal(m, b)
}
func (m *PrefixRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PrefixRequest.Marshal(b, m, deterministic)
}
func (dst *PrefixRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrefixRequest.Merge(dst, src)
}
func (m *PrefixRequest) XXX_Size() int {
	return xxx_messageInfo_PrefixRequest.Size(m)
}
func (m *PrefixRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PrefixRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PrefixRequest proto.InternalMessageInfo

func (m *PrefixRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

// PrefixMetadata is metadata defined at some concrete package prefix.
//
// It applies to this prefix and all subprefixes, recursively.
type PrefixMetadata struct {
	// Prefix this metadata is defined at, e.g. "a/b/c".
	//
	// Note: there's no metadata at the root, so prefix must never be "".
	Prefix string `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	// An opaque string that identifies a particular version of this metadata.
	//
	// Used by UpdatePrefixMetadata to prevent an accidental overwrite of changes.
	Fingerprint string `protobuf:"bytes,2,opt,name=fingerprint" json:"fingerprint,omitempty"`
	// When the metadata was modified the last time.
	//
	// Managed by the server, ignored when passed to UpdatePrefixMetadata.
	UpdateTime *timestamp.Timestamp `protobuf:"bytes,3,opt,name=update_time,json=updateTime" json:"update_time,omitempty"`
	// Identity string of whoever modified the metadata the last time.
	//
	// Managed by the server, ignored when passed to UpdatePrefixMetadata.
	UpdateUser string `protobuf:"bytes,4,opt,name=update_user,json=updateUser" json:"update_user,omitempty"`
	// ACLs that apply to this prefix and all subprefixes, as a mapping from
	// a role to a list of users and groups that have it.
	Acls                 []*PrefixMetadata_ACL `protobuf:"bytes,5,rep,name=acls" json:"acls,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *PrefixMetadata) Reset()         { *m = PrefixMetadata{} }
func (m *PrefixMetadata) String() string { return proto.CompactTextString(m) }
func (*PrefixMetadata) ProtoMessage()    {}
func (*PrefixMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{1}
}
func (m *PrefixMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PrefixMetadata.Unmarshal(m, b)
}
func (m *PrefixMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PrefixMetadata.Marshal(b, m, deterministic)
}
func (dst *PrefixMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrefixMetadata.Merge(dst, src)
}
func (m *PrefixMetadata) XXX_Size() int {
	return xxx_messageInfo_PrefixMetadata.Size(m)
}
func (m *PrefixMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_PrefixMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_PrefixMetadata proto.InternalMessageInfo

func (m *PrefixMetadata) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *PrefixMetadata) GetFingerprint() string {
	if m != nil {
		return m.Fingerprint
	}
	return ""
}

func (m *PrefixMetadata) GetUpdateTime() *timestamp.Timestamp {
	if m != nil {
		return m.UpdateTime
	}
	return nil
}

func (m *PrefixMetadata) GetUpdateUser() string {
	if m != nil {
		return m.UpdateUser
	}
	return ""
}

func (m *PrefixMetadata) GetAcls() []*PrefixMetadata_ACL {
	if m != nil {
		return m.Acls
	}
	return nil
}

type PrefixMetadata_ACL struct {
	// Role that this ACL describes.
	Role Role `protobuf:"varint,1,opt,name=role,enum=cipd.Role" json:"role,omitempty"`
	// Users and groups that have the specified role.
	//
	// Each entry has a form "<kind>:<value>", e.g "group:..." or "user:...".
	Principals           []string `protobuf:"bytes,2,rep,name=principals" json:"principals,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PrefixMetadata_ACL) Reset()         { *m = PrefixMetadata_ACL{} }
func (m *PrefixMetadata_ACL) String() string { return proto.CompactTextString(m) }
func (*PrefixMetadata_ACL) ProtoMessage()    {}
func (*PrefixMetadata_ACL) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{1, 0}
}
func (m *PrefixMetadata_ACL) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PrefixMetadata_ACL.Unmarshal(m, b)
}
func (m *PrefixMetadata_ACL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PrefixMetadata_ACL.Marshal(b, m, deterministic)
}
func (dst *PrefixMetadata_ACL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrefixMetadata_ACL.Merge(dst, src)
}
func (m *PrefixMetadata_ACL) XXX_Size() int {
	return xxx_messageInfo_PrefixMetadata_ACL.Size(m)
}
func (m *PrefixMetadata_ACL) XXX_DiscardUnknown() {
	xxx_messageInfo_PrefixMetadata_ACL.DiscardUnknown(m)
}

var xxx_messageInfo_PrefixMetadata_ACL proto.InternalMessageInfo

func (m *PrefixMetadata_ACL) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return Role_ROLE_UNSPECIFIED
}

func (m *PrefixMetadata_ACL) GetPrincipals() []string {
	if m != nil {
		return m.Principals
	}
	return nil
}

type InheritedPrefixMetadata struct {
	// Per-prefix metadata that applies to a prefix, ordered by prefix length.
	//
	// For example, when requesting metadata for prefix "a/b/c/d" the reply may
	// contain entries for "a", "a/b", "a/b/c/d" (in that order, with "a/b/c"
	// skipped in this example as not having any metadata attached).
	PerPrefixMetadata    []*PrefixMetadata `protobuf:"bytes,1,rep,name=per_prefix_metadata,json=perPrefixMetadata" json:"per_prefix_metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *InheritedPrefixMetadata) Reset()         { *m = InheritedPrefixMetadata{} }
func (m *InheritedPrefixMetadata) String() string { return proto.CompactTextString(m) }
func (*InheritedPrefixMetadata) ProtoMessage()    {}
func (*InheritedPrefixMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{2}
}
func (m *InheritedPrefixMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InheritedPrefixMetadata.Unmarshal(m, b)
}
func (m *InheritedPrefixMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InheritedPrefixMetadata.Marshal(b, m, deterministic)
}
func (dst *InheritedPrefixMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InheritedPrefixMetadata.Merge(dst, src)
}
func (m *InheritedPrefixMetadata) XXX_Size() int {
	return xxx_messageInfo_InheritedPrefixMetadata.Size(m)
}
func (m *InheritedPrefixMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_InheritedPrefixMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_InheritedPrefixMetadata proto.InternalMessageInfo

func (m *InheritedPrefixMetadata) GetPerPrefixMetadata() []*PrefixMetadata {
	if m != nil {
		return m.PerPrefixMetadata
	}
	return nil
}

type RolesInPrefixResponse struct {
	// Unordered set or roles the caller has in the requested prefix.
	Roles                []*RolesInPrefixResponse_RoleInPrefix `protobuf:"bytes,1,rep,name=roles" json:"roles,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *RolesInPrefixResponse) Reset()         { *m = RolesInPrefixResponse{} }
func (m *RolesInPrefixResponse) String() string { return proto.CompactTextString(m) }
func (*RolesInPrefixResponse) ProtoMessage()    {}
func (*RolesInPrefixResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{3}
}
func (m *RolesInPrefixResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RolesInPrefixResponse.Unmarshal(m, b)
}
func (m *RolesInPrefixResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RolesInPrefixResponse.Marshal(b, m, deterministic)
}
func (dst *RolesInPrefixResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RolesInPrefixResponse.Merge(dst, src)
}
func (m *RolesInPrefixResponse) XXX_Size() int {
	return xxx_messageInfo_RolesInPrefixResponse.Size(m)
}
func (m *RolesInPrefixResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RolesInPrefixResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RolesInPrefixResponse proto.InternalMessageInfo

func (m *RolesInPrefixResponse) GetRoles() []*RolesInPrefixResponse_RoleInPrefix {
	if m != nil {
		return m.Roles
	}
	return nil
}

type RolesInPrefixResponse_RoleInPrefix struct {
	Role                 Role     `protobuf:"varint,1,opt,name=role,enum=cipd.Role" json:"role,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RolesInPrefixResponse_RoleInPrefix) Reset()         { *m = RolesInPrefixResponse_RoleInPrefix{} }
func (m *RolesInPrefixResponse_RoleInPrefix) String() string { return proto.CompactTextString(m) }
func (*RolesInPrefixResponse_RoleInPrefix) ProtoMessage()    {}
func (*RolesInPrefixResponse_RoleInPrefix) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{3, 0}
}
func (m *RolesInPrefixResponse_RoleInPrefix) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RolesInPrefixResponse_RoleInPrefix.Unmarshal(m, b)
}
func (m *RolesInPrefixResponse_RoleInPrefix) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RolesInPrefixResponse_RoleInPrefix.Marshal(b, m, deterministic)
}
func (dst *RolesInPrefixResponse_RoleInPrefix) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RolesInPrefixResponse_RoleInPrefix.Merge(dst, src)
}
func (m *RolesInPrefixResponse_RoleInPrefix) XXX_Size() int {
	return xxx_messageInfo_RolesInPrefixResponse_RoleInPrefix.Size(m)
}
func (m *RolesInPrefixResponse_RoleInPrefix) XXX_DiscardUnknown() {
	xxx_messageInfo_RolesInPrefixResponse_RoleInPrefix.DiscardUnknown(m)
}

var xxx_messageInfo_RolesInPrefixResponse_RoleInPrefix proto.InternalMessageInfo

func (m *RolesInPrefixResponse_RoleInPrefix) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return Role_ROLE_UNSPECIFIED
}

type ListPrefixRequest struct {
	// A prefix within the repository to list, e.g. "a/b/c". Empty prefix is also
	// accepted: it means "root of the repository".
	Prefix string `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	// If false, list only direct descendants of the prefix, otherwise all.
	Recursive bool `protobuf:"varint,2,opt,name=recursive" json:"recursive,omitempty"`
	// If true, include hidden packages in the result.
	IncludeHidden        bool     `protobuf:"varint,3,opt,name=include_hidden,json=includeHidden" json:"include_hidden,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPrefixRequest) Reset()         { *m = ListPrefixRequest{} }
func (m *ListPrefixRequest) String() string { return proto.CompactTextString(m) }
func (*ListPrefixRequest) ProtoMessage()    {}
func (*ListPrefixRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{4}
}
func (m *ListPrefixRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPrefixRequest.Unmarshal(m, b)
}
func (m *ListPrefixRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPrefixRequest.Marshal(b, m, deterministic)
}
func (dst *ListPrefixRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPrefixRequest.Merge(dst, src)
}
func (m *ListPrefixRequest) XXX_Size() int {
	return xxx_messageInfo_ListPrefixRequest.Size(m)
}
func (m *ListPrefixRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPrefixRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListPrefixRequest proto.InternalMessageInfo

func (m *ListPrefixRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *ListPrefixRequest) GetRecursive() bool {
	if m != nil {
		return m.Recursive
	}
	return false
}

func (m *ListPrefixRequest) GetIncludeHidden() bool {
	if m != nil {
		return m.IncludeHidden
	}
	return false
}

type ListPrefixResponse struct {
	// Lexicographically sorted list of full packages names.
	Packages []string `protobuf:"bytes,1,rep,name=packages" json:"packages,omitempty"`
	// Lexicographically sorted list of child prefixes (without trailing '/').
	Prefixes             []string `protobuf:"bytes,2,rep,name=prefixes" json:"prefixes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPrefixResponse) Reset()         { *m = ListPrefixResponse{} }
func (m *ListPrefixResponse) String() string { return proto.CompactTextString(m) }
func (*ListPrefixResponse) ProtoMessage()    {}
func (*ListPrefixResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{5}
}
func (m *ListPrefixResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListPrefixResponse.Unmarshal(m, b)
}
func (m *ListPrefixResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListPrefixResponse.Marshal(b, m, deterministic)
}
func (dst *ListPrefixResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPrefixResponse.Merge(dst, src)
}
func (m *ListPrefixResponse) XXX_Size() int {
	return xxx_messageInfo_ListPrefixResponse.Size(m)
}
func (m *ListPrefixResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPrefixResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListPrefixResponse proto.InternalMessageInfo

func (m *ListPrefixResponse) GetPackages() []string {
	if m != nil {
		return m.Packages
	}
	return nil
}

func (m *ListPrefixResponse) GetPrefixes() []string {
	if m != nil {
		return m.Prefixes
	}
	return nil
}

// PackageRequest names a package and nothing else.
type PackageRequest struct {
	Package              string   `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PackageRequest) Reset()         { *m = PackageRequest{} }
func (m *PackageRequest) String() string { return proto.CompactTextString(m) }
func (*PackageRequest) ProtoMessage()    {}
func (*PackageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{6}
}
func (m *PackageRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PackageRequest.Unmarshal(m, b)
}
func (m *PackageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PackageRequest.Marshal(b, m, deterministic)
}
func (dst *PackageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PackageRequest.Merge(dst, src)
}
func (m *PackageRequest) XXX_Size() int {
	return xxx_messageInfo_PackageRequest.Size(m)
}
func (m *PackageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PackageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PackageRequest proto.InternalMessageInfo

func (m *PackageRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

// Instance is a pointer to an instance of some package.
type Instance struct {
	// A name of the package, e.g. "a/b/c/d".
	Package string `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
	// A reference to the instance file in the storage.
	Instance *ObjectRef `protobuf:"bytes,2,opt,name=instance" json:"instance,omitempty"`
	// User who registered the instance (output only).
	RegisteredBy string `protobuf:"bytes,3,opt,name=registered_by,json=registeredBy" json:"registered_by,omitempty"`
	// When the instance was registered (output only).
	RegisteredTs         *timestamp.Timestamp `protobuf:"bytes,4,opt,name=registered_ts,json=registeredTs" json:"registered_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Instance) Reset()         { *m = Instance{} }
func (m *Instance) String() string { return proto.CompactTextString(m) }
func (*Instance) ProtoMessage()    {}
func (*Instance) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{7}
}
func (m *Instance) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Instance.Unmarshal(m, b)
}
func (m *Instance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Instance.Marshal(b, m, deterministic)
}
func (dst *Instance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Instance.Merge(dst, src)
}
func (m *Instance) XXX_Size() int {
	return xxx_messageInfo_Instance.Size(m)
}
func (m *Instance) XXX_DiscardUnknown() {
	xxx_messageInfo_Instance.DiscardUnknown(m)
}

var xxx_messageInfo_Instance proto.InternalMessageInfo

func (m *Instance) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *Instance) GetInstance() *ObjectRef {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *Instance) GetRegisteredBy() string {
	if m != nil {
		return m.RegisteredBy
	}
	return ""
}

func (m *Instance) GetRegisteredTs() *timestamp.Timestamp {
	if m != nil {
		return m.RegisteredTs
	}
	return nil
}

type RegisterInstanceResponse struct {
	// Outcome of the operation, see the enum for possibilities.
	//
	// Defines what other fields are present.
	Status RegistrationStatus `protobuf:"varint,1,opt,name=status,enum=cipd.RegistrationStatus" json:"status,omitempty"`
	// For statuses REGISTERED and ALREADY_REGISTERED contains details about the
	// instance. Not set for NOT_UPLOADED status.
	Instance *Instance `protobuf:"bytes,2,opt,name=instance" json:"instance,omitempty"`
	// For status NOT_UPLOADED contains a new upload operation that can be used
	// together with Storage service to upload the instance file. Not set for
	// other statuses.
	UploadOp             *UploadOperation `protobuf:"bytes,3,opt,name=upload_op,json=uploadOp" json:"upload_op,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *RegisterInstanceResponse) Reset()         { *m = RegisterInstanceResponse{} }
func (m *RegisterInstanceResponse) String() string { return proto.CompactTextString(m) }
func (*RegisterInstanceResponse) ProtoMessage()    {}
func (*RegisterInstanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{8}
}
func (m *RegisterInstanceResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RegisterInstanceResponse.Unmarshal(m, b)
}
func (m *RegisterInstanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RegisterInstanceResponse.Marshal(b, m, deterministic)
}
func (dst *RegisterInstanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterInstanceResponse.Merge(dst, src)
}
func (m *RegisterInstanceResponse) XXX_Size() int {
	return xxx_messageInfo_RegisterInstanceResponse.Size(m)
}
func (m *RegisterInstanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterInstanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterInstanceResponse proto.InternalMessageInfo

func (m *RegisterInstanceResponse) GetStatus() RegistrationStatus {
	if m != nil {
		return m.Status
	}
	return RegistrationStatus_REGISTRATION_STATUS_UNSPECIFIED
}

func (m *RegisterInstanceResponse) GetInstance() *Instance {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *RegisterInstanceResponse) GetUploadOp() *UploadOperation {
	if m != nil {
		return m.UploadOp
	}
	return nil
}

type ListInstancesRequest struct {
	// Name of a package to list instances of.
	Package string `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
	// Number of instances to return on one page, default is 100.
	PageSize int32 `protobuf:"varint,20,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
	// Value of 'next_page_token' from the previous response.
	//
	// Can be used to resume fetching.
	PageToken            string   `protobuf:"bytes,21,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListInstancesRequest) Reset()         { *m = ListInstancesRequest{} }
func (m *ListInstancesRequest) String() string { return proto.CompactTextString(m) }
func (*ListInstancesRequest) ProtoMessage()    {}
func (*ListInstancesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{9}
}
func (m *ListInstancesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListInstancesRequest.Unmarshal(m, b)
}
func (m *ListInstancesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListInstancesRequest.Marshal(b, m, deterministic)
}
func (dst *ListInstancesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListInstancesRequest.Merge(dst, src)
}
func (m *ListInstancesRequest) XXX_Size() int {
	return xxx_messageInfo_ListInstancesRequest.Size(m)
}
func (m *ListInstancesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListInstancesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListInstancesRequest proto.InternalMessageInfo

func (m *ListInstancesRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *ListInstancesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListInstancesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

type ListInstancesResponse struct {
	// Package instances, sorted by registration time, most recent first.
	Instances []*Instance `protobuf:"bytes,1,rep,name=instances" json:"instances,omitempty"`
	// Value to pass as 'page_token' in ListInstancesRequest to resume fetching or
	// empty string if there's no more results.
	NextPageToken        string   `protobuf:"bytes,20,opt,name=next_page_token,json=nextPageToken" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListInstancesResponse) Reset()         { *m = ListInstancesResponse{} }
func (m *ListInstancesResponse) String() string { return proto.CompactTextString(m) }
func (*ListInstancesResponse) ProtoMessage()    {}
func (*ListInstancesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{10}
}
func (m *ListInstancesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListInstancesResponse.Unmarshal(m, b)
}
func (m *ListInstancesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListInstancesResponse.Marshal(b, m, deterministic)
}
func (dst *ListInstancesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListInstancesResponse.Merge(dst, src)
}
func (m *ListInstancesResponse) XXX_Size() int {
	return xxx_messageInfo_ListInstancesResponse.Size(m)
}
func (m *ListInstancesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListInstancesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListInstancesResponse proto.InternalMessageInfo

func (m *ListInstancesResponse) GetInstances() []*Instance {
	if m != nil {
		return m.Instances
	}
	return nil
}

func (m *ListInstancesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// Ref is a mutable named pointer to some package instance that can be used
// as a version identifier.
type Ref struct {
	// Name of the ref, e.g. "latest".
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Name of the package where the ref is defined.
	Package string `protobuf:"bytes,2,opt,name=package" json:"package,omitempty"`
	// A package instance the ref is pointing to.
	Instance *ObjectRef `protobuf:"bytes,3,opt,name=instance" json:"instance,omitempty"`
	// User who modified this ref the last time (output only).
	ModifiedBy string `protobuf:"bytes,4,opt,name=modified_by,json=modifiedBy" json:"modified_by,omitempty"`
	// When the ref was modified the last time (output only).
	ModifiedTs           *timestamp.Timestamp `protobuf:"bytes,5,opt,name=modified_ts,json=modifiedTs" json:"modified_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Ref) Reset()         { *m = Ref{} }
func (m *Ref) String() string { return proto.CompactTextString(m) }
func (*Ref) ProtoMessage()    {}
func (*Ref) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{11}
}
func (m *Ref) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ref.Unmarshal(m, b)
}
func (m *Ref) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ref.Marshal(b, m, deterministic)
}
func (dst *Ref) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ref.Merge(dst, src)
}
func (m *Ref) XXX_Size() int {
	return xxx_messageInfo_Ref.Size(m)
}
func (m *Ref) XXX_DiscardUnknown() {
	xxx_messageInfo_Ref.DiscardUnknown(m)
}

var xxx_messageInfo_Ref proto.InternalMessageInfo

func (m *Ref) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Ref) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *Ref) GetInstance() *ObjectRef {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *Ref) GetModifiedBy() string {
	if m != nil {
		return m.ModifiedBy
	}
	return ""
}

func (m *Ref) GetModifiedTs() *timestamp.Timestamp {
	if m != nil {
		return m.ModifiedTs
	}
	return nil
}

type DeleteRefRequest struct {
	// Name of the ref, e.g. "latest".
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Name of the package where the ref is defined.
	Package              string   `protobuf:"bytes,2,opt,name=package" json:"package,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteRefRequest) Reset()         { *m = DeleteRefRequest{} }
func (m *DeleteRefRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRefRequest) ProtoMessage()    {}
func (*DeleteRefRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{12}
}
func (m *DeleteRefRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteRefRequest.Unmarshal(m, b)
}
func (m *DeleteRefRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteRefRequest.Marshal(b, m, deterministic)
}
func (dst *DeleteRefRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRefRequest.Merge(dst, src)
}
func (m *DeleteRefRequest) XXX_Size() int {
	return xxx_messageInfo_DeleteRefRequest.Size(m)
}
func (m *DeleteRefRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRefRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRefRequest proto.InternalMessageInfo

func (m *DeleteRefRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeleteRefRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

type ListRefsRequest struct {
	// Name of a package to list refs of.
	Package              string   `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListRefsRequest) Reset()         { *m = ListRefsRequest{} }
func (m *ListRefsRequest) String() string { return proto.CompactTextString(m) }
func (*ListRefsRequest) ProtoMessage()    {}
func (*ListRefsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{13}
}
func (m *ListRefsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListRefsRequest.Unmarshal(m, b)
}
func (m *ListRefsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListRefsRequest.Marshal(b, m, deterministic)
}
func (dst *ListRefsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRefsRequest.Merge(dst, src)
}
func (m *ListRefsRequest) XXX_Size() int {
	return xxx_messageInfo_ListRefsRequest.Size(m)
}
func (m *ListRefsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRefsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRefsRequest proto.InternalMessageInfo

func (m *ListRefsRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

type ListRefsResponse struct {
	// Package refs, sorted by modification time, most recently touched first.
	Refs                 []*Ref   `protobuf:"bytes,1,rep,name=refs" json:"refs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListRefsResponse) Reset()         { *m = ListRefsResponse{} }
func (m *ListRefsResponse) String() string { return proto.CompactTextString(m) }
func (*ListRefsResponse) ProtoMessage()    {}
func (*ListRefsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{14}
}
func (m *ListRefsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListRefsResponse.Unmarshal(m, b)
}
func (m *ListRefsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListRefsResponse.Marshal(b, m, deterministic)
}
func (dst *ListRefsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRefsResponse.Merge(dst, src)
}
func (m *ListRefsResponse) XXX_Size() int {
	return xxx_messageInfo_ListRefsResponse.Size(m)
}
func (m *ListRefsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRefsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListRefsResponse proto.InternalMessageInfo

func (m *ListRefsResponse) GetRefs() []*Ref {
	if m != nil {
		return m.Refs
	}
	return nil
}

// Tag is a key:value pair attached to some instance.
//
// Keys don't have to be unique, only the full pair should. For example,
// it is fine to have "version:1" and "version:2" tags attached to the same
// instance.
//
// The total length of the tag (as "key:value" pair) should be less that 400
// bytes.
type Tag struct {
	// Key should be a lowercase identifier-like string ([a-z0-9_\-]+).
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// Value can be an arbitrary string.
	Value                string   `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tag) Reset()         { *m = Tag{} }
func (m *Tag) String() string { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()    {}
func (*Tag) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{15}
}
func (m *Tag) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Tag.Unmarshal(m, b)
}
func (m *Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Tag.Marshal(b, m, deterministic)
}
func (dst *Tag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tag.Merge(dst, src)
}
func (m *Tag) XXX_Size() int {
	return xxx_messageInfo_Tag.Size(m)
}
func (m *Tag) XXX_DiscardUnknown() {
	xxx_messageInfo_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_Tag proto.InternalMessageInfo

func (m *Tag) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Tag) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type AttachTagsRequest struct {
	// The package that holds the instance we attach tags to.
	Package string `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
	// The instance we attach tags to.
	Instance *ObjectRef `protobuf:"bytes,2,opt,name=instance" json:"instance,omitempty"`
	// One or more tags to attach (order doesn't matter).
	Tags                 []*Tag   `protobuf:"bytes,3,rep,name=tags" json:"tags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttachTagsRequest) Reset()         { *m = AttachTagsRequest{} }
func (m *AttachTagsRequest) String() string { return proto.CompactTextString(m) }
func (*AttachTagsRequest) ProtoMessage()    {}
func (*AttachTagsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{16}
}
func (m *AttachTagsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttachTagsRequest.Unmarshal(m, b)
}
func (m *AttachTagsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttachTagsRequest.Marshal(b, m, deterministic)
}
func (dst *AttachTagsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttachTagsRequest.Merge(dst, src)
}
func (m *AttachTagsRequest) XXX_Size() int {
	return xxx_messageInfo_AttachTagsRequest.Size(m)
}
func (m *AttachTagsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttachTagsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttachTagsRequest proto.InternalMessageInfo

func (m *AttachTagsRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *AttachTagsRequest) GetInstance() *ObjectRef {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *AttachTagsRequest) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

type DetachTagsRequest struct {
	// The package that holds the instance we detach tags from.
	Package string `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
	// The instance we detach tags from.
	Instance *ObjectRef `protobuf:"bytes,2,opt,name=instance" json:"instance,omitempty"`
	// One or more tags to detach (order doesn't matter).
	Tags                 []*Tag   `protobuf:"bytes,3,rep,name=tags" json:"tags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DetachTagsRequest) Reset()         { *m = DetachTagsRequest{} }
func (m *DetachTagsRequest) String() string { return proto.CompactTextString(m) }
func (*DetachTagsRequest) ProtoMessage()    {}
func (*DetachTagsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{17}
}
func (m *DetachTagsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetachTagsRequest.Unmarshal(m, b)
}
func (m *DetachTagsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetachTagsRequest.Marshal(b, m, deterministic)
}
func (dst *DetachTagsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetachTagsRequest.Merge(dst, src)
}
func (m *DetachTagsRequest) XXX_Size() int {
	return xxx_messageInfo_DetachTagsRequest.Size(m)
}
func (m *DetachTagsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DetachTagsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DetachTagsRequest proto.InternalMessageInfo

func (m *DetachTagsRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *DetachTagsRequest) GetInstance() *ObjectRef {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *DetachTagsRequest) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

type ResolveVersionRequest struct {
	// The package that contains the instance we are resolving version of.
	Package string `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
	// The version string to resolve, see ResolveVersion for details.
	Version              string   `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResolveVersionRequest) Reset()         { *m = ResolveVersionRequest{} }
func (m *ResolveVersionRequest) String() string { return proto.CompactTextString(m) }
func (*ResolveVersionRequest) ProtoMessage()    {}
func (*ResolveVersionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_repo_affa443c330fcf82, []int{18}
}
func (m *ResolveVersionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResolveVersionRequest.Unmarshal(m, b)
}
func (m *ResolveVersionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResolveVersionRequest.Marshal(b, m, deterministic)
}
func (dst *ResolveVersionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveVersionRequest.Merge(dst, src)
}
func (m *ResolveVersionRequest) XXX_Size() int {
	return xxx_messageInfo_ResolveVersionRequest.Size(m)
}
func (m *ResolveVersionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveVersionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveVersionRequest proto.InternalMessageInfo

func (m *ResolveVersionRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *ResolveVersionRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func init() {
	proto.RegisterType((*PrefixRequest)(nil), "cipd.PrefixRequest")
	proto.RegisterType((*PrefixMetadata)(nil), "cipd.PrefixMetadata")
	proto.RegisterType((*PrefixMetadata_ACL)(nil), "cipd.PrefixMetadata.ACL")
	proto.RegisterType((*InheritedPrefixMetadata)(nil), "cipd.InheritedPrefixMetadata")
	proto.RegisterType((*RolesInPrefixResponse)(nil), "cipd.RolesInPrefixResponse")
	proto.RegisterType((*RolesInPrefixResponse_RoleInPrefix)(nil), "cipd.RolesInPrefixResponse.RoleInPrefix")
	proto.RegisterType((*ListPrefixRequest)(nil), "cipd.ListPrefixRequest")
	proto.RegisterType((*ListPrefixResponse)(nil), "cipd.ListPrefixResponse")
	proto.RegisterType((*PackageRequest)(nil), "cipd.PackageRequest")
	proto.RegisterType((*Instance)(nil), "cipd.Instance")
	proto.RegisterType((*RegisterInstanceResponse)(nil), "cipd.RegisterInstanceResponse")
	proto.RegisterType((*ListInstancesRequest)(nil), "cipd.ListInstancesRequest")
	proto.RegisterType((*ListInstancesResponse)(nil), "cipd.ListInstancesResponse")
	proto.RegisterType((*Ref)(nil), "cipd.Ref")
	proto.RegisterType((*DeleteRefRequest)(nil), "cipd.DeleteRefRequest")
	proto.RegisterType((*ListRefsRequest)(nil), "cipd.ListRefsRequest")
	proto.RegisterType((*ListRefsResponse)(nil), "cipd.ListRefsResponse")
	proto.RegisterType((*Tag)(nil), "cipd.Tag")
	proto.RegisterType((*AttachTagsRequest)(nil), "cipd.AttachTagsRequest")
	proto.RegisterType((*DetachTagsRequest)(nil), "cipd.DetachTagsRequest")
	proto.RegisterType((*ResolveVersionRequest)(nil), "cipd.ResolveVersionRequest")
	proto.RegisterEnum("cipd.Role", Role_name, Role_value)
	proto.RegisterEnum("cipd.RegistrationStatus", RegistrationStatus_name, RegistrationStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RepositoryClient is the client API for Repository service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RepositoryClient interface {
	// Returns metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// If the caller has OWNER permission in any of parent prefixes, but the
	// requested prefix has no metadata associated with it, the call fails with
	// NOT_FOUND error.
	GetPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*PrefixMetadata, error)
	// Returns metadata associated with the given prefix and all parent prefixes.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// Note that if the caller has permission to see the metadata for the
	// requested prefix, they will also see metadata for all parent prefixes,
	// since it is needed to assemble the final metadata for the prefix (it
	// includes inherited properties from all parent prefixes).
	GetInheritedPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*InheritedPrefixMetadata, error)
	// Updates or creates metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// This method checks 'fingerprint' field of the PrefixMetadata object. If the
	// metadata for the given prefix already exists, and the fingerprint in the
	// request doesn't match the current fingerprint, the request fails with
	// FAILED_PRECONDITION error.
	//
	// If the metadata doesn't exist yet, its fingerprint is assumed to be empty
	// string. So pass empty fingerprint when creating initial metadata objects.
	//
	// If the caller passes empty fingerprint, but the metadata already exists,
	// the request fails with ALREADY_EXISTS error.
	//
	// Note that there's no way to delete metadata once it was created. Passing
	// empty PrefixMetadata object is the best that can be done.
	//
	// On success returns PrefixMetadata object with the updated fingerprint.
	UpdatePrefixMetadata(ctx context.Context, in *PrefixMetadata, opts ...grpc.CallOption) (*PrefixMetadata, error)
	// Returns a set of roles the caller has in the given prefix.
	//
	// Unlike GetPrefixMetadata call that requires OWNER access (since it returns
	// a lot of detailed information), GetRolesInPrefix can be called by anyone.
	//
	// It understands and expands roles inheritance, e.g. if the caller is an
	// OWNER, the result will also contain WRITER and READER (as they are implied
	// by being an OWNER).
	//
	// Returns empty set of roles if the caller has no permissions to access the
	// prefix at all or such prefix doesn't exist.
	GetRolesInPrefix(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*RolesInPrefixResponse, error)
	// Lists packages and subprefixes registered under the prefix.
	//
	// Lists either only direct descendants or recursively all descendants. The
	// result is sorted lexicographically.
	//
	// For example, for packages ["a", "a/b", "a/c/d", "a/c/e/f"], listing of "a"
	// will be:
	//   * {packages: ["a/b"], prefixes: ["a/c"]} if listing non-recursively.
	//   * {packages: ["a/b", "a/c/d", "a/c/e/f"], prefixes: ["a/c", "a/c/e"]} if
	//     listing recursively.
	//
	// Returns only packages and prefixes visible to the caller. This applies even
	// when listing a prefix the caller has no direct read access to. For example,
	// recursively listing the root prefix will return all packages the caller has
	// read access to (no matter when in the hierarchy they are located), even if
	// the caller has no READER permission in the root. It works as if the caller
	// can freely browse the repository that contains only the packages they can
	// see and nothing else.
	ListPrefix(ctx context.Context, in *ListPrefixRequest, opts ...grpc.CallOption) (*ListPrefixResponse, error)
	// HidePackage marks the package as hidden.
	//
	// This removes it from the ListPrefix results, but doesn't otherwise affect
	// its usage (e.g. it is still fetchable).
	//
	// Requires OWNER role for the package prefix. Returns PERMISSION_DENIED
	// otherwise.
	HidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// UnhidePackage marks the package as visible again.
	//
	// It's reverse of HidePackage.
	//
	// Requires OWNER role for the package prefix. Returns PERMISSION_DENIED
	// otherwise.
	UnhidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Registers a package instance in the repository (if it was uploaded to the
	// storage already and wasn't registered yet) or initiates a new upload
	// operation.
	//
	// Callers are expected to execute the following protocol:
	//   1. Attempt to register a package instance by calling RegisterInstance.
	//   2. On NOT_UPLOADED status, upload the package data and finalize the
	//      upload operation using Storage RPC service and upload_op from the
	//      response.
	//   3. Once the upload operation is finalized, call RegisterInstance again,
	//      it should succeed with status REGISTERED now.
	//
	// If such instance is already registered by someone else, returns
	// ALREADY_REGISTERED status. This is not an error.
	//
	// Callers must have roles WRITER or OWNER for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	RegisterInstance(ctx context.Context, in *Instance, opts ...grpc.CallOption) (*RegisterInstanceResponse, error)
	// Lists instances of a package, most recent first.
	//
	// Callers must have roles READER (or above) for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	//
	// If the package doesn't exist, returns NOT_FOUND.
	ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error)
	// Creates a new ref or moves an existing one.
	//
	// A ref is a mutable named pointer to some existing package instance that
	// can be used as a version identifier. For example, "latest" or "stable".
	//
	// Refs are namespaced to some particular package. E.g. "latest" ref in
	// packages "A" and "B" are completely different entities not related to each
	// other.
	//
	// Pointing a ref to an instance generally makes the instance "discoverable".
	// For that reason the ref can be set only to instances that successfully
	// passed all post-registration processing.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package or the instance the ref points to doesn't exist.
	//   FAILED_PRECONDITION if the instance is still being processed.
	//   ABORTED if the instance has some failed processors associated with it,
	//       such instance is effectively broken and should not be used.
	CreateRef(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*empty.Empty, error)
	// Removes a ref.
	//
	// Not a failure if there's no such ref.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package doesn't exist.
	DeleteRef(ctx context.Context, in *DeleteRefRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Lists refs defined in a package, most recently modified first.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a READER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package doesn't exist.
	ListRefs(ctx context.Context, in *ListRefsRequest, opts ...grpc.CallOption) (*ListRefsResponse, error)
	// Attaches one or more tags to an instance.
	//
	// Silently skips already attached tags.
	//
	// Tags are "key:value" pairs associated with a concrete package instance.
	// They can be used for querying registered instances and for version
	// resolution: if a tag is attached to one and only one instance of a package,
	// the tag uniquely identifies this instance and such tag can be used as an
	// alias of the instance ID.
	//
	// Tags generally should be assumed globally namespaced (e.g. it makes sense
	// to query for all registered instances with a given tag, across all
	// packages), and they don't have to be unique: same tag may be attached to
	// multiple instances (of the same or different packages).
	//
	// Additionally, tags (unlike refs) are intended to be mostly static, since
	// they usually relate to some properties of package instances, which are
	// static entities. This is particularity important for tags used for version
	// resolution.
	//
	// Attaching a tag to an instance generally makes the instance "discoverable".
	// For that reason tags can be attached only to instances that successfully
	// passed all post-registration processing.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package or the instance doesn't exist.
	//   FAILED_PRECONDITION if the instance is still being processed.
	//   ABORTED if the instance has some failed processors associated with it,
	//       such instance is effectively broken and should not be used.
	AttachTags(ctx context.Context, in *AttachTagsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Detaches one or more tags if they were attached.
	//
	// This call should not be used routinely, since tags are assumed to be
	// static (and thus not detachable).
	//
	// It is occasionally useful for fixing screw ups though. For that reason,
	// DetachTags is allowed only by OWNERS of a prefix (not WRITERS, like
	// AttachTags).
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not an OWNER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package or the instance doesn't exist.
	DetachTags(ctx context.Context, in *DetachTagsRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// Takes a version string and resolves it into a concrete package instance.
	//
	// A version string can be any of:
	//   * A string-encoded instance ID, e.g. "abcdef....".
	//   * A ref name, e.g. "latest".
	//   * A tag, e.g. "version:1.10.3".
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a READER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if there's no such package or version.
	//   FAILED_PRECONDITION if the tag resolves to multiple instances.
	ResolveVersion(ctx context.Context, in *ResolveVersionRequest, opts ...grpc.CallOption) (*Instance, error)
}
type repositoryPRPCClient struct {
	client *prpc.Client
}

func NewRepositoryPRPCClient(client *prpc.Client) RepositoryClient {
	return &repositoryPRPCClient{client}
}

func (c *repositoryPRPCClient) GetPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*PrefixMetadata, error) {
	out := new(PrefixMetadata)
	err := c.client.Call(ctx, "cipd.Repository", "GetPrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) GetInheritedPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*InheritedPrefixMetadata, error) {
	out := new(InheritedPrefixMetadata)
	err := c.client.Call(ctx, "cipd.Repository", "GetInheritedPrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) UpdatePrefixMetadata(ctx context.Context, in *PrefixMetadata, opts ...grpc.CallOption) (*PrefixMetadata, error) {
	out := new(PrefixMetadata)
	err := c.client.Call(ctx, "cipd.Repository", "UpdatePrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) GetRolesInPrefix(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*RolesInPrefixResponse, error) {
	out := new(RolesInPrefixResponse)
	err := c.client.Call(ctx, "cipd.Repository", "GetRolesInPrefix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) ListPrefix(ctx context.Context, in *ListPrefixRequest, opts ...grpc.CallOption) (*ListPrefixResponse, error) {
	out := new(ListPrefixResponse)
	err := c.client.Call(ctx, "cipd.Repository", "ListPrefix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) HidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "cipd.Repository", "HidePackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) UnhidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "cipd.Repository", "UnhidePackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) RegisterInstance(ctx context.Context, in *Instance, opts ...grpc.CallOption) (*RegisterInstanceResponse, error) {
	out := new(RegisterInstanceResponse)
	err := c.client.Call(ctx, "cipd.Repository", "RegisterInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error) {
	out := new(ListInstancesResponse)
	err := c.client.Call(ctx, "cipd.Repository", "ListInstances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) CreateRef(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "cipd.Repository", "CreateRef", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) DeleteRef(ctx context.Context, in *DeleteRefRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "cipd.Repository", "DeleteRef", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) ListRefs(ctx context.Context, in *ListRefsRequest, opts ...grpc.CallOption) (*ListRefsResponse, error) {
	out := new(ListRefsResponse)
	err := c.client.Call(ctx, "cipd.Repository", "ListRefs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) AttachTags(ctx context.Context, in *AttachTagsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "cipd.Repository", "AttachTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) DetachTags(ctx context.Context, in *DetachTagsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.client.Call(ctx, "cipd.Repository", "DetachTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryPRPCClient) ResolveVersion(ctx context.Context, in *ResolveVersionRequest, opts ...grpc.CallOption) (*Instance, error) {
	out := new(Instance)
	err := c.client.Call(ctx, "cipd.Repository", "ResolveVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type repositoryClient struct {
	cc *grpc.ClientConn
}

func NewRepositoryClient(cc *grpc.ClientConn) RepositoryClient {
	return &repositoryClient{cc}
}

func (c *repositoryClient) GetPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*PrefixMetadata, error) {
	out := new(PrefixMetadata)
	err := c.cc.Invoke(ctx, "/cipd.Repository/GetPrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) GetInheritedPrefixMetadata(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*InheritedPrefixMetadata, error) {
	out := new(InheritedPrefixMetadata)
	err := c.cc.Invoke(ctx, "/cipd.Repository/GetInheritedPrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) UpdatePrefixMetadata(ctx context.Context, in *PrefixMetadata, opts ...grpc.CallOption) (*PrefixMetadata, error) {
	out := new(PrefixMetadata)
	err := c.cc.Invoke(ctx, "/cipd.Repository/UpdatePrefixMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) GetRolesInPrefix(ctx context.Context, in *PrefixRequest, opts ...grpc.CallOption) (*RolesInPrefixResponse, error) {
	out := new(RolesInPrefixResponse)
	err := c.cc.Invoke(ctx, "/cipd.Repository/GetRolesInPrefix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) ListPrefix(ctx context.Context, in *ListPrefixRequest, opts ...grpc.CallOption) (*ListPrefixResponse, error) {
	out := new(ListPrefixResponse)
	err := c.cc.Invoke(ctx, "/cipd.Repository/ListPrefix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) HidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/cipd.Repository/HidePackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) UnhidePackage(ctx context.Context, in *PackageRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/cipd.Repository/UnhidePackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) RegisterInstance(ctx context.Context, in *Instance, opts ...grpc.CallOption) (*RegisterInstanceResponse, error) {
	out := new(RegisterInstanceResponse)
	err := c.cc.Invoke(ctx, "/cipd.Repository/RegisterInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error) {
	out := new(ListInstancesResponse)
	err := c.cc.Invoke(ctx, "/cipd.Repository/ListInstances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) CreateRef(ctx context.Context, in *Ref, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/cipd.Repository/CreateRef", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) DeleteRef(ctx context.Context, in *DeleteRefRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/cipd.Repository/DeleteRef", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) ListRefs(ctx context.Context, in *ListRefsRequest, opts ...grpc.CallOption) (*ListRefsResponse, error) {
	out := new(ListRefsResponse)
	err := c.cc.Invoke(ctx, "/cipd.Repository/ListRefs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) AttachTags(ctx context.Context, in *AttachTagsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/cipd.Repository/AttachTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) DetachTags(ctx context.Context, in *DetachTagsRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/cipd.Repository/DetachTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repositoryClient) ResolveVersion(ctx context.Context, in *ResolveVersionRequest, opts ...grpc.CallOption) (*Instance, error) {
	out := new(Instance)
	err := c.cc.Invoke(ctx, "/cipd.Repository/ResolveVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RepositoryServer is the server API for Repository service.
type RepositoryServer interface {
	// Returns metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// If the caller has OWNER permission in any of parent prefixes, but the
	// requested prefix has no metadata associated with it, the call fails with
	// NOT_FOUND error.
	GetPrefixMetadata(context.Context, *PrefixRequest) (*PrefixMetadata, error)
	// Returns metadata associated with the given prefix and all parent prefixes.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// Note that if the caller has permission to see the metadata for the
	// requested prefix, they will also see metadata for all parent prefixes,
	// since it is needed to assemble the final metadata for the prefix (it
	// includes inherited properties from all parent prefixes).
	GetInheritedPrefixMetadata(context.Context, *PrefixRequest) (*InheritedPrefixMetadata, error)
	// Updates or creates metadata associated with the given prefix.
	//
	// Requires the caller to have OWNER role for the requested prefix or any of
	// parent prefixes, otherwise the call fails with PERMISSION_DENIED error.
	//
	// This method checks 'fingerprint' field of the PrefixMetadata object. If the
	// metadata for the given prefix already exists, and the fingerprint in the
	// request doesn't match the current fingerprint, the request fails with
	// FAILED_PRECONDITION error.
	//
	// If the metadata doesn't exist yet, its fingerprint is assumed to be empty
	// string. So pass empty fingerprint when creating initial metadata objects.
	//
	// If the caller passes empty fingerprint, but the metadata already exists,
	// the request fails with ALREADY_EXISTS error.
	//
	// Note that there's no way to delete metadata once it was created. Passing
	// empty PrefixMetadata object is the best that can be done.
	//
	// On success returns PrefixMetadata object with the updated fingerprint.
	UpdatePrefixMetadata(context.Context, *PrefixMetadata) (*PrefixMetadata, error)
	// Returns a set of roles the caller has in the given prefix.
	//
	// Unlike GetPrefixMetadata call that requires OWNER access (since it returns
	// a lot of detailed information), GetRolesInPrefix can be called by anyone.
	//
	// It understands and expands roles inheritance, e.g. if the caller is an
	// OWNER, the result will also contain WRITER and READER (as they are implied
	// by being an OWNER).
	//
	// Returns empty set of roles if the caller has no permissions to access the
	// prefix at all or such prefix doesn't exist.
	GetRolesInPrefix(context.Context, *PrefixRequest) (*RolesInPrefixResponse, error)
	// Lists packages and subprefixes registered under the prefix.
	//
	// Lists either only direct descendants or recursively all descendants. The
	// result is sorted lexicographically.
	//
	// For example, for packages ["a", "a/b", "a/c/d", "a/c/e/f"], listing of "a"
	// will be:
	//   * {packages: ["a/b"], prefixes: ["a/c"]} if listing non-recursively.
	//   * {packages: ["a/b", "a/c/d", "a/c/e/f"], prefixes: ["a/c", "a/c/e"]} if
	//     listing recursively.
	//
	// Returns only packages and prefixes visible to the caller. This applies even
	// when listing a prefix the caller has no direct read access to. For example,
	// recursively listing the root prefix will return all packages the caller has
	// read access to (no matter when in the hierarchy they are located), even if
	// the caller has no READER permission in the root. It works as if the caller
	// can freely browse the repository that contains only the packages they can
	// see and nothing else.
	ListPrefix(context.Context, *ListPrefixRequest) (*ListPrefixResponse, error)
	// HidePackage marks the package as hidden.
	//
	// This removes it from the ListPrefix results, but doesn't otherwise affect
	// its usage (e.g. it is still fetchable).
	//
	// Requires OWNER role for the package prefix. Returns PERMISSION_DENIED
	// otherwise.
	HidePackage(context.Context, *PackageRequest) (*empty.Empty, error)
	// UnhidePackage marks the package as visible again.
	//
	// It's reverse of HidePackage.
	//
	// Requires OWNER role for the package prefix. Returns PERMISSION_DENIED
	// otherwise.
	UnhidePackage(context.Context, *PackageRequest) (*empty.Empty, error)
	// Registers a package instance in the repository (if it was uploaded to the
	// storage already and wasn't registered yet) or initiates a new upload
	// operation.
	//
	// Callers are expected to execute the following protocol:
	//   1. Attempt to register a package instance by calling RegisterInstance.
	//   2. On NOT_UPLOADED status, upload the package data and finalize the
	//      upload operation using Storage RPC service and upload_op from the
	//      response.
	//   3. Once the upload operation is finalized, call RegisterInstance again,
	//      it should succeed with status REGISTERED now.
	//
	// If such instance is already registered by someone else, returns
	// ALREADY_REGISTERED status. This is not an error.
	//
	// Callers must have roles WRITER or OWNER for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	RegisterInstance(context.Context, *Instance) (*RegisterInstanceResponse, error)
	// Lists instances of a package, most recent first.
	//
	// Callers must have roles READER (or above) for the package prefix. Returns
	// PERMISSION_DENIED otherwise.
	//
	// If the package doesn't exist, returns NOT_FOUND.
	ListInstances(context.Context, *ListInstancesRequest) (*ListInstancesResponse, error)
	// Creates a new ref or moves an existing one.
	//
	// A ref is a mutable named pointer to some existing package instance that
	// can be used as a version identifier. For example, "latest" or "stable".
	//
	// Refs are namespaced to some particular package. E.g. "latest" ref in
	// packages "A" and "B" are completely different entities not related to each
	// other.
	//
	// Pointing a ref to an instance generally makes the instance "discoverable".
	// For that reason the ref can be set only to instances that successfully
	// passed all post-registration processing.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package or the instance the ref points to doesn't exist.
	//   FAILED_PRECONDITION if the instance is still being processed.
	//   ABORTED if the instance has some failed processors associated with it,
	//       such instance is effectively broken and should not be used.
	CreateRef(context.Context, *Ref) (*empty.Empty, error)
	// Removes a ref.
	//
	// Not a failure if there's no such ref.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package doesn't exist.
	DeleteRef(context.Context, *DeleteRefRequest) (*empty.Empty, error)
	// Lists refs defined in a package, most recently modified first.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a READER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package doesn't exist.
	ListRefs(context.Context, *ListRefsRequest) (*ListRefsResponse, error)
	// Attaches one or more tags to an instance.
	//
	// Silently skips already attached tags.
	//
	// Tags are "key:value" pairs associated with a concrete package instance.
	// They can be used for querying registered instances and for version
	// resolution: if a tag is attached to one and only one instance of a package,
	// the tag uniquely identifies this instance and such tag can be used as an
	// alias of the instance ID.
	//
	// Tags generally should be assumed globally namespaced (e.g. it makes sense
	// to query for all registered instances with a given tag, across all
	// packages), and they don't have to be unique: same tag may be attached to
	// multiple instances (of the same or different packages).
	//
	// Additionally, tags (unlike refs) are intended to be mostly static, since
	// they usually relate to some properties of package instances, which are
	// static entities. This is particularity important for tags used for version
	// resolution.
	//
	// Attaching a tag to an instance generally makes the instance "discoverable".
	// For that reason tags can be attached only to instances that successfully
	// passed all post-registration processing.
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a WRITER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package or the instance doesn't exist.
	//   FAILED_PRECONDITION if the instance is still being processed.
	//   ABORTED if the instance has some failed processors associated with it,
	//       such instance is effectively broken and should not be used.
	AttachTags(context.Context, *AttachTagsRequest) (*empty.Empty, error)
	// Detaches one or more tags if they were attached.
	//
	// This call should not be used routinely, since tags are assumed to be
	// static (and thus not detachable).
	//
	// It is occasionally useful for fixing screw ups though. For that reason,
	// DetachTags is allowed only by OWNERS of a prefix (not WRITERS, like
	// AttachTags).
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not an OWNER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if the package or the instance doesn't exist.
	DetachTags(context.Context, *DetachTagsRequest) (*empty.Empty, error)
	// Takes a version string and resolves it into a concrete package instance.
	//
	// A version string can be any of:
	//   * A string-encoded instance ID, e.g. "abcdef....".
	//   * A ref name, e.g. "latest".
	//   * A tag, e.g. "version:1.10.3".
	//
	// Returns:
	//   PERMISSION_DENIED if the caller is not a READER for the prefix.
	//   INVALID_ARGUMENT if the request is malformed.
	//   NOT_FOUND if there's no such package or version.
	//   FAILED_PRECONDITION if the tag resolves to multiple instances.
	ResolveVersion(context.Context, *ResolveVersionRequest) (*Instance, error)
}

func RegisterRepositoryServer(s prpc.Registrar, srv RepositoryServer) {
	s.RegisterService(&_Repository_serviceDesc, srv)
}

func _Repository_GetPrefixMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).GetPrefixMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/GetPrefixMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).GetPrefixMetadata(ctx, req.(*PrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_GetInheritedPrefixMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).GetInheritedPrefixMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/GetInheritedPrefixMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).GetInheritedPrefixMetadata(ctx, req.(*PrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_UpdatePrefixMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).UpdatePrefixMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/UpdatePrefixMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).UpdatePrefixMetadata(ctx, req.(*PrefixMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_GetRolesInPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).GetRolesInPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/GetRolesInPrefix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).GetRolesInPrefix(ctx, req.(*PrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_ListPrefix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPrefixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).ListPrefix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/ListPrefix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).ListPrefix(ctx, req.(*ListPrefixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_HidePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).HidePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/HidePackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).HidePackage(ctx, req.(*PackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_UnhidePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).UnhidePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/UnhidePackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).UnhidePackage(ctx, req.(*PackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_RegisterInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Instance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).RegisterInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/RegisterInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).RegisterInstance(ctx, req.(*Instance))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_ListInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).ListInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/ListInstances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).ListInstances(ctx, req.(*ListInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_CreateRef_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ref)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).CreateRef(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/CreateRef",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).CreateRef(ctx, req.(*Ref))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_DeleteRef_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRefRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).DeleteRef(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/DeleteRef",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).DeleteRef(ctx, req.(*DeleteRefRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_ListRefs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRefsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).ListRefs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/ListRefs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).ListRefs(ctx, req.(*ListRefsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_AttachTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).AttachTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/AttachTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).AttachTags(ctx, req.(*AttachTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_DetachTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).DetachTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/DetachTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).DetachTags(ctx, req.(*DetachTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repository_ResolveVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepositoryServer).ResolveVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Repository/ResolveVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepositoryServer).ResolveVersion(ctx, req.(*ResolveVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Repository_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cipd.Repository",
	HandlerType: (*RepositoryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPrefixMetadata",
			Handler:    _Repository_GetPrefixMetadata_Handler,
		},
		{
			MethodName: "GetInheritedPrefixMetadata",
			Handler:    _Repository_GetInheritedPrefixMetadata_Handler,
		},
		{
			MethodName: "UpdatePrefixMetadata",
			Handler:    _Repository_UpdatePrefixMetadata_Handler,
		},
		{
			MethodName: "GetRolesInPrefix",
			Handler:    _Repository_GetRolesInPrefix_Handler,
		},
		{
			MethodName: "ListPrefix",
			Handler:    _Repository_ListPrefix_Handler,
		},
		{
			MethodName: "HidePackage",
			Handler:    _Repository_HidePackage_Handler,
		},
		{
			MethodName: "UnhidePackage",
			Handler:    _Repository_UnhidePackage_Handler,
		},
		{
			MethodName: "RegisterInstance",
			Handler:    _Repository_RegisterInstance_Handler,
		},
		{
			MethodName: "ListInstances",
			Handler:    _Repository_ListInstances_Handler,
		},
		{
			MethodName: "CreateRef",
			Handler:    _Repository_CreateRef_Handler,
		},
		{
			MethodName: "DeleteRef",
			Handler:    _Repository_DeleteRef_Handler,
		},
		{
			MethodName: "ListRefs",
			Handler:    _Repository_ListRefs_Handler,
		},
		{
			MethodName: "AttachTags",
			Handler:    _Repository_AttachTags_Handler,
		},
		{
			MethodName: "DetachTags",
			Handler:    _Repository_DetachTags_Handler,
		},
		{
			MethodName: "ResolveVersion",
			Handler:    _Repository_ResolveVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/cipd/api/cipd/v1/repo.proto",
}

func init() {
	proto.RegisterFile("go.chromium.org/luci/cipd/api/cipd/v1/repo.proto", fileDescriptor_repo_affa443c330fcf82)
}

var fileDescriptor_repo_affa443c330fcf82 = []byte{
	// 1252 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0x51, 0x73, 0xda, 0x46,
	0x10, 0x2e, 0x06, 0x3b, 0xb0, 0xc4, 0x44, 0xbe, 0x60, 0x47, 0xa3, 0xd4, 0xb1, 0x47, 0x99, 0xb6,
	0x1e, 0x27, 0x85, 0xc4, 0x7d, 0xea, 0x64, 0x92, 0x14, 0x1b, 0xd5, 0x61, 0x4a, 0x8d, 0xe7, 0x2c,
	0x9a, 0x69, 0x5f, 0x34, 0x32, 0x2c, 0xb2, 0x1a, 0x90, 0x54, 0xdd, 0xe1, 0x09, 0xf9, 0x03, 0xfd,
	0x15, 0xfd, 0x07, 0x7d, 0xef, 0x5b, 0x7f, 0x47, 0x7f, 0x4e, 0x47, 0xa7, 0x13, 0x02, 0x01, 0x76,
	0xd2, 0x97, 0xbe, 0xe9, 0xbe, 0xfb, 0xf6, 0x76, 0xf7, 0x76, 0xef, 0x5b, 0xc1, 0x33, 0xc7, 0xaf,
	0xf5, 0xae, 0x42, 0x7f, 0xe4, 0x8e, 0x47, 0x35, 0x3f, 0x74, 0xea, 0xc3, 0x71, 0xcf, 0xad, 0xf7,
	0xdc, 0xa0, 0x5f, 0xb7, 0x03, 0xf9, 0x71, 0xfd, 0xbc, 0x1e, 0x62, 0xe0, 0xd7, 0x82, 0xd0, 0xe7,
	0x3e, 0x29, 0x44, 0x98, 0xf6, 0xd0, 0xf1, 0x7d, 0x67, 0x88, 0x75, 0x81, 0x5d, 0x8e, 0x07, 0x75,
	0x1c, 0x05, 0x7c, 0x12, 0x53, 0xb4, 0xbd, 0xec, 0x26, 0x77, 0x47, 0xc8, 0xb8, 0x3d, 0x0a, 0x24,
	0xa1, 0xfe, 0x71, 0x5e, 0x7b, 0x36, 0x8b, 0x0d, 0xf4, 0xaf, 0x60, 0xf3, 0x3c, 0xc4, 0x81, 0xfb,
	0x9e, 0xe2, 0x6f, 0x63, 0x64, 0x9c, 0xec, 0xc0, 0x46, 0x20, 0x00, 0x35, 0xb7, 0x9f, 0x3b, 0x28,
	0x51, 0xb9, 0xd2, 0xff, 0x58, 0x83, 0x4a, 0xcc, 0xfc, 0x11, 0xb9, 0xdd, 0xb7, 0xb9, 0xbd, 0x8a,
	0x4a, 0xf6, 0xa1, 0x3c, 0x70, 0x3d, 0x07, 0xc3, 0x20, 0x74, 0x3d, 0xae, 0xae, 0x89, 0xcd, 0x59,
	0x88, 0xbc, 0x80, 0xf2, 0x38, 0xe8, 0xdb, 0x1c, 0xad, 0x28, 0x01, 0x35, 0xbf, 0x9f, 0x3b, 0x28,
	0x1f, 0x69, 0xb5, 0x38, 0xbb, 0x5a, 0x92, 0x5d, 0xcd, 0x4c, 0xb2, 0xa3, 0x10, 0xd3, 0x23, 0x80,
	0xec, 0x4d, 0x8d, 0xc7, 0x0c, 0x43, 0xb5, 0x20, 0x8e, 0x97, 0x84, 0x2e, 0xc3, 0x90, 0x3c, 0x85,
	0x82, 0xdd, 0x1b, 0x32, 0x75, 0x7d, 0x3f, 0x7f, 0x50, 0x3e, 0x52, 0x6b, 0x51, 0xd6, 0xb5, 0xf9,
	0xd8, 0x6b, 0x8d, 0x93, 0x36, 0x15, 0x2c, 0xcd, 0x80, 0x7c, 0xe3, 0xa4, 0x4d, 0x1e, 0x41, 0x21,
	0xf4, 0x87, 0x28, 0x52, 0xa9, 0x1c, 0x41, 0x6c, 0x44, 0xfd, 0x21, 0x52, 0x81, 0x93, 0x47, 0x00,
	0x51, 0xec, 0x3d, 0x37, 0xb0, 0x87, 0x4c, 0x5d, 0xdb, 0xcf, 0x47, 0x4e, 0x53, 0x44, 0xb7, 0xe0,
	0x41, 0xcb, 0xbb, 0xc2, 0xd0, 0xe5, 0xd8, 0xcf, 0xdc, 0x53, 0x13, 0xee, 0x07, 0x18, 0x5a, 0xf1,
	0xed, 0x58, 0x23, 0x09, 0xab, 0x39, 0x11, 0x5e, 0x75, 0x59, 0x78, 0x74, 0x2b, 0xc0, 0x70, 0x1e,
	0xd2, 0x7f, 0xcf, 0xc1, 0x76, 0x14, 0x0f, 0x6b, 0x79, 0x49, 0xc5, 0x58, 0xe0, 0x7b, 0x0c, 0xc9,
	0x2b, 0x58, 0x8f, 0x42, 0x64, 0xf2, 0xc4, 0x83, 0x34, 0xf6, 0x05, 0xae, 0x40, 0xa7, 0x60, 0x6c,
	0xa6, 0xd5, 0xe0, 0xee, 0x2c, 0x7c, 0xdb, 0x55, 0xe8, 0x01, 0x6c, 0xb5, 0x5d, 0xc6, 0x3f, 0xaa,
	0x6f, 0xc8, 0xe7, 0x50, 0x0a, 0xb1, 0x37, 0x0e, 0x99, 0x7b, 0x8d, 0xa2, 0x15, 0x8a, 0x34, 0x05,
	0xc8, 0x17, 0x50, 0x71, 0xbd, 0xde, 0x70, 0xdc, 0x47, 0xeb, 0xca, 0xed, 0xf7, 0xd1, 0x13, 0xbd,
	0x50, 0xa4, 0x9b, 0x12, 0x7d, 0x23, 0x40, 0xbd, 0x0d, 0x64, 0xd6, 0xa3, 0xcc, 0x5b, 0x83, 0x62,
	0x60, 0xf7, 0xde, 0xd9, 0x8e, 0x4c, 0xbd, 0x44, 0xa7, 0x6b, 0xb1, 0x27, 0xd8, 0x98, 0x14, 0x6b,
	0xba, 0xd6, 0x0f, 0xa1, 0x72, 0x1e, 0xf3, 0x92, 0xe0, 0x55, 0xb8, 0x23, 0x2d, 0x65, 0xf4, 0xc9,
	0x52, 0xff, 0x2b, 0x07, 0xc5, 0x96, 0xc7, 0xb8, 0xed, 0xf5, 0x70, 0x35, 0x8d, 0x3c, 0x81, 0xa2,
	0x2b, 0x59, 0x22, 0xc9, 0xf2, 0xd1, 0xbd, 0xf8, 0xda, 0x3a, 0x97, 0xbf, 0x62, 0x8f, 0x53, 0x1c,
	0xd0, 0x29, 0x81, 0x3c, 0x86, 0xcd, 0x10, 0x1d, 0x97, 0x71, 0x0c, 0xb1, 0x6f, 0x5d, 0x4e, 0x44,
	0xce, 0x25, 0x7a, 0x37, 0x05, 0x8f, 0x27, 0xe4, 0xf5, 0x1c, 0x89, 0x33, 0xd1, 0xe7, 0x37, 0x3f,
	0x92, 0x99, 0x03, 0x4c, 0xa6, 0xff, 0x99, 0x03, 0x95, 0x4a, 0x20, 0xc9, 0x60, 0x7a, 0x75, 0xcf,
	0x60, 0x83, 0x71, 0x9b, 0x8f, 0x99, 0x2c, 0xb2, 0x7c, 0x24, 0x31, 0x3f, 0xb4, 0xb9, 0xeb, 0x7b,
	0x17, 0x62, 0x9f, 0x4a, 0x1e, 0x39, 0x5c, 0xc8, 0xb0, 0x12, 0xdb, 0x4c, 0xcf, 0x4e, 0x13, 0x3c,
	0x82, 0xd2, 0x38, 0x18, 0xfa, 0x76, 0xdf, 0xf2, 0x03, 0xf9, 0xb8, 0xb7, 0x63, 0x72, 0x57, 0xc0,
	0x9d, 0x00, 0x63, 0x1f, 0xb4, 0x38, 0x96, 0x80, 0x3e, 0x84, 0x6a, 0x54, 0xe2, 0xe4, 0x34, 0x76,
	0x6b, 0x69, 0xc8, 0x43, 0x28, 0x05, 0xb6, 0x83, 0x16, 0x73, 0x3f, 0xa0, 0x5a, 0xdd, 0xcf, 0x1d,
	0xac, 0x47, 0xf5, 0x77, 0xf0, 0xc2, 0xfd, 0x80, 0x64, 0x17, 0x40, 0x6c, 0x72, 0xff, 0x1d, 0x7a,
	0xea, 0xb6, 0xb0, 0x14, 0x74, 0x33, 0x02, 0xf4, 0x11, 0x6c, 0x67, 0xbc, 0xc9, 0x8b, 0x79, 0x0a,
	0xa5, 0x24, 0x8d, 0xe4, 0x3d, 0x65, 0xf3, 0x4c, 0x09, 0xe4, 0x4b, 0xb8, 0xe7, 0xe1, 0x7b, 0x6e,
	0xcd, 0xb8, 0xaa, 0x0a, 0x57, 0x9b, 0x11, 0x7c, 0x3e, 0x75, 0xf7, 0x77, 0x0e, 0xf2, 0x14, 0x07,
	0x84, 0x40, 0xc1, 0xb3, 0x47, 0x49, 0x26, 0xe2, 0x7b, 0x36, 0xc1, 0xb5, 0xd5, 0x4d, 0x95, 0xbf,
	0xad, 0xa9, 0xf6, 0xa0, 0x3c, 0xf2, 0xfb, 0xee, 0xc0, 0x8d, 0x5b, 0x4a, 0xaa, 0x62, 0x02, 0x1d,
	0x4f, 0x22, 0xcd, 0x9d, 0x12, 0x78, 0x24, 0x8e, 0xb7, 0x6a, 0x6e, 0x42, 0x37, 0x99, 0xfe, 0x1d,
	0x28, 0x4d, 0x1c, 0x22, 0xc7, 0xc8, 0xa9, 0xac, 0xcc, 0x27, 0x25, 0xa3, 0x3f, 0x81, 0x7b, 0xd1,
	0x8d, 0x53, 0x1c, 0xdc, 0x5e, 0x5a, 0xfd, 0x39, 0x28, 0x29, 0x59, 0x56, 0x66, 0x17, 0x0a, 0x21,
	0x0e, 0x92, 0xa2, 0x94, 0x92, 0x86, 0x1d, 0x50, 0x01, 0xeb, 0x5f, 0x43, 0xde, 0xb4, 0x1d, 0xa2,
	0x40, 0xfe, 0x1d, 0x4e, 0xe4, 0x79, 0xd1, 0x27, 0xa9, 0xc2, 0xfa, 0xb5, 0x3d, 0x1c, 0x27, 0x01,
	0xc5, 0x0b, 0x7d, 0x02, 0x5b, 0x0d, 0xce, 0xed, 0xde, 0x95, 0x69, 0x3b, 0x1f, 0xd1, 0x6b, 0x9f,
	0xf4, 0xbe, 0x77, 0xa1, 0xc0, 0x6d, 0x87, 0xa9, 0xf9, 0xd9, 0x48, 0x4d, 0xdb, 0xa1, 0x02, 0x8e,
	0x5c, 0x37, 0xf1, 0xff, 0x71, 0xfd, 0x03, 0x6c, 0x53, 0x64, 0xfe, 0xf0, 0x1a, 0x7f, 0xc2, 0x90,
	0x45, 0x0f, 0xf0, 0x56, 0xf7, 0x2a, 0xdc, 0xb9, 0x8e, 0xb9, 0x49, 0x45, 0xe5, 0xf2, 0xf0, 0x35,
	0x14, 0xa2, 0xa1, 0x40, 0xaa, 0xa0, 0xd0, 0x4e, 0xdb, 0xb0, 0xba, 0x67, 0x17, 0xe7, 0xc6, 0x49,
	0xeb, 0xfb, 0x96, 0xd1, 0x54, 0x3e, 0x23, 0x00, 0x1b, 0xd4, 0x68, 0x34, 0x0d, 0xaa, 0xe4, 0xa2,
	0xef, 0xb7, 0xb4, 0x65, 0x1a, 0x54, 0x59, 0x23, 0x25, 0x58, 0xef, 0xbc, 0x3d, 0x33, 0xa8, 0x92,
	0x3f, 0x64, 0x40, 0x16, 0x05, 0x87, 0x3c, 0x86, 0x3d, 0x6a, 0x9c, 0xb6, 0x2e, 0x4c, 0xda, 0x30,
	0x5b, 0x9d, 0x33, 0xeb, 0xc2, 0x6c, 0x98, 0xdd, 0x8b, 0xcc, 0xe9, 0x15, 0x80, 0x98, 0x64, 0x50,
	0xa3, 0xa9, 0xe4, 0xc8, 0x0e, 0x90, 0x46, 0x3b, 0xf2, 0xf7, 0xb3, 0x35, 0x83, 0xaf, 0x11, 0x05,
	0xee, 0x9e, 0x75, 0x4c, 0xab, 0x7b, 0xde, 0xee, 0x34, 0x9a, 0x46, 0x53, 0xc9, 0x1f, 0xfd, 0x73,
	0x07, 0x80, 0x62, 0xe0, 0x33, 0x97, 0xfb, 0xe1, 0x84, 0xbc, 0x82, 0xad, 0x53, 0xe4, 0x99, 0x81,
	0x7d, 0x7f, 0x76, 0x26, 0xcb, 0x2b, 0xd2, 0x96, 0x0e, 0x6a, 0x72, 0x0e, 0xda, 0x29, 0xf2, 0x55,
	0x93, 0x7f, 0xe9, 0x41, 0xbb, 0x89, 0x9e, 0x2c, 0xb7, 0x39, 0x86, 0x6a, 0x57, 0xfc, 0xcb, 0x64,
	0xf0, 0xa5, 0xfe, 0x57, 0x44, 0xd5, 0x04, 0xe5, 0x14, 0xf9, 0xdc, 0x1f, 0xc0, 0xf2, 0x58, 0x1e,
	0xde, 0xf0, 0xaf, 0x40, 0x5e, 0x03, 0xa4, 0x53, 0x97, 0x3c, 0x88, 0xa9, 0x0b, 0x93, 0x5f, 0x53,
	0x17, 0x37, 0xe4, 0x01, 0x2f, 0xa0, 0xfc, 0xc6, 0xed, 0xa3, 0x1c, 0xb6, 0xd3, 0x0c, 0xe6, 0x66,
	0xaf, 0xb6, 0xb3, 0x20, 0x41, 0x46, 0xf4, 0xc7, 0x4b, 0x5e, 0xc2, 0x66, 0xd7, 0xbb, 0xfa, 0xcf,
	0xe6, 0xc7, 0xa0, 0x64, 0xa7, 0x1f, 0xc9, 0x28, 0xb9, 0xf6, 0x68, 0x76, 0xea, 0x2d, 0x99, 0x92,
	0x6f, 0x60, 0x73, 0x6e, 0x4a, 0x10, 0x2d, 0x4d, 0x35, 0x3b, 0xa8, 0x92, 0xab, 0x5c, 0x3e, 0x56,
	0x6a, 0x50, 0x3a, 0x09, 0xd1, 0x16, 0xfa, 0x49, 0x52, 0xed, 0x5a, 0x19, 0xfd, 0x0b, 0x28, 0x4d,
	0xf5, 0x96, 0xec, 0xc4, 0xfc, 0xac, 0x00, 0xaf, 0x34, 0xfe, 0x16, 0x8a, 0x89, 0x7a, 0x92, 0xed,
	0x34, 0xaa, 0x19, 0xe9, 0xd5, 0x76, 0xb2, 0xb0, 0x8c, 0xf3, 0x25, 0x40, 0x2a, 0x8b, 0x49, 0xc9,
	0x17, 0x84, 0xf2, 0x86, 0x9a, 0x41, 0x2a, 0x6d, 0x89, 0xf9, 0x82, 0xd8, 0xdd, 0x60, 0x5e, 0x99,
	0x97, 0x27, 0x92, 0xf4, 0xe7, 0x32, 0xd1, 0xd2, 0x32, 0xe5, 0x3c, 0x5e, 0xff, 0x25, 0x6f, 0x07,
	0xee, 0xe5, 0x86, 0x38, 0xf5, 0x9b, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xa2, 0x73, 0x8c, 0x10,
	0x82, 0x0d, 0x00, 0x00,
}
