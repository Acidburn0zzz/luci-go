// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/cipd/api/cipd/v1/cas.proto

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	go.chromium.org/luci/cipd/api/cipd/v1/cas.proto
	go.chromium.org/luci/cipd/api/cipd/v1/repo.proto

It has these top-level messages:
	ObjectRef
	GetObjectURLRequest
	ObjectURL
	BeginUploadRequest
	FinishUploadRequest
	UploadOperation
	PrefixRequest
	PrefixMetadata
	InheritedPrefixMetadata
*/
package api

import prpc "go.chromium.org/luci/grpc/prpc"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Supported hashing algorithms used by the content-addressable storage.
//
// Literal names are important, since they are used to construct Google Storage
// paths internally.
type HashAlgo int32

const (
	HashAlgo_HASH_ALGO_UNSPECIFIED HashAlgo = 0
	HashAlgo_SHA1                  HashAlgo = 1
)

var HashAlgo_name = map[int32]string{
	0: "HASH_ALGO_UNSPECIFIED",
	1: "SHA1",
}
var HashAlgo_value = map[string]int32{
	"HASH_ALGO_UNSPECIFIED": 0,
	"SHA1":                  1,
}

func (x HashAlgo) String() string {
	return proto.EnumName(HashAlgo_name, int32(x))
}
func (HashAlgo) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type UploadStatus int32

const (
	UploadStatus_UPLOAD_STATUS_UNSPECIFIED UploadStatus = 0
	UploadStatus_UPLOADING                 UploadStatus = 1
	UploadStatus_VERIFYING                 UploadStatus = 2
	UploadStatus_PUBLISHED                 UploadStatus = 3
	UploadStatus_ERRORED                   UploadStatus = 4
)

var UploadStatus_name = map[int32]string{
	0: "UPLOAD_STATUS_UNSPECIFIED",
	1: "UPLOADING",
	2: "VERIFYING",
	3: "PUBLISHED",
	4: "ERRORED",
}
var UploadStatus_value = map[string]int32{
	"UPLOAD_STATUS_UNSPECIFIED": 0,
	"UPLOADING":                 1,
	"VERIFYING":                 2,
	"PUBLISHED":                 3,
	"ERRORED":                   4,
}

func (x UploadStatus) String() string {
	return proto.EnumName(UploadStatus_name, int32(x))
}
func (UploadStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// A reference to an object in the content-addressable storage.
type ObjectRef struct {
	HashAlgo  HashAlgo `protobuf:"varint,1,opt,name=hash_algo,json=hashAlgo,enum=cipd.HashAlgo" json:"hash_algo,omitempty"`
	HexDigest string   `protobuf:"bytes,2,opt,name=hex_digest,json=hexDigest" json:"hex_digest,omitempty"`
}

func (m *ObjectRef) Reset()                    { *m = ObjectRef{} }
func (m *ObjectRef) String() string            { return proto.CompactTextString(m) }
func (*ObjectRef) ProtoMessage()               {}
func (*ObjectRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ObjectRef) GetHashAlgo() HashAlgo {
	if m != nil {
		return m.HashAlgo
	}
	return HashAlgo_HASH_ALGO_UNSPECIFIED
}

func (m *ObjectRef) GetHexDigest() string {
	if m != nil {
		return m.HexDigest
	}
	return ""
}

type GetObjectURLRequest struct {
	// A reference to the object the client wants to fetch.
	Object *ObjectRef `protobuf:"bytes,1,opt,name=object" json:"object,omitempty"`
	// If present, the returned URL will be served with Content-Disposition header
	// that includes the given filename. It makes browsers save the file under the
	// given name.
	DownloadFilename string `protobuf:"bytes,2,opt,name=download_filename,json=downloadFilename" json:"download_filename,omitempty"`
}

func (m *GetObjectURLRequest) Reset()                    { *m = GetObjectURLRequest{} }
func (m *GetObjectURLRequest) String() string            { return proto.CompactTextString(m) }
func (*GetObjectURLRequest) ProtoMessage()               {}
func (*GetObjectURLRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *GetObjectURLRequest) GetObject() *ObjectRef {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *GetObjectURLRequest) GetDownloadFilename() string {
	if m != nil {
		return m.DownloadFilename
	}
	return ""
}

type ObjectURL struct {
	// A signed HTTPS URL to the object's body.
	//
	// Fetching it doesn't require authentication. Expires after some unspecified
	// short amount of time. It is expected that callers will use it immediately.
	//
	// The URL isn't guaranteed to have any particular internal structure. Do not
	// attempt to parse it.
	SignedUrl string `protobuf:"bytes,1,opt,name=signed_url,json=signedUrl" json:"signed_url,omitempty"`
}

func (m *ObjectURL) Reset()                    { *m = ObjectURL{} }
func (m *ObjectURL) String() string            { return proto.CompactTextString(m) }
func (*ObjectURL) ProtoMessage()               {}
func (*ObjectURL) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ObjectURL) GetSignedUrl() string {
	if m != nil {
		return m.SignedUrl
	}
	return ""
}

type BeginUploadRequest struct {
	// A reference to the object the client wants to put in the storage, if known.
	//
	// If such object already exists, RPC will finish with ALREADY_EXISTS status
	// right away.
	//
	// If this field is missing (in case the client doesn't know the hash yet),
	// the client MUST supply hash_algo field, to let the backend know what
	// hashing algorithm it should use for calculating object's hash.
	//
	// The calculated hash will be returned back to the client as part of
	// UploadOperation ('object' field) by FinishUpload call.
	Object *ObjectRef `protobuf:"bytes,1,opt,name=object" json:"object,omitempty"`
	// An algorithm to use to derive object's name during uploads when the final
	// hash of the object is not yet known.
	//
	// Optional if 'object' is present.
	//
	// If both 'object' and 'hash_algo' are present, 'object.hash_algo' MUST match
	// 'hash_algo'.
	HashAlgo HashAlgo `protobuf:"varint,2,opt,name=hash_algo,json=hashAlgo,enum=cipd.HashAlgo" json:"hash_algo,omitempty"`
}

func (m *BeginUploadRequest) Reset()                    { *m = BeginUploadRequest{} }
func (m *BeginUploadRequest) String() string            { return proto.CompactTextString(m) }
func (*BeginUploadRequest) ProtoMessage()               {}
func (*BeginUploadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *BeginUploadRequest) GetObject() *ObjectRef {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *BeginUploadRequest) GetHashAlgo() HashAlgo {
	if m != nil {
		return m.HashAlgo
	}
	return HashAlgo_HASH_ALGO_UNSPECIFIED
}

type FinishUploadRequest struct {
	// An identifier of an upload operation returned by BeginUpload RPC.
	UploadOperationId string `protobuf:"bytes,1,opt,name=upload_operation_id,json=uploadOperationId" json:"upload_operation_id,omitempty"`
	// If set, instructs Storage to skip the hash verification and just assume the
	// uploaded object has the given hash.
	//
	// This is used internally by the service as an optimization for cases when
	// it trusts the uploaded data (for example, when it upload it itself).
	//
	// External callers are denied usage of this field. Attempt to use it results
	// in PERMISSION_DENIED.
	ForceHash *ObjectRef `protobuf:"bytes,2,opt,name=force_hash,json=forceHash" json:"force_hash,omitempty"`
}

func (m *FinishUploadRequest) Reset()                    { *m = FinishUploadRequest{} }
func (m *FinishUploadRequest) String() string            { return proto.CompactTextString(m) }
func (*FinishUploadRequest) ProtoMessage()               {}
func (*FinishUploadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *FinishUploadRequest) GetUploadOperationId() string {
	if m != nil {
		return m.UploadOperationId
	}
	return ""
}

func (m *FinishUploadRequest) GetForceHash() *ObjectRef {
	if m != nil {
		return m.ForceHash
	}
	return nil
}

type UploadOperation struct {
	// An opaque string that identifies this upload operation.
	//
	// It acts as a temporary authorization token for FinishUpload RPC. Treat it
	// as a secret.
	OperationId string `protobuf:"bytes,1,opt,name=operation_id,json=operationId" json:"operation_id,omitempty"`
	// URL the client should use in Google Storage Resumable Upload protocol to
	// upload the object's body.
	//
	// No authentication is required to upload data to this URL, so it also should
	// be treated as a secret.
	UploadUrl string `protobuf:"bytes,2,opt,name=upload_url,json=uploadUrl" json:"upload_url,omitempty"`
	// Status of the upload operation.
	Status UploadStatus `protobuf:"varint,3,opt,name=status,enum=cipd.UploadStatus" json:"status,omitempty"`
	// For PUBLISHED status, the reference to the published object.
	//
	// This is in particular useful for uploads when the hash of the object is not
	// known until the upload is finished.
	Object *ObjectRef `protobuf:"bytes,4,opt,name=object" json:"object,omitempty"`
	// For ERRORED status, a human readable error message.
	ErrorMessage string `protobuf:"bytes,5,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
}

func (m *UploadOperation) Reset()                    { *m = UploadOperation{} }
func (m *UploadOperation) String() string            { return proto.CompactTextString(m) }
func (*UploadOperation) ProtoMessage()               {}
func (*UploadOperation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *UploadOperation) GetOperationId() string {
	if m != nil {
		return m.OperationId
	}
	return ""
}

func (m *UploadOperation) GetUploadUrl() string {
	if m != nil {
		return m.UploadUrl
	}
	return ""
}

func (m *UploadOperation) GetStatus() UploadStatus {
	if m != nil {
		return m.Status
	}
	return UploadStatus_UPLOAD_STATUS_UNSPECIFIED
}

func (m *UploadOperation) GetObject() *ObjectRef {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *UploadOperation) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func init() {
	proto.RegisterType((*ObjectRef)(nil), "cipd.ObjectRef")
	proto.RegisterType((*GetObjectURLRequest)(nil), "cipd.GetObjectURLRequest")
	proto.RegisterType((*ObjectURL)(nil), "cipd.ObjectURL")
	proto.RegisterType((*BeginUploadRequest)(nil), "cipd.BeginUploadRequest")
	proto.RegisterType((*FinishUploadRequest)(nil), "cipd.FinishUploadRequest")
	proto.RegisterType((*UploadOperation)(nil), "cipd.UploadOperation")
	proto.RegisterEnum("cipd.HashAlgo", HashAlgo_name, HashAlgo_value)
	proto.RegisterEnum("cipd.UploadStatus", UploadStatus_name, UploadStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Storage service

type StorageClient interface {
	// Produces a signed URL that can be used to fetch an object.
	//
	// Returns NOT_FOUND status code if there's no such object.
	GetObjectURL(ctx context.Context, in *GetObjectURLRequest, opts ...grpc.CallOption) (*ObjectURL, error)
	// Initiates an upload operation.
	//
	// Once the upload is initiated the client is responsible for uploading the
	// object to the temporary location (provided via 'upload_url' which should be
	// used as an upload URL in Google Storage Resumable Upload protocol) and
	// finishing the upload with a call to FinishUpload, which will launch
	// the verification of the object's hash on the server side.
	//
	// If the client knows the hash of the object it wants to upload already, it
	// can provide it via 'object' field. In that case Storage may reply right
	// away that such object already exists by retuning ALREADY_EXISTS status
	// code.
	//
	// If the client doesn't know the hash yet (perhaps if the object's body is
	// generated on the fly), it still can open an upload operation and start
	// streaming the data. When finalizing the upload the backend will calculate
	// and return the resulting hash of the object.
	//
	// An UploadOperation returned by this method contains tokens that grant
	// direct upload access to whoever possesses them, so it should be treated as
	// a secret. See UploadOperation for more info.
	BeginUpload(ctx context.Context, in *BeginUploadRequest, opts ...grpc.CallOption) (*UploadOperation, error)
	// Finishes the pending upload operation, returning its new status.
	//
	// Clients are expected to finish Google Storage Resumable protocol first
	// before calling FinishUpload. Failure to do so will cause the upload
	// operation to end up in ERROR state.
	//
	// This call is idempotent and it is expected that clients will keep polling
	// it if they want to wait for the server to verify the hash of the uploaded
	// object.
	//
	// Returns NOT_FOUND if the provided upload operation doesn't exist.
	//
	// Errors related to the uploaded file body are communicated through 'status'
	// field of the upload operation, since they are not directly related to this
	// RPC call, but rather to the upload operation itself.
	FinishUpload(ctx context.Context, in *FinishUploadRequest, opts ...grpc.CallOption) (*UploadOperation, error)
}
type storagePRPCClient struct {
	client *prpc.Client
}

func NewStoragePRPCClient(client *prpc.Client) StorageClient {
	return &storagePRPCClient{client}
}

func (c *storagePRPCClient) GetObjectURL(ctx context.Context, in *GetObjectURLRequest, opts ...grpc.CallOption) (*ObjectURL, error) {
	out := new(ObjectURL)
	err := c.client.Call(ctx, "cipd.Storage", "GetObjectURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePRPCClient) BeginUpload(ctx context.Context, in *BeginUploadRequest, opts ...grpc.CallOption) (*UploadOperation, error) {
	out := new(UploadOperation)
	err := c.client.Call(ctx, "cipd.Storage", "BeginUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePRPCClient) FinishUpload(ctx context.Context, in *FinishUploadRequest, opts ...grpc.CallOption) (*UploadOperation, error) {
	out := new(UploadOperation)
	err := c.client.Call(ctx, "cipd.Storage", "FinishUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type storageClient struct {
	cc *grpc.ClientConn
}

func NewStorageClient(cc *grpc.ClientConn) StorageClient {
	return &storageClient{cc}
}

func (c *storageClient) GetObjectURL(ctx context.Context, in *GetObjectURLRequest, opts ...grpc.CallOption) (*ObjectURL, error) {
	out := new(ObjectURL)
	err := grpc.Invoke(ctx, "/cipd.Storage/GetObjectURL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) BeginUpload(ctx context.Context, in *BeginUploadRequest, opts ...grpc.CallOption) (*UploadOperation, error) {
	out := new(UploadOperation)
	err := grpc.Invoke(ctx, "/cipd.Storage/BeginUpload", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) FinishUpload(ctx context.Context, in *FinishUploadRequest, opts ...grpc.CallOption) (*UploadOperation, error) {
	out := new(UploadOperation)
	err := grpc.Invoke(ctx, "/cipd.Storage/FinishUpload", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Storage service

type StorageServer interface {
	// Produces a signed URL that can be used to fetch an object.
	//
	// Returns NOT_FOUND status code if there's no such object.
	GetObjectURL(context.Context, *GetObjectURLRequest) (*ObjectURL, error)
	// Initiates an upload operation.
	//
	// Once the upload is initiated the client is responsible for uploading the
	// object to the temporary location (provided via 'upload_url' which should be
	// used as an upload URL in Google Storage Resumable Upload protocol) and
	// finishing the upload with a call to FinishUpload, which will launch
	// the verification of the object's hash on the server side.
	//
	// If the client knows the hash of the object it wants to upload already, it
	// can provide it via 'object' field. In that case Storage may reply right
	// away that such object already exists by retuning ALREADY_EXISTS status
	// code.
	//
	// If the client doesn't know the hash yet (perhaps if the object's body is
	// generated on the fly), it still can open an upload operation and start
	// streaming the data. When finalizing the upload the backend will calculate
	// and return the resulting hash of the object.
	//
	// An UploadOperation returned by this method contains tokens that grant
	// direct upload access to whoever possesses them, so it should be treated as
	// a secret. See UploadOperation for more info.
	BeginUpload(context.Context, *BeginUploadRequest) (*UploadOperation, error)
	// Finishes the pending upload operation, returning its new status.
	//
	// Clients are expected to finish Google Storage Resumable protocol first
	// before calling FinishUpload. Failure to do so will cause the upload
	// operation to end up in ERROR state.
	//
	// This call is idempotent and it is expected that clients will keep polling
	// it if they want to wait for the server to verify the hash of the uploaded
	// object.
	//
	// Returns NOT_FOUND if the provided upload operation doesn't exist.
	//
	// Errors related to the uploaded file body are communicated through 'status'
	// field of the upload operation, since they are not directly related to this
	// RPC call, but rather to the upload operation itself.
	FinishUpload(context.Context, *FinishUploadRequest) (*UploadOperation, error)
}

func RegisterStorageServer(s prpc.Registrar, srv StorageServer) {
	s.RegisterService(&_Storage_serviceDesc, srv)
}

func _Storage_GetObjectURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetObjectURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).GetObjectURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Storage/GetObjectURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).GetObjectURL(ctx, req.(*GetObjectURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_BeginUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BeginUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).BeginUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Storage/BeginUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).BeginUpload(ctx, req.(*BeginUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_FinishUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishUploadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).FinishUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cipd.Storage/FinishUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).FinishUpload(ctx, req.(*FinishUploadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Storage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cipd.Storage",
	HandlerType: (*StorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetObjectURL",
			Handler:    _Storage_GetObjectURL_Handler,
		},
		{
			MethodName: "BeginUpload",
			Handler:    _Storage_BeginUpload_Handler,
		},
		{
			MethodName: "FinishUpload",
			Handler:    _Storage_FinishUpload_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/cipd/api/cipd/v1/cas.proto",
}

func init() { proto.RegisterFile("go.chromium.org/luci/cipd/api/cipd/v1/cas.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 567 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0x4f, 0x6f, 0x9b, 0x4e,
	0x14, 0xfc, 0x91, 0x38, 0x7f, 0x78, 0x76, 0x12, 0xb2, 0x51, 0x24, 0x27, 0x52, 0xa4, 0xfc, 0xe8,
	0xa1, 0x91, 0x23, 0x81, 0x92, 0xde, 0x7a, 0xa8, 0x4a, 0x6a, 0x1c, 0x23, 0xb9, 0x71, 0xb4, 0x84,
	0x56, 0xed, 0x05, 0x6d, 0x60, 0x0d, 0x9b, 0x62, 0x96, 0x2e, 0xd0, 0xe6, 0x1b, 0xf6, 0xd4, 0xef,
	0x54, 0xb1, 0xe0, 0x16, 0xb7, 0x6e, 0x0e, 0xbd, 0xb1, 0x33, 0xcf, 0x33, 0xb3, 0xc3, 0x33, 0x60,
	0x46, 0xdc, 0x08, 0x62, 0xc1, 0xe7, 0xac, 0x9c, 0x1b, 0x5c, 0x44, 0x66, 0x52, 0x06, 0xcc, 0x0c,
	0x58, 0x16, 0x9a, 0x24, 0x6b, 0x1e, 0xbe, 0x5c, 0x98, 0x01, 0xc9, 0x8d, 0x4c, 0xf0, 0x82, 0xa3,
	0x4e, 0x05, 0xe9, 0xef, 0x41, 0x9d, 0xde, 0x3f, 0xd0, 0xa0, 0xc0, 0x74, 0x86, 0xce, 0x41, 0x8d,
	0x49, 0x1e, 0xfb, 0x24, 0x89, 0x78, 0x5f, 0x39, 0x55, 0xce, 0x76, 0x2f, 0x77, 0x8d, 0x6a, 0xcc,
	0x18, 0x93, 0x3c, 0xb6, 0x92, 0x88, 0xe3, 0xed, 0xb8, 0x79, 0x42, 0x27, 0x00, 0x31, 0x7d, 0xf4,
	0x43, 0x16, 0xd1, 0xbc, 0xe8, 0xaf, 0x9d, 0x2a, 0x67, 0x2a, 0x56, 0x63, 0xfa, 0x38, 0x94, 0x80,
	0xfe, 0x09, 0x0e, 0xae, 0x69, 0x51, 0x6b, 0x7b, 0x78, 0x82, 0xe9, 0xe7, 0x92, 0xe6, 0x05, 0x7a,
	0x0e, 0x9b, 0x5c, 0x62, 0x52, 0xbf, 0x7b, 0xb9, 0x57, 0xeb, 0xff, 0xcc, 0x80, 0x1b, 0x1a, 0x9d,
	0xc3, 0x7e, 0xc8, 0xbf, 0xa6, 0x09, 0x27, 0xa1, 0x3f, 0x63, 0x09, 0x4d, 0xc9, 0x9c, 0x36, 0x2e,
	0xda, 0x82, 0x18, 0x35, 0xb8, 0x3e, 0x58, 0xdc, 0xc2, 0xc3, 0x93, 0x2a, 0x58, 0xce, 0xa2, 0x94,
	0x86, 0x7e, 0x29, 0x12, 0x69, 0xa3, 0x62, 0xb5, 0x46, 0x3c, 0x91, 0xe8, 0x0f, 0x80, 0xae, 0x68,
	0xc4, 0x52, 0x2f, 0xab, 0x24, 0xfe, 0x21, 0x57, 0xab, 0xa3, 0xb5, 0xa7, 0x3b, 0xd2, 0x4b, 0x38,
	0x18, 0xb1, 0x94, 0xe5, 0xf1, 0xb2, 0x99, 0x01, 0x07, 0xa5, 0x04, 0x7c, 0x9e, 0x51, 0x41, 0x0a,
	0xc6, 0x53, 0x9f, 0x85, 0x4d, 0xd4, 0xfd, 0x9a, 0x9a, 0x2e, 0x18, 0x27, 0x44, 0x06, 0xc0, 0x8c,
	0x8b, 0x80, 0xfa, 0x95, 0xb0, 0x34, 0x5d, 0x11, 0x50, 0x95, 0x23, 0x55, 0x08, 0xfd, 0xbb, 0x02,
	0x7b, 0xde, 0xb2, 0x0a, 0xfa, 0x1f, 0x7a, 0x2b, 0xcc, 0xba, 0xbc, 0x65, 0x73, 0x02, 0xd0, 0xc4,
	0xaa, 0x8a, 0x6b, 0xde, 0x68, 0x8d, 0x78, 0x22, 0x41, 0x03, 0xd8, 0xcc, 0x0b, 0x52, 0x94, 0x79,
	0x7f, 0x5d, 0x5e, 0x1b, 0xd5, 0x09, 0x6a, 0x23, 0x57, 0x32, 0xb8, 0x99, 0x68, 0xd5, 0xd9, 0x79,
	0xba, 0xce, 0x67, 0xb0, 0x43, 0x85, 0xe0, 0xc2, 0x9f, 0xd3, 0x3c, 0x27, 0x11, 0xed, 0x6f, 0x48,
	0xdb, 0x9e, 0x04, 0xdf, 0xd6, 0xd8, 0xc0, 0x84, 0xed, 0x45, 0xb9, 0xe8, 0x08, 0x0e, 0xc7, 0x96,
	0x3b, 0xf6, 0xad, 0xc9, 0xf5, 0xd4, 0xf7, 0x6e, 0xdc, 0x5b, 0xfb, 0x8d, 0x33, 0x72, 0xec, 0xa1,
	0xf6, 0x1f, 0xda, 0x86, 0x8e, 0x3b, 0xb6, 0x2e, 0x34, 0x65, 0x10, 0x41, 0xaf, 0x1d, 0x0b, 0x9d,
	0xc0, 0x91, 0x77, 0x3b, 0x99, 0x5a, 0x43, 0xdf, 0xbd, 0xb3, 0xee, 0x3c, 0xf7, 0xb7, 0x1f, 0xee,
	0x80, 0x5a, 0xd3, 0xce, 0xcd, 0xb5, 0xa6, 0x54, 0xc7, 0x77, 0x36, 0x76, 0x46, 0x1f, 0xaa, 0xe3,
	0x5a, 0x75, 0xbc, 0xf5, 0xae, 0x26, 0x8e, 0x3b, 0xb6, 0x87, 0xda, 0x3a, 0xea, 0xc2, 0x96, 0x8d,
	0xf1, 0x14, 0xdb, 0x43, 0xad, 0x73, 0xf9, 0x4d, 0x81, 0x2d, 0xb7, 0xe0, 0x82, 0x44, 0x14, 0xbd,
	0x84, 0x5e, 0x7b, 0xe3, 0xd1, 0x51, 0x7d, 0xe7, 0x15, 0xff, 0x82, 0xe3, 0xa5, 0x3a, 0xaa, 0xd9,
	0x57, 0xd0, 0x6d, 0x2d, 0x25, 0xea, 0xd7, 0xfc, 0x9f, 0x7b, 0x7a, 0x7c, 0xd8, 0x2e, 0xfd, 0xd7,
	0xdb, 0x7d, 0x0d, 0xbd, 0xf6, 0xa2, 0x2d, 0xbc, 0x57, 0x2c, 0xdf, 0x5f, 0x14, 0xae, 0x36, 0x3e,
	0xae, 0x93, 0x8c, 0xdd, 0x6f, 0xca, 0x8f, 0xc3, 0x8b, 0x1f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x5f,
	0x8b, 0x12, 0xf2, 0x4f, 0x04, 0x00, 0x00,
}
