// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Package main reads a service interface XYZServer generated by protoc
// and generates XYZVersionedServer that stores a map version->implementation,
// and a default version. Each method forwards a request to the implementation
// of the requested version.
//
// Example of usage:
// 	//go:generate svcmux -type GreetServer
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/net/context"

	"github.com/luci/luci-go/common/logging/gologger"
)

func usage() {
	fmt.Fprintln(os.Stderr, "Usage of svcmux:")
	fmt.Fprintln(os.Stderr, "\tsvcmux [flags] -type T [directory]")
	fmt.Fprintln(os.Stderr, "\tsvcmux [flags[ -type T files... # Must be a single package")
	flag.PrintDefaults()
}

type generator struct {
	// Parsed from args:

	types     []string
	output    string
	dir       string
	fileNames []string

	// Internal mutable state:

	flags      *flag.FlagSet
	fset       *token.FileSet
	files      []*ast.File
	typeCache  map[string]*ast.TypeSpec
	exprStrBuf bytes.Buffer
}

func (g *generator) parseFlags(args []string) []string {
	var flags = flag.NewFlagSet("svcmux", flag.ExitOnError)
	typeFlag := flags.String("type", "", "comma-separated list of type names; must be set")
	flags.StringVar(&g.output, "output", "", "output file name; default <type>_string.go")
	flags.Usage = usage
	flags.Parse(args)

	splitTypes := strings.Split(*typeFlag, ",")
	g.types = make([]string, 0, len(splitTypes))
	for _, t := range splitTypes {
		t = strings.TrimSpace(t)
		if t != "" {
			g.types = append(g.types, t)
		}
	}
	if len(g.types) == 0 {
		fmt.Fprintf(os.Stderr, "type is not specified")
		flags.Usage()
		os.Exit(1)
	}
	return flags.Args()
}

func (g *generator) parseArgs(args []string) error {
	if len(args) == 0 {
		args = []string{"."}
	}
	if len(args) == 1 {
		info, err := os.Stat(args[0])
		if err != nil {
			return err
		}
		if info.IsDir() {
			g.dir = args[0]
			g.fileNames, err = readPackageDir(args[0])
			return err
		}
	}

	g.dir = filepath.Dir(args[0])
	g.fileNames = args
	return nil
}

// parsePackage parses .go files.
// They must be in the same directory and have same package name.
func (g *generator) parsePackage(fileNames []string) error {
	if len(fileNames) == 0 {
		return fmt.Errorf("fileNames is empty")
	}
	for i, name := range fileNames {
		if i > 0 && filepath.Dir(name) != filepath.Dir(fileNames[0]) {
			return fmt.Errorf("Go files belong to different directories")
		}
		if !strings.HasSuffix(name, ".go") {
			continue
		}
		file, err := parser.ParseFile(g.fset, name, nil, 0)
		if err != nil {
			return fmt.Errorf("parsing %s: %s", name, err)
		}
		if len(g.files) > 0 && file.Name.Name != g.files[0].Name.Name {
			return fmt.Errorf("Go files belong to different packages")
		}
		g.files = append(g.files, file)
	}
	if len(g.files) == 0 {
		return fmt.Errorf("no buildable Go files")
	}
	return nil
}

func (g *generator) run(c context.Context, args ...string) error {
	// Parse args.
	args = g.parseFlags(args)
	if err := g.parseArgs(args); err != nil {
		return err
	}

	// Parse files.
	g.fset = token.NewFileSet()
	if err := g.parsePackage(g.fileNames); err != nil {
		return err
	}

	// Generate template args.
	tmplArgs := templateArgs{
		PackageName: g.files[0].Name.Name,
	}
	for _, t := range g.types {
		mux, err := g.genMuxType(c, t)
		if err != nil {
			return err
		}
		tmplArgs.MuxTypes = append(tmplArgs.MuxTypes, mux)
	}

	// Execute template.
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, tmplArgs); err != nil {
		return err
	}

	// Format the output.
	src, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	// Write to file.
	outputName := g.output
	if outputName == "" {
		baseName := fmt.Sprintf("%s_mux.go", g.types[0])
		outputName = filepath.Join(g.dir, strings.ToLower(baseName))
	}
	return ioutil.WriteFile(outputName, src, 0644)
}

func (g *generator) setupLogging(c context.Context) context.Context {
	logCfg := gologger.LoggerConfig{
		Format: gologger.StandardFormat,
		Out:    os.Stderr,
	}
	return logCfg.Use(c)
}

func main() {
	var g generator
	c := g.setupLogging(context.Background())
	if err := g.run(c, os.Args[1:]...); err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(1)
	}
}

// readPackageDir lists .go files in dir.
func readPackageDir(dir string) ([]string, error) {
	pkg, err := build.ImportDir(dir, 0)
	if err != nil {
		return nil, fmt.Errorf("cannot process directory %s: %s", dir, err)
	}
	var names []string
	names = append(names, pkg.GoFiles...)
	names = append(names, pkg.CgoFiles...)
	names = prefixDirectory(dir, names)
	return names, nil
}

// prefixDirectory places the directory name on the beginning of each name in the list.
func prefixDirectory(directory string, names []string) []string {
	if directory == "." {
		return names
	}
	ret := make([]string, len(names))
	for i, name := range names {
		ret[i] = filepath.Join(directory, name)
	}
	return ret
}
