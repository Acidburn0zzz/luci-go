// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/scheduler/api/scheduler/v1/scheduler.proto

/*
Package scheduler is a generated protocol buffer package.

It is generated from these files:
	go.chromium.org/luci/scheduler/api/scheduler/v1/scheduler.proto
	go.chromium.org/luci/scheduler/api/scheduler/v1/triggers.proto

It has these top-level messages:
	JobsRequest
	JobsReply
	InvocationsRequest
	InvocationsReply
	EmitTriggersRequest
	JobRef
	InvocationRef
	Job
	JobState
	Invocation
	Trigger
	NoopTrigger
	GitilesTrigger
	BuildbucketTrigger
*/
package scheduler

import prpc "go.chromium.org/luci/grpc/prpc"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/empty"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type JobsRequest struct {
	// If not specified or "", all projects' jobs are returned.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	Cursor  string `protobuf:"bytes,2,opt,name=cursor" json:"cursor,omitempty"`
	// page_size is currently not implemented and is ignored.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
}

func (m *JobsRequest) Reset()                    { *m = JobsRequest{} }
func (m *JobsRequest) String() string            { return proto.CompactTextString(m) }
func (*JobsRequest) ProtoMessage()               {}
func (*JobsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *JobsRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *JobsRequest) GetCursor() string {
	if m != nil {
		return m.Cursor
	}
	return ""
}

func (m *JobsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

type JobsReply struct {
	Jobs       []*Job `protobuf:"bytes,1,rep,name=jobs" json:"jobs,omitempty"`
	NextCursor string `protobuf:"bytes,2,opt,name=next_cursor,json=nextCursor" json:"next_cursor,omitempty"`
}

func (m *JobsReply) Reset()                    { *m = JobsReply{} }
func (m *JobsReply) String() string            { return proto.CompactTextString(m) }
func (*JobsReply) ProtoMessage()               {}
func (*JobsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *JobsReply) GetJobs() []*Job {
	if m != nil {
		return m.Jobs
	}
	return nil
}

func (m *JobsReply) GetNextCursor() string {
	if m != nil {
		return m.NextCursor
	}
	return ""
}

type InvocationsRequest struct {
	JobRef *JobRef `protobuf:"bytes,1,opt,name=job_ref,json=jobRef" json:"job_ref,omitempty"`
	Cursor string  `protobuf:"bytes,2,opt,name=cursor" json:"cursor,omitempty"`
	// page_size defaults to 50 which is maximum.
	PageSize int32 `protobuf:"varint,3,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
}

func (m *InvocationsRequest) Reset()                    { *m = InvocationsRequest{} }
func (m *InvocationsRequest) String() string            { return proto.CompactTextString(m) }
func (*InvocationsRequest) ProtoMessage()               {}
func (*InvocationsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *InvocationsRequest) GetJobRef() *JobRef {
	if m != nil {
		return m.JobRef
	}
	return nil
}

func (m *InvocationsRequest) GetCursor() string {
	if m != nil {
		return m.Cursor
	}
	return ""
}

func (m *InvocationsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

type InvocationsReply struct {
	Invocations []*Invocation `protobuf:"bytes,1,rep,name=invocations" json:"invocations,omitempty"`
	NextCursor  string        `protobuf:"bytes,2,opt,name=next_cursor,json=nextCursor" json:"next_cursor,omitempty"`
}

func (m *InvocationsReply) Reset()                    { *m = InvocationsReply{} }
func (m *InvocationsReply) String() string            { return proto.CompactTextString(m) }
func (*InvocationsReply) ProtoMessage()               {}
func (*InvocationsReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *InvocationsReply) GetInvocations() []*Invocation {
	if m != nil {
		return m.Invocations
	}
	return nil
}

func (m *InvocationsReply) GetNextCursor() string {
	if m != nil {
		return m.NextCursor
	}
	return ""
}

type EmitTriggersRequest struct {
	Batches []*EmitTriggersRequest_Batch `protobuf:"bytes,1,rep,name=batches" json:"batches,omitempty"`
}

func (m *EmitTriggersRequest) Reset()                    { *m = EmitTriggersRequest{} }
func (m *EmitTriggersRequest) String() string            { return proto.CompactTextString(m) }
func (*EmitTriggersRequest) ProtoMessage()               {}
func (*EmitTriggersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *EmitTriggersRequest) GetBatches() []*EmitTriggersRequest_Batch {
	if m != nil {
		return m.Batches
	}
	return nil
}

type EmitTriggersRequest_Batch struct {
	Trigger *Trigger  `protobuf:"bytes,1,opt,name=trigger" json:"trigger,omitempty"`
	Jobs    []*JobRef `protobuf:"bytes,2,rep,name=jobs" json:"jobs,omitempty"`
}

func (m *EmitTriggersRequest_Batch) Reset()                    { *m = EmitTriggersRequest_Batch{} }
func (m *EmitTriggersRequest_Batch) String() string            { return proto.CompactTextString(m) }
func (*EmitTriggersRequest_Batch) ProtoMessage()               {}
func (*EmitTriggersRequest_Batch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

func (m *EmitTriggersRequest_Batch) GetTrigger() *Trigger {
	if m != nil {
		return m.Trigger
	}
	return nil
}

func (m *EmitTriggersRequest_Batch) GetJobs() []*JobRef {
	if m != nil {
		return m.Jobs
	}
	return nil
}

// JobRef uniquely identifies a job.
type JobRef struct {
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	Job     string `protobuf:"bytes,2,opt,name=job" json:"job,omitempty"`
}

func (m *JobRef) Reset()                    { *m = JobRef{} }
func (m *JobRef) String() string            { return proto.CompactTextString(m) }
func (*JobRef) ProtoMessage()               {}
func (*JobRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *JobRef) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *JobRef) GetJob() string {
	if m != nil {
		return m.Job
	}
	return ""
}

// InvocationRef uniquely identifies an invocation of a job.
type InvocationRef struct {
	JobRef *JobRef `protobuf:"bytes,1,opt,name=job_ref,json=jobRef" json:"job_ref,omitempty"`
	// invocation_id is a unique integer among all invocations for a given job.
	// However, there could be invocations with the same invocation_id but
	// belonging to different jobs.
	InvocationId int64 `protobuf:"varint,2,opt,name=invocation_id,json=invocationId" json:"invocation_id,omitempty"`
}

func (m *InvocationRef) Reset()                    { *m = InvocationRef{} }
func (m *InvocationRef) String() string            { return proto.CompactTextString(m) }
func (*InvocationRef) ProtoMessage()               {}
func (*InvocationRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *InvocationRef) GetJobRef() *JobRef {
	if m != nil {
		return m.JobRef
	}
	return nil
}

func (m *InvocationRef) GetInvocationId() int64 {
	if m != nil {
		return m.InvocationId
	}
	return 0
}

// Job descibes currently configured job.
type Job struct {
	JobRef   *JobRef   `protobuf:"bytes,1,opt,name=job_ref,json=jobRef" json:"job_ref,omitempty"`
	Schedule string    `protobuf:"bytes,2,opt,name=schedule" json:"schedule,omitempty"`
	State    *JobState `protobuf:"bytes,3,opt,name=state" json:"state,omitempty"`
	Paused   bool      `protobuf:"varint,4,opt,name=paused" json:"paused,omitempty"`
}

func (m *Job) Reset()                    { *m = Job{} }
func (m *Job) String() string            { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()               {}
func (*Job) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Job) GetJobRef() *JobRef {
	if m != nil {
		return m.JobRef
	}
	return nil
}

func (m *Job) GetSchedule() string {
	if m != nil {
		return m.Schedule
	}
	return ""
}

func (m *Job) GetState() *JobState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Job) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

// JobState describes current Job state as one of these strings:
//   "DISABLED"
//   "OVERRUN"
//   "PAUSED"
//   "RETRYING"
//   "RUNNING"
//   "SCHEDULED"
//   "STARTING"
//   "SUSPENDED"
//   "WAITING"
type JobState struct {
	UiStatus string `protobuf:"bytes,1,opt,name=ui_status,json=uiStatus" json:"ui_status,omitempty"`
}

func (m *JobState) Reset()                    { *m = JobState{} }
func (m *JobState) String() string            { return proto.CompactTextString(m) }
func (*JobState) ProtoMessage()               {}
func (*JobState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *JobState) GetUiStatus() string {
	if m != nil {
		return m.UiStatus
	}
	return ""
}

// Invocation describes properties of one job execution.
type Invocation struct {
	InvocationRef *InvocationRef `protobuf:"bytes,1,opt,name=invocation_ref,json=invocationRef" json:"invocation_ref,omitempty"`
	// start_ts is unix timestamp in microseconds.
	StartedTs int64 `protobuf:"varint,2,opt,name=started_ts,json=startedTs" json:"started_ts,omitempty"`
	// finished_ts is unix timestamp in microseconds. Set only if final is true.
	FinishedTs int64 `protobuf:"varint,3,opt,name=finished_ts,json=finishedTs" json:"finished_ts,omitempty"`
	// triggered_by is an identity ("kind:value") which is specified only if
	// invocation was triggered by not the scheduler service itself.
	TriggeredBy string `protobuf:"bytes,4,opt,name=triggered_by,json=triggeredBy" json:"triggered_by,omitempty"`
	// Latest status of a job.
	Status string `protobuf:"bytes,5,opt,name=status" json:"status,omitempty"`
	// If true, this invocation properties are final and won't be changed.
	Final bool `protobuf:"varint,6,opt,name=final" json:"final,omitempty"`
	// config_revision pins project/job config version according to which this
	// invocation was created.
	ConfigRevision string `protobuf:"bytes,7,opt,name=config_revision,json=configRevision" json:"config_revision,omitempty"`
	// view_url points to human readable page for a given invocation if available.
	ViewUrl string `protobuf:"bytes,8,opt,name=view_url,json=viewUrl" json:"view_url,omitempty"`
}

func (m *Invocation) Reset()                    { *m = Invocation{} }
func (m *Invocation) String() string            { return proto.CompactTextString(m) }
func (*Invocation) ProtoMessage()               {}
func (*Invocation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Invocation) GetInvocationRef() *InvocationRef {
	if m != nil {
		return m.InvocationRef
	}
	return nil
}

func (m *Invocation) GetStartedTs() int64 {
	if m != nil {
		return m.StartedTs
	}
	return 0
}

func (m *Invocation) GetFinishedTs() int64 {
	if m != nil {
		return m.FinishedTs
	}
	return 0
}

func (m *Invocation) GetTriggeredBy() string {
	if m != nil {
		return m.TriggeredBy
	}
	return ""
}

func (m *Invocation) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Invocation) GetFinal() bool {
	if m != nil {
		return m.Final
	}
	return false
}

func (m *Invocation) GetConfigRevision() string {
	if m != nil {
		return m.ConfigRevision
	}
	return ""
}

func (m *Invocation) GetViewUrl() string {
	if m != nil {
		return m.ViewUrl
	}
	return ""
}

func init() {
	proto.RegisterType((*JobsRequest)(nil), "scheduler.JobsRequest")
	proto.RegisterType((*JobsReply)(nil), "scheduler.JobsReply")
	proto.RegisterType((*InvocationsRequest)(nil), "scheduler.InvocationsRequest")
	proto.RegisterType((*InvocationsReply)(nil), "scheduler.InvocationsReply")
	proto.RegisterType((*EmitTriggersRequest)(nil), "scheduler.EmitTriggersRequest")
	proto.RegisterType((*EmitTriggersRequest_Batch)(nil), "scheduler.EmitTriggersRequest.Batch")
	proto.RegisterType((*JobRef)(nil), "scheduler.JobRef")
	proto.RegisterType((*InvocationRef)(nil), "scheduler.InvocationRef")
	proto.RegisterType((*Job)(nil), "scheduler.Job")
	proto.RegisterType((*JobState)(nil), "scheduler.JobState")
	proto.RegisterType((*Invocation)(nil), "scheduler.Invocation")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Scheduler service

type SchedulerClient interface {
	// GetJobs fetches all jobs satisfying JobsRequest and visibility ACLs.
	// If JobsRequest.project is specified but the project doesn't exist, empty
	// list of Jobs is returned.
	GetJobs(ctx context.Context, in *JobsRequest, opts ...grpc.CallOption) (*JobsReply, error)
	// GetInvocations fetches invocations of a given job, most recent first.
	GetInvocations(ctx context.Context, in *InvocationsRequest, opts ...grpc.CallOption) (*InvocationsReply, error)
	// PauseJob will prevent automatic triggering of a job. Manual triggering such
	// as through this API is still allowed. Any pending or running invocations
	// are still executed. PauseJob does nothing if job is already paused.
	//
	// Requires OWNER Job permission.
	PauseJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// ResumeJob resumes paused job. ResumeJob does nothing if job is not paused.
	//
	// Requires OWNER Job permission.
	ResumeJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// AbortJob resets the job to scheduled state, aborting a currently pending or
	// running invocation if any.
	//
	// Note, that this is similar to AbortInvocation except that AbortInvocation
	// requires invocation ID and doesn't ensure that the invocation aborted is
	// actually latest triggered for the job.
	//
	// Requires OWNER Job permission.
	AbortJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// AbortInvocation aborts a given job invocation.
	// If an invocation is final, AbortInvocation does nothing.
	//
	// If you want to abort a specific hung invocation, use this request instead
	// of AbortJob.
	//
	// Requires OWNER Job permission.
	AbortInvocation(ctx context.Context, in *InvocationRef, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// EmitTriggers puts one or more triggers into pending trigger queues of the
	// specified jobs.
	//
	// This eventually causes jobs to start executing. The scheduler may merge
	// multiple triggers into one job execution, based on how the job is
	// configured.
	//
	// If at least one job doesn't exist or the caller has no permission to
	// trigger it, the entire request is aborted. Otherwise, the request is NOT
	// transactional: if it fails midway (e.g by returning internal server error),
	// some triggers may have been submitted and some may not. It is safe to retry
	// the call, supplying the same trigger IDs. Triggers with the same IDs will
	// be deduplicated. See Trigger message for more details.
	//
	// Requires OWNER Job permission.
	//
	// TODO(vadimsh): add new TRIGGERER role.
	// TODO(vadimsh): deduplication doesn't work in v1.
	EmitTriggers(ctx context.Context, in *EmitTriggersRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
}
type schedulerPRPCClient struct {
	client *prpc.Client
}

func NewSchedulerPRPCClient(client *prpc.Client) SchedulerClient {
	return &schedulerPRPCClient{client}
}

func (c *schedulerPRPCClient) GetJobs(ctx context.Context, in *JobsRequest, opts ...grpc.CallOption) (*JobsReply, error) {
	out := new(JobsReply)
	err := c.client.Call(ctx, "scheduler.Scheduler", "GetJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerPRPCClient) GetInvocations(ctx context.Context, in *InvocationsRequest, opts ...grpc.CallOption) (*InvocationsReply, error) {
	out := new(InvocationsReply)
	err := c.client.Call(ctx, "scheduler.Scheduler", "GetInvocations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerPRPCClient) PauseJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := c.client.Call(ctx, "scheduler.Scheduler", "PauseJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerPRPCClient) ResumeJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := c.client.Call(ctx, "scheduler.Scheduler", "ResumeJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerPRPCClient) AbortJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := c.client.Call(ctx, "scheduler.Scheduler", "AbortJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerPRPCClient) AbortInvocation(ctx context.Context, in *InvocationRef, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := c.client.Call(ctx, "scheduler.Scheduler", "AbortInvocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerPRPCClient) EmitTriggers(ctx context.Context, in *EmitTriggersRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := c.client.Call(ctx, "scheduler.Scheduler", "EmitTriggers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

type schedulerClient struct {
	cc *grpc.ClientConn
}

func NewSchedulerClient(cc *grpc.ClientConn) SchedulerClient {
	return &schedulerClient{cc}
}

func (c *schedulerClient) GetJobs(ctx context.Context, in *JobsRequest, opts ...grpc.CallOption) (*JobsReply, error) {
	out := new(JobsReply)
	err := grpc.Invoke(ctx, "/scheduler.Scheduler/GetJobs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) GetInvocations(ctx context.Context, in *InvocationsRequest, opts ...grpc.CallOption) (*InvocationsReply, error) {
	out := new(InvocationsReply)
	err := grpc.Invoke(ctx, "/scheduler.Scheduler/GetInvocations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) PauseJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/scheduler.Scheduler/PauseJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) ResumeJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/scheduler.Scheduler/ResumeJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) AbortJob(ctx context.Context, in *JobRef, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/scheduler.Scheduler/AbortJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) AbortInvocation(ctx context.Context, in *InvocationRef, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/scheduler.Scheduler/AbortInvocation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) EmitTriggers(ctx context.Context, in *EmitTriggersRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/scheduler.Scheduler/EmitTriggers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Scheduler service

type SchedulerServer interface {
	// GetJobs fetches all jobs satisfying JobsRequest and visibility ACLs.
	// If JobsRequest.project is specified but the project doesn't exist, empty
	// list of Jobs is returned.
	GetJobs(context.Context, *JobsRequest) (*JobsReply, error)
	// GetInvocations fetches invocations of a given job, most recent first.
	GetInvocations(context.Context, *InvocationsRequest) (*InvocationsReply, error)
	// PauseJob will prevent automatic triggering of a job. Manual triggering such
	// as through this API is still allowed. Any pending or running invocations
	// are still executed. PauseJob does nothing if job is already paused.
	//
	// Requires OWNER Job permission.
	PauseJob(context.Context, *JobRef) (*google_protobuf.Empty, error)
	// ResumeJob resumes paused job. ResumeJob does nothing if job is not paused.
	//
	// Requires OWNER Job permission.
	ResumeJob(context.Context, *JobRef) (*google_protobuf.Empty, error)
	// AbortJob resets the job to scheduled state, aborting a currently pending or
	// running invocation if any.
	//
	// Note, that this is similar to AbortInvocation except that AbortInvocation
	// requires invocation ID and doesn't ensure that the invocation aborted is
	// actually latest triggered for the job.
	//
	// Requires OWNER Job permission.
	AbortJob(context.Context, *JobRef) (*google_protobuf.Empty, error)
	// AbortInvocation aborts a given job invocation.
	// If an invocation is final, AbortInvocation does nothing.
	//
	// If you want to abort a specific hung invocation, use this request instead
	// of AbortJob.
	//
	// Requires OWNER Job permission.
	AbortInvocation(context.Context, *InvocationRef) (*google_protobuf.Empty, error)
	// EmitTriggers puts one or more triggers into pending trigger queues of the
	// specified jobs.
	//
	// This eventually causes jobs to start executing. The scheduler may merge
	// multiple triggers into one job execution, based on how the job is
	// configured.
	//
	// If at least one job doesn't exist or the caller has no permission to
	// trigger it, the entire request is aborted. Otherwise, the request is NOT
	// transactional: if it fails midway (e.g by returning internal server error),
	// some triggers may have been submitted and some may not. It is safe to retry
	// the call, supplying the same trigger IDs. Triggers with the same IDs will
	// be deduplicated. See Trigger message for more details.
	//
	// Requires OWNER Job permission.
	//
	// TODO(vadimsh): add new TRIGGERER role.
	// TODO(vadimsh): deduplication doesn't work in v1.
	EmitTriggers(context.Context, *EmitTriggersRequest) (*google_protobuf.Empty, error)
}

func RegisterSchedulerServer(s prpc.Registrar, srv SchedulerServer) {
	s.RegisterService(&_Scheduler_serviceDesc, srv)
}

func _Scheduler_GetJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).GetJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/GetJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).GetJobs(ctx, req.(*JobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_GetInvocations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvocationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).GetInvocations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/GetInvocations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).GetInvocations(ctx, req.(*InvocationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_PauseJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).PauseJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/PauseJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).PauseJob(ctx, req.(*JobRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_ResumeJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).ResumeJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/ResumeJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).ResumeJob(ctx, req.(*JobRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_AbortJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).AbortJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/AbortJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).AbortJob(ctx, req.(*JobRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_AbortInvocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvocationRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).AbortInvocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/AbortInvocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).AbortInvocation(ctx, req.(*InvocationRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_EmitTriggers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmitTriggersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).EmitTriggers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scheduler.Scheduler/EmitTriggers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).EmitTriggers(ctx, req.(*EmitTriggersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Scheduler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "scheduler.Scheduler",
	HandlerType: (*SchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetJobs",
			Handler:    _Scheduler_GetJobs_Handler,
		},
		{
			MethodName: "GetInvocations",
			Handler:    _Scheduler_GetInvocations_Handler,
		},
		{
			MethodName: "PauseJob",
			Handler:    _Scheduler_PauseJob_Handler,
		},
		{
			MethodName: "ResumeJob",
			Handler:    _Scheduler_ResumeJob_Handler,
		},
		{
			MethodName: "AbortJob",
			Handler:    _Scheduler_AbortJob_Handler,
		},
		{
			MethodName: "AbortInvocation",
			Handler:    _Scheduler_AbortInvocation_Handler,
		},
		{
			MethodName: "EmitTriggers",
			Handler:    _Scheduler_EmitTriggers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "go.chromium.org/luci/scheduler/api/scheduler/v1/scheduler.proto",
}

func init() {
	proto.RegisterFile("go.chromium.org/luci/scheduler/api/scheduler/v1/scheduler.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 730 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xdd, 0x4e, 0xe3, 0x46,
	0x18, 0x55, 0x08, 0x49, 0xec, 0x2f, 0x10, 0xe8, 0x40, 0x91, 0x1b, 0x44, 0x9b, 0xba, 0xad, 0x48,
	0xab, 0xca, 0x51, 0xd3, 0x52, 0xee, 0x40, 0x0b, 0x62, 0x11, 0x68, 0x2f, 0x90, 0xc3, 0xde, 0x21,
	0x79, 0x6d, 0x67, 0xec, 0x4c, 0xe4, 0x64, 0xb2, 0x9e, 0x71, 0x76, 0xc3, 0x53, 0xec, 0x33, 0xec,
	0x2b, 0xec, 0x33, 0xec, 0x7b, 0xad, 0x66, 0x3c, 0x8e, 0x9d, 0x25, 0x61, 0x95, 0xbd, 0x4a, 0xce,
	0xf9, 0xfe, 0x7c, 0xbe, 0x39, 0x33, 0x70, 0x1e, 0x52, 0xcb, 0x1f, 0xc4, 0x74, 0x44, 0x92, 0x91,
	0x45, 0xe3, 0xb0, 0x13, 0x25, 0x3e, 0xe9, 0x30, 0x7f, 0x80, 0xfb, 0x49, 0x84, 0xe3, 0x8e, 0x3b,
	0x29, 0xa2, 0xe9, 0x3f, 0x39, 0xb0, 0x26, 0x31, 0xe5, 0x14, 0xe9, 0x73, 0xa2, 0x79, 0x18, 0x52,
	0x1a, 0x46, 0xb8, 0x23, 0x03, 0x5e, 0x12, 0x74, 0xf0, 0x68, 0xc2, 0x67, 0x69, 0x5e, 0xf3, 0x6c,
	0xdd, 0x41, 0x3c, 0x26, 0x61, 0x88, 0x63, 0x96, 0xd6, 0x9b, 0x0f, 0x50, 0xbf, 0xa5, 0x1e, 0xb3,
	0xf1, 0xdb, 0x04, 0x33, 0x8e, 0x0c, 0xa8, 0x4d, 0x62, 0x3a, 0xc4, 0x3e, 0x37, 0x4a, 0xad, 0x52,
	0x5b, 0xb7, 0x33, 0x88, 0x0e, 0xa0, 0xea, 0x27, 0x31, 0xa3, 0xb1, 0xb1, 0x21, 0x03, 0x0a, 0xa1,
	0x43, 0xd0, 0x27, 0x6e, 0x88, 0x1d, 0x46, 0x1e, 0xb1, 0x51, 0x6e, 0x95, 0xda, 0x15, 0x5b, 0x13,
	0x44, 0x8f, 0x3c, 0x62, 0xf3, 0x0e, 0xf4, 0xb4, 0xfb, 0x24, 0x9a, 0x21, 0x13, 0x36, 0x87, 0xd4,
	0x63, 0x46, 0xa9, 0x55, 0x6e, 0xd7, 0xbb, 0x0d, 0x2b, 0x97, 0x7c, 0x4b, 0x3d, 0x5b, 0xc6, 0xd0,
	0x2f, 0x50, 0x1f, 0xe3, 0xf7, 0xdc, 0x59, 0x18, 0x05, 0x82, 0xba, 0x94, 0x8c, 0x99, 0x00, 0xba,
	0x19, 0x4f, 0xa9, 0xef, 0x72, 0x42, 0xc7, 0xf3, 0xcf, 0xfe, 0x0b, 0x6a, 0x43, 0xea, 0x39, 0x31,
	0x0e, 0xe4, 0x67, 0xd7, 0xbb, 0x3f, 0x7c, 0xd5, 0x1d, 0x07, 0x76, 0x75, 0x28, 0x7f, 0xbf, 0x4f,
	0x48, 0x04, 0xbb, 0x0b, 0x63, 0x85, 0x9e, 0x53, 0xa8, 0x93, 0x9c, 0x53, 0xb2, 0x7e, 0x2c, 0x0c,
	0xce, 0x2b, 0xec, 0x62, 0xe6, 0xb7, 0x45, 0x7e, 0x2a, 0xc1, 0xde, 0xd5, 0x88, 0xf0, 0x7b, 0x75,
	0x56, 0x99, 0xcc, 0x33, 0xa8, 0x79, 0x2e, 0xf7, 0x07, 0x38, 0x9b, 0xf6, 0x7b, 0x61, 0xda, 0x92,
	0x02, 0xeb, 0x42, 0x64, 0xdb, 0x59, 0x51, 0xf3, 0x01, 0x2a, 0x92, 0x41, 0x7f, 0x43, 0x4d, 0xf9,
	0x40, 0xed, 0x0b, 0x15, 0x1a, 0xa9, 0x26, 0x76, 0x96, 0x82, 0xfe, 0x50, 0x07, 0xb7, 0x21, 0x67,
	0x2e, 0x59, 0xad, 0x0c, 0x9b, 0xff, 0x41, 0x35, 0xc5, 0xcf, 0xb8, 0x68, 0x17, 0xca, 0x43, 0xea,
	0x29, 0xc9, 0xe2, 0xaf, 0xf9, 0x06, 0xb6, 0x0b, 0x7b, 0xc2, 0xc1, 0x5a, 0x67, 0xf9, 0x1b, 0x6c,
	0xe7, 0x8b, 0x75, 0x48, 0x5f, 0x36, 0x2e, 0xdb, 0x5b, 0x39, 0x79, 0xd3, 0x37, 0x3f, 0x94, 0xa0,
	0x7c, 0x4b, 0xbd, 0xb5, 0x1a, 0x37, 0x41, 0xcb, 0x62, 0xea, 0x63, 0xe7, 0x18, 0xfd, 0x09, 0x15,
	0xc6, 0x5d, 0x9e, 0x9a, 0xa4, 0xde, 0xdd, 0x5b, 0xec, 0xd2, 0x13, 0x21, 0x3b, 0xcd, 0x10, 0x5e,
	0x9b, 0xb8, 0x09, 0xc3, 0x7d, 0x63, 0xb3, 0x55, 0x6a, 0x6b, 0xb6, 0x42, 0xe6, 0x31, 0x68, 0x59,
	0xaa, 0xf0, 0x5d, 0x42, 0x1c, 0x91, 0x9f, 0x30, 0xb5, 0x2e, 0x2d, 0x21, 0x3d, 0x89, 0xcd, 0x8f,
	0x1b, 0x00, 0xf9, 0x7a, 0xd0, 0x39, 0x34, 0x0a, 0x7a, 0x73, 0x25, 0xc6, 0x72, 0xd7, 0xe1, 0xc0,
	0x2e, 0xec, 0x47, 0xe8, 0x3a, 0x02, 0x60, 0xdc, 0x8d, 0x39, 0xee, 0x3b, 0x9c, 0xa9, 0x6d, 0xe9,
	0x8a, 0xb9, 0x97, 0xce, 0x0c, 0xc8, 0x98, 0xb0, 0x41, 0x1a, 0x2f, 0xcb, 0x38, 0x64, 0xd4, 0x3d,
	0x43, 0xbf, 0xc2, 0x96, 0x72, 0x05, 0xee, 0x3b, 0xde, 0x4c, 0xca, 0xd2, 0xed, 0xfa, 0x9c, 0xbb,
	0x98, 0x09, 0xcd, 0x4a, 0x4c, 0x25, 0xbd, 0x5f, 0x29, 0x42, 0xfb, 0x50, 0x09, 0xc8, 0xd8, 0x8d,
	0x8c, 0xaa, 0x5c, 0x45, 0x0a, 0xd0, 0x31, 0xec, 0xf8, 0x74, 0x1c, 0x90, 0xd0, 0x89, 0xf1, 0x94,
	0x30, 0x42, 0xc7, 0x46, 0x4d, 0x96, 0x35, 0x52, 0xda, 0x56, 0x2c, 0xfa, 0x09, 0xb4, 0x29, 0xc1,
	0xef, 0x9c, 0x24, 0x8e, 0x0c, 0x2d, 0x35, 0x95, 0xc0, 0xaf, 0xe3, 0xa8, 0xfb, 0xb9, 0x0c, 0x7a,
	0x2f, 0xd3, 0x8f, 0x4e, 0xa1, 0x76, 0x8d, 0xb9, 0x78, 0x76, 0xd0, 0xc1, 0xe2, 0xd1, 0x64, 0xd7,
	0xa2, 0xb9, 0xff, 0x84, 0x17, 0xf7, 0xf9, 0x15, 0x34, 0xae, 0x31, 0x2f, 0x5c, 0x73, 0x74, 0xb4,
	0x74, 0xad, 0xf3, 0x36, 0x87, 0xab, 0xc2, 0xa2, 0xdb, 0x09, 0x68, 0x77, 0xe2, 0xb0, 0x85, 0xf3,
	0x9e, 0x1a, 0xad, 0x79, 0x60, 0xa5, 0xaf, 0xba, 0x95, 0xbd, 0xea, 0xd6, 0x95, 0x78, 0xd5, 0xd1,
	0xff, 0xa0, 0xdb, 0x98, 0x25, 0xa3, 0x75, 0xeb, 0x4e, 0x40, 0x7b, 0xe1, 0xd1, 0x98, 0xaf, 0x59,
	0x76, 0x09, 0x3b, 0xb2, 0xac, 0xe0, 0xb1, 0x95, 0x5e, 0x5a, 0xd9, 0xe4, 0x25, 0x6c, 0x15, 0x1f,
	0x1f, 0xf4, 0xf3, 0xf3, 0xaf, 0xd2, 0xaa, 0x3e, 0x5e, 0x55, 0xe2, 0x7f, 0xbf, 0x04, 0x00, 0x00,
	0xff, 0xff, 0xb6, 0x1a, 0xc0, 0xaf, 0x3d, 0x07, 0x00, 0x00,
}
