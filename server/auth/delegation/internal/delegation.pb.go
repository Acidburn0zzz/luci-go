// Code generated by protoc-gen-go.
// source: github.com/luci/luci-go/server/auth/delegation/internal/delegation.proto
// DO NOT EDIT!

/*
Package internal is a generated protocol buffer package.

It is generated from these files:
	github.com/luci/luci-go/server/auth/delegation/internal/delegation.proto

It has these top-level messages:
	DelegationToken
	SubtokenList
	Subtoken
*/
package internal

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Signed serialized list of subtokens. This message itself is mostly
// an envelope that carries the signature. The meat of the token is in
// SubtokenList (stored in serialized_subtoken_list field).
type DelegationToken struct {
	// Serialized SubtokenList message with at least one subtoken. It's signature
	// is stored in pkcs1_sha256_sig field. Required.
	SerializedSubtokenList []byte `protobuf:"bytes,1,opt,name=serialized_subtoken_list,json=serializedSubtokenList" json:"serialized_subtoken_list,omitempty"`
	// Identity of a service that signed this token (e.g. 'service:app-id').
	// Will be queries (via SSL) for the public key to use for signature
	// verification. Required.
	SignerId *string `protobuf:"bytes,2,opt,name=signer_id,json=signerId" json:"signer_id,omitempty"`
	// ID of a key used for making the signature. There can be multiple active
	// keys at any moment in time: one used for new signatures, and one being
	// rotated out (but still valid for verification). Required.
	SigningKeyId *string `protobuf:"bytes,3,opt,name=signing_key_id,json=signingKeyId" json:"signing_key_id,omitempty"`
	// The signature: PKCS1_v1_5+SHA256(serialized_subtoken_list, signing_key_id).
	// Required.
	Pkcs1Sha256Sig   []byte `protobuf:"bytes,4,opt,name=pkcs1_sha256_sig,json=pkcs1Sha256Sig" json:"pkcs1_sha256_sig,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DelegationToken) Reset()                    { *m = DelegationToken{} }
func (m *DelegationToken) String() string            { return proto.CompactTextString(m) }
func (*DelegationToken) ProtoMessage()               {}
func (*DelegationToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DelegationToken) GetSerializedSubtokenList() []byte {
	if m != nil {
		return m.SerializedSubtokenList
	}
	return nil
}

func (m *DelegationToken) GetSignerId() string {
	if m != nil && m.SignerId != nil {
		return *m.SignerId
	}
	return ""
}

func (m *DelegationToken) GetSigningKeyId() string {
	if m != nil && m.SigningKeyId != nil {
		return *m.SigningKeyId
	}
	return ""
}

func (m *DelegationToken) GetPkcs1Sha256Sig() []byte {
	if m != nil {
		return m.Pkcs1Sha256Sig
	}
	return nil
}

// List of tokens, to be serialized, signed and put into DelegationToken.
type SubtokenList struct {
	Subtokens        []*Subtoken `protobuf:"bytes,1,rep,name=subtokens" json:"subtokens,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *SubtokenList) Reset()                    { *m = SubtokenList{} }
func (m *SubtokenList) String() string            { return proto.CompactTextString(m) }
func (*SubtokenList) ProtoMessage()               {}
func (*SubtokenList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SubtokenList) GetSubtokens() []*Subtoken {
	if m != nil {
		return m.Subtokens
	}
	return nil
}

// Identifies who delegates what authority to whom where.
//
// Multiple subtokens are chained together during redelegation (when a bearer
// of a delegation token scopes it and passes it to someone else). Such subtoken
// list conveys in itself full delegation chain (which is nice for auditing
// purposes).
//
// The final delegated identity is recovered from traversing the subtoken chain
// in last to first order, keeping track of current "active" identity and
// checking that it is specified in 'audience' field of the token being checked.
//
// Traversal starts with an active identity set to identity encoded in caller's
// authentication token.
//
// current_id = peer_id
// while subtokens:
//   if current_id in subtokens[-1].audience:
//     current_id = subtokens[-1].issuer_id
//     subtokens.pop()
//   else:
//     abort()
type Subtoken struct {
	// WHO. Identity whose authority is delegated. Usually it's the identity that
	// generates the delegation token. Required.
	IssuerId *string `protobuf:"bytes,1,opt,name=issuer_id,json=issuerId" json:"issuer_id,omitempty"`
	// When the subtoken was generated (and when it becomes valid). Number of
	// seconds since epoch. Required.
	CreationTime *int64 `protobuf:"varint,2,opt,name=creation_time,json=creationTime" json:"creation_time,omitempty"`
	// How long the token is considered valid (in seconds). Required.
	ValidityDuration *int32 `protobuf:"varint,3,opt,name=validity_duration,json=validityDuration" json:"validity_duration,omitempty"`
	// Identifier of this subtoken.
	//
	// Used for logging and tracking purposes.
	SubtokenId *int64 `protobuf:"varint,4,opt,name=subtoken_id,json=subtokenId" json:"subtoken_id,omitempty"`
	// To WHOM the authority is delegated. Each item can be an identity string
	// (e.g. "user:<email>") or a "group:<name>" string. "Any bearer can use
	// the token" if empty.
	Audience []string `protobuf:"bytes,5,rep,name=audience" json:"audience,omitempty"`
	// WHERE the token is valid. List of services (specified as service
	// identities, e.g. "service:app-id") that can accept this token.
	// "All services" if empty.
	Services []string `protobuf:"bytes,6,rep,name=services" json:"services,omitempty"`
	// If this token was minted on some else's behalf (i.e. issuer_id field was
	// provided externally) stores an identify of whoever initiated the minting
	// request. Mostly for informational purposes. Optional field.
	ImpersonatorId   *string `protobuf:"bytes,7,opt,name=impersonator_id,json=impersonatorId" json:"impersonator_id,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Subtoken) Reset()                    { *m = Subtoken{} }
func (m *Subtoken) String() string            { return proto.CompactTextString(m) }
func (*Subtoken) ProtoMessage()               {}
func (*Subtoken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Subtoken) GetIssuerId() string {
	if m != nil && m.IssuerId != nil {
		return *m.IssuerId
	}
	return ""
}

func (m *Subtoken) GetCreationTime() int64 {
	if m != nil && m.CreationTime != nil {
		return *m.CreationTime
	}
	return 0
}

func (m *Subtoken) GetValidityDuration() int32 {
	if m != nil && m.ValidityDuration != nil {
		return *m.ValidityDuration
	}
	return 0
}

func (m *Subtoken) GetSubtokenId() int64 {
	if m != nil && m.SubtokenId != nil {
		return *m.SubtokenId
	}
	return 0
}

func (m *Subtoken) GetAudience() []string {
	if m != nil {
		return m.Audience
	}
	return nil
}

func (m *Subtoken) GetServices() []string {
	if m != nil {
		return m.Services
	}
	return nil
}

func (m *Subtoken) GetImpersonatorId() string {
	if m != nil && m.ImpersonatorId != nil {
		return *m.ImpersonatorId
	}
	return ""
}

func init() {
	proto.RegisterType((*DelegationToken)(nil), "internal.DelegationToken")
	proto.RegisterType((*SubtokenList)(nil), "internal.SubtokenList")
	proto.RegisterType((*Subtoken)(nil), "internal.Subtoken")
}

func init() {
	proto.RegisterFile("github.com/luci/luci-go/server/auth/delegation/internal/delegation.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 372 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x54, 0x91, 0x41, 0x8f, 0xda, 0x30,
	0x10, 0x85, 0x95, 0x02, 0x6d, 0x30, 0x29, 0x50, 0x1f, 0xaa, 0xa8, 0x3d, 0xb4, 0xa2, 0x95, 0x8a,
	0x54, 0x35, 0x69, 0x91, 0x5a, 0xf5, 0xd8, 0x03, 0x87, 0xa2, 0xdd, 0x53, 0xe0, 0x6e, 0x85, 0x78,
	0x14, 0x46, 0x04, 0x1b, 0xd9, 0x0e, 0x12, 0xfb, 0xcb, 0xf6, 0xbf, 0xed, 0x65, 0x1d, 0x27, 0x06,
	0xf6, 0x82, 0x98, 0xef, 0x3d, 0x79, 0xde, 0x9b, 0x90, 0xff, 0x25, 0x9a, 0x5d, 0xbd, 0x4d, 0x0a,
	0x79, 0x48, 0xab, 0xba, 0x40, 0xf7, 0xf3, 0xa3, 0x94, 0xa9, 0x06, 0x75, 0x02, 0x95, 0xe6, 0xb5,
	0xd9, 0xa5, 0x1c, 0x2a, 0x28, 0x73, 0x83, 0x52, 0xa4, 0x28, 0x0c, 0x28, 0x91, 0x57, 0x37, 0x2c,
	0x39, 0x2a, 0x69, 0x24, 0x0d, 0xbd, 0x34, 0x7b, 0x0c, 0xc8, 0x64, 0x79, 0x91, 0x37, 0x72, 0x0f,
	0x82, 0xfe, 0x25, 0xb1, 0x7d, 0x11, 0xf3, 0x0a, 0x1f, 0x80, 0x33, 0x5d, 0x6f, 0x4d, 0x83, 0x59,
	0x85, 0xda, 0xc4, 0xc1, 0xe7, 0x60, 0x1e, 0x65, 0xef, 0xaf, 0xfa, 0xba, 0x93, 0xef, 0xad, 0x4a,
	0x3f, 0x92, 0xa1, 0xc6, 0x52, 0x80, 0x62, 0xc8, 0xe3, 0x57, 0xd6, 0x3a, 0xcc, 0xc2, 0x16, 0xac,
	0x38, 0xfd, 0x4a, 0xc6, 0xcd, 0x7f, 0x14, 0x25, 0xdb, 0xc3, 0xb9, 0x71, 0xf4, 0x9c, 0x23, 0xea,
	0xe8, 0x1d, 0x9c, 0xad, 0x6b, 0x4e, 0xa6, 0xc7, 0x7d, 0xa1, 0x7f, 0x31, 0xbd, 0xcb, 0x17, 0xbf,
	0xff, 0x30, 0x2b, 0xc6, 0x7d, 0xb7, 0x74, 0xec, 0xf8, 0xda, 0xe1, 0x35, 0x96, 0xb3, 0x7f, 0x24,
	0x7a, 0xb1, 0xfc, 0xa7, 0x5d, 0xde, 0xcd, 0xda, 0xe6, 0xec, 0xcd, 0x47, 0x0b, 0x9a, 0xf8, 0xa2,
	0x89, 0xb7, 0x66, 0x57, 0xd3, 0xec, 0x29, 0x20, 0xa1, 0xe7, 0x4d, 0x76, 0xd4, 0xba, 0x6e, 0xb3,
	0x07, 0x6d, 0xf6, 0x16, 0xd8, 0x54, 0x5f, 0xc8, 0xdb, 0x42, 0x81, 0xbb, 0x11, 0x33, 0x78, 0x00,
	0x57, 0xae, 0x97, 0x45, 0x1e, 0x6e, 0x2c, 0xa3, 0xdf, 0xc9, 0xbb, 0x93, 0x3d, 0x0a, 0x47, 0x73,
	0x66, 0xbc, 0x56, 0x4e, 0x70, 0x1d, 0x07, 0xd9, 0xd4, 0x0b, 0xcb, 0x8e, 0xd3, 0x4f, 0x64, 0x74,
	0xb9, 0xac, 0x5d, 0xd8, 0x77, 0xef, 0x11, 0x8f, 0xec, 0xca, 0x0f, 0x24, 0xcc, 0x6b, 0x8e, 0x20,
	0x0a, 0x88, 0x07, 0xb6, 0x8d, 0x8d, 0xe3, 0xe7, 0x46, 0x6b, 0xbe, 0x39, 0x16, 0xa0, 0xe3, 0xd7,
	0xad, 0xe6, 0x67, 0xfa, 0x8d, 0x4c, 0xf0, 0x70, 0x04, 0xa5, 0xa5, 0xc8, 0x8d, 0x74, 0x6d, 0xde,
	0xb8, 0x36, 0xe3, 0x5b, 0xbc, 0xe2, 0xcf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xa8, 0x6c, 0xc3, 0x9b,
	0x4f, 0x02, 0x00, 0x00,
}
