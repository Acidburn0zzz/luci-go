// Code generated by protoc-gen-go. DO NOT EDIT.
// source: go.chromium.org/luci/milo/api/proto/recipes/source_manifest.proto

/*
Package source_manifest is a generated protocol buffer package.

It is generated from these files:
	go.chromium.org/luci/milo/api/proto/recipes/source_manifest.proto

It has these top-level messages:
	Manifest
*/
package source_manifest

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// A Manifest attempts to make an accurate accounting of source/data directories
// during the execution of a LUCI task.
//
// These directories are primarially in the form of e.g. git checkouts of
// source, but also include things like isolated hashes and CIPD package
// deployments. In the future, other deployment forms may be supported (like
// other SCMs).
//
// The purpose of this manifest is so that other parts of the LUCI stack (e.g.
// Milo) can work with the descripitons of this deployed data as a first-class
// citizen. Initially this Manifest will be used to allow Milo to display diffs
// between jobs, but it will also be useful for tools and humans to get a
// record of exactly what data went into this LUCI task.
//
// Source Manifests can be emitted from recipes using the
// 'recipe_engine/manifest' module.
type Manifest struct {
	// Version will increment on backwards-incompatible changes only. Backwards
	// compatible changes will not alter this version number.
	//
	// Currently, the only valid version number is 0.
	Version int32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	// Map of local file system directory path (with forward slashes) to
	// a Directory message containing one or more deployments.
	//
	// The local path is relative to some job-specific root. This should be used
	// for informational/display/organization purposes, and should not be used as
	// a global primary key. i.e. if you depend on chromium/src.git being in
	// a folder called “src”, I will find you and make really angry faces at you
	// until you change it...（╬ಠ益ಠ). Instead, implementations should consider
	// indexing by e.g. git repository URL or cipd package name as more better
	// primary keys.
	Directories map[string]*Manifest_Directory `protobuf:"bytes,2,rep,name=directories" json:"directories,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Manifest) Reset()                    { *m = Manifest{} }
func (m *Manifest) String() string            { return proto.CompactTextString(m) }
func (*Manifest) ProtoMessage()               {}
func (*Manifest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Manifest) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Manifest) GetDirectories() map[string]*Manifest_Directory {
	if m != nil {
		return m.Directories
	}
	return nil
}

type Manifest_GitCheckout struct {
	// The canonicalized URL of the original repo that is considered the “source
	// of truth” for the source code. Ex.
	//   https://chromium.googlesource.com/chromium/tools/build.git
	//   https://chromium.googlesource.com/infra/luci/recipes-py
	RepoUrl string `protobuf:"bytes,1,opt,name=repo_url,json=repoUrl" json:"repo_url,omitempty"`
	// If different from repo_url, this can be the URL of the repo that the source
	// was actually fetched from (i.e. a mirror). Ex.
	//   https://github.com/luci/recipes-py
	//
	// If this is empty, it's presumed to be equal to repo_url.
	FetchUrl string `protobuf:"bytes,2,opt,name=fetch_url,json=fetchUrl" json:"fetch_url,omitempty"`
	// The fully resolved revision (commit hash) of the source. Ex.
	//   3617b0eea7ec74b8e731a23fed2f4070cbc284c4
	//
	// Note that this is the raw revision bytes, not their hex-encoded form.
	Revision []byte `protobuf:"bytes,3,opt,name=revision,proto3" json:"revision,omitempty"`
	// The ref that the task used to resolve the revision of the source (if any). Ex.
	//   refs/heads/master
	//   refs/changes/04/511804/4
	//
	// This should always be a ref on the hosted repo (not any local alias
	// like 'refs/remotes/...').
	//
	// This should always be an absolute ref (i.e. starts with 'refs/'). An
	// example of a non-absolute ref would be 'master'.
	TrackingRef string `protobuf:"bytes,4,opt,name=tracking_ref,json=trackingRef" json:"tracking_ref,omitempty"`
}

func (m *Manifest_GitCheckout) Reset()                    { *m = Manifest_GitCheckout{} }
func (m *Manifest_GitCheckout) String() string            { return proto.CompactTextString(m) }
func (*Manifest_GitCheckout) ProtoMessage()               {}
func (*Manifest_GitCheckout) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

func (m *Manifest_GitCheckout) GetRepoUrl() string {
	if m != nil {
		return m.RepoUrl
	}
	return ""
}

func (m *Manifest_GitCheckout) GetFetchUrl() string {
	if m != nil {
		return m.FetchUrl
	}
	return ""
}

func (m *Manifest_GitCheckout) GetRevision() []byte {
	if m != nil {
		return m.Revision
	}
	return nil
}

func (m *Manifest_GitCheckout) GetTrackingRef() string {
	if m != nil {
		return m.TrackingRef
	}
	return ""
}

type Manifest_CIPDPackage struct {
	// The canonicalized URL of the CIPD server which provided the package. Ex.
	//   https://chrome-infra-packages.appspot.com
	CipdServerUrl string `protobuf:"bytes,1,opt,name=cipd_server_url,json=cipdServerUrl" json:"cipd_server_url,omitempty"`
	// The fully resolved CIPD package name that was deployed. Ex.
	//   infra/tools/luci/led/linux-amd64
	CipdPackageName string `protobuf:"bytes,2,opt,name=cipd_package_name,json=cipdPackageName" json:"cipd_package_name,omitempty"`
	// The package pattern that was given to the CIPD client (if known). Ex.
	//   infra/tools/luci/led/${platform}
	CipdPackagePattern string `protobuf:"bytes,3,opt,name=cipd_package_pattern,json=cipdPackagePattern" json:"cipd_package_pattern,omitempty"`
	// The fully resolved instance ID of the deployed package. Ex.
	//   0cfafb3a705bd8f05f86c6444ff500397fbb711c
	//
	// Note that this is the raw instance_id bytes, not their hex-encoded form.
	CipdInstanceId []byte `protobuf:"bytes,4,opt,name=cipd_instance_id,json=cipdInstanceId,proto3" json:"cipd_instance_id,omitempty"`
	// The unresolved version ID of the deployed package (if known). Ex.
	//   git_revision:aaf3a2cfccc227b5141caa1b6b3502c9907d7420
	//   latest
	CipdVersion string `protobuf:"bytes,5,opt,name=cipd_version,json=cipdVersion" json:"cipd_version,omitempty"`
}

func (m *Manifest_CIPDPackage) Reset()                    { *m = Manifest_CIPDPackage{} }
func (m *Manifest_CIPDPackage) String() string            { return proto.CompactTextString(m) }
func (*Manifest_CIPDPackage) ProtoMessage()               {}
func (*Manifest_CIPDPackage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 1} }

func (m *Manifest_CIPDPackage) GetCipdServerUrl() string {
	if m != nil {
		return m.CipdServerUrl
	}
	return ""
}

func (m *Manifest_CIPDPackage) GetCipdPackageName() string {
	if m != nil {
		return m.CipdPackageName
	}
	return ""
}

func (m *Manifest_CIPDPackage) GetCipdPackagePattern() string {
	if m != nil {
		return m.CipdPackagePattern
	}
	return ""
}

func (m *Manifest_CIPDPackage) GetCipdInstanceId() []byte {
	if m != nil {
		return m.CipdInstanceId
	}
	return nil
}

func (m *Manifest_CIPDPackage) GetCipdVersion() string {
	if m != nil {
		return m.CipdVersion
	}
	return ""
}

type Manifest_Isolated struct {
	// The canonicalized URL of the isolated server which hosts the isolated.
	// Ex.
	//   https://isolateserver.appspot.com
	IsolatedServerUrl string `protobuf:"bytes,1,opt,name=isolated_server_url,json=isolatedServerUrl" json:"isolated_server_url,omitempty"`
	// The namespace of the isolated document. Ex.
	//   default-gzip
	Namespace string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	// The hash of the isolated document. Ex.
	//   62a7df62ea122380afb306bb4d9cdac1bc7e9a96
	//
	// Note that this is the raw hash bytes, not their hex-encoded form.
	Hash []byte `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *Manifest_Isolated) Reset()                    { *m = Manifest_Isolated{} }
func (m *Manifest_Isolated) String() string            { return proto.CompactTextString(m) }
func (*Manifest_Isolated) ProtoMessage()               {}
func (*Manifest_Isolated) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 2} }

func (m *Manifest_Isolated) GetIsolatedServerUrl() string {
	if m != nil {
		return m.IsolatedServerUrl
	}
	return ""
}

func (m *Manifest_Isolated) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Manifest_Isolated) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// A Directory contains one or more descriptions of deployed artifacts. Note
// that due to the practical nature of jobs on bots, it may be the case that
// a given directory contains e.g. a git checkout and multiple cipd packages.
type Manifest_Directory struct {
	GitCheckout *Manifest_GitCheckout   `protobuf:"bytes,1,opt,name=git_checkout,json=gitCheckout" json:"git_checkout,omitempty"`
	CipdPackage []*Manifest_CIPDPackage `protobuf:"bytes,2,rep,name=cipd_package,json=cipdPackage" json:"cipd_package,omitempty"`
	Isolated    []*Manifest_Isolated    `protobuf:"bytes,3,rep,name=isolated" json:"isolated,omitempty"`
}

func (m *Manifest_Directory) Reset()                    { *m = Manifest_Directory{} }
func (m *Manifest_Directory) String() string            { return proto.CompactTextString(m) }
func (*Manifest_Directory) ProtoMessage()               {}
func (*Manifest_Directory) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 3} }

func (m *Manifest_Directory) GetGitCheckout() *Manifest_GitCheckout {
	if m != nil {
		return m.GitCheckout
	}
	return nil
}

func (m *Manifest_Directory) GetCipdPackage() []*Manifest_CIPDPackage {
	if m != nil {
		return m.CipdPackage
	}
	return nil
}

func (m *Manifest_Directory) GetIsolated() []*Manifest_Isolated {
	if m != nil {
		return m.Isolated
	}
	return nil
}

func init() {
	proto.RegisterType((*Manifest)(nil), "Manifest")
	proto.RegisterType((*Manifest_GitCheckout)(nil), "Manifest.GitCheckout")
	proto.RegisterType((*Manifest_CIPDPackage)(nil), "Manifest.CIPDPackage")
	proto.RegisterType((*Manifest_Isolated)(nil), "Manifest.Isolated")
	proto.RegisterType((*Manifest_Directory)(nil), "Manifest.Directory")
}

func init() {
	proto.RegisterFile("go.chromium.org/luci/milo/api/proto/recipes/source_manifest.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 500 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x53, 0xcd, 0x8e, 0xd3, 0x30,
	0x10, 0x56, 0xda, 0xed, 0x6e, 0x3b, 0x29, 0xd0, 0xf5, 0x82, 0x54, 0x02, 0x87, 0xc2, 0x01, 0x15,
	0x0e, 0x09, 0x2a, 0x97, 0x0a, 0x71, 0x41, 0xbb, 0x08, 0xf5, 0x00, 0xaa, 0xb2, 0x82, 0x6b, 0x64,
	0xdc, 0x69, 0x6a, 0x35, 0x89, 0x23, 0xdb, 0xa9, 0xd4, 0x3b, 0xef, 0xc3, 0x33, 0xf0, 0x26, 0x3c,
	0x0a, 0xb2, 0x63, 0x6f, 0x03, 0x7b, 0xb3, 0xbf, 0x9f, 0x78, 0xbe, 0x99, 0x09, 0x7c, 0xcc, 0x45,
	0xcc, 0x76, 0x52, 0x94, 0xbc, 0x29, 0x63, 0x21, 0xf3, 0xa4, 0x68, 0x18, 0x4f, 0x4a, 0x5e, 0x88,
	0x84, 0xd6, 0x3c, 0xa9, 0xa5, 0xd0, 0x22, 0x91, 0xc8, 0x78, 0x8d, 0x2a, 0x51, 0xa2, 0x91, 0x0c,
	0xb3, 0x92, 0x56, 0x7c, 0x8b, 0x4a, 0xc7, 0x96, 0x7d, 0xf9, 0xfb, 0x1c, 0x86, 0x5f, 0x1c, 0x44,
	0xa6, 0x70, 0x71, 0x40, 0xa9, 0xb8, 0xa8, 0xa6, 0xc1, 0x2c, 0x98, 0x0f, 0x52, 0x7f, 0x25, 0x1f,
	0x20, 0xdc, 0x70, 0x89, 0x4c, 0x0b, 0xc9, 0x51, 0x4d, 0x7b, 0xb3, 0xfe, 0x3c, 0x5c, 0x44, 0xb1,
	0x77, 0xc6, 0x37, 0x27, 0xf2, 0x53, 0xa5, 0xe5, 0x31, 0xed, 0xca, 0xa3, 0x9f, 0x01, 0x84, 0x9f,
	0xb9, 0xbe, 0xde, 0x21, 0xdb, 0x8b, 0x46, 0x93, 0xa7, 0x30, 0x94, 0x58, 0x8b, 0xac, 0x91, 0x85,
	0x7d, 0x68, 0x94, 0x5e, 0x98, 0xfb, 0x37, 0x59, 0x90, 0x67, 0x30, 0xda, 0xa2, 0x66, 0x3b, 0xcb,
	0xf5, 0x2c, 0x37, 0xb4, 0x80, 0x21, 0x23, 0xe3, 0x3b, 0x70, 0x5b, 0x60, 0x7f, 0x16, 0xcc, 0xc7,
	0xe9, 0xdd, 0x9d, 0xbc, 0x80, 0xb1, 0x96, 0x94, 0xed, 0x79, 0x95, 0x67, 0x12, 0xb7, 0xd3, 0x33,
	0xeb, 0x0d, 0x3d, 0x96, 0xe2, 0x36, 0xfa, 0x13, 0x40, 0x78, 0xbd, 0x5a, 0xdf, 0xac, 0x29, 0xdb,
	0xd3, 0x1c, 0xc9, 0x2b, 0x78, 0xc4, 0x78, 0xbd, 0xc9, 0x14, 0xca, 0x03, 0xca, 0x4e, 0x35, 0x0f,
	0x0c, 0x7c, 0x6b, 0x51, 0xf3, 0xec, 0x1b, 0xb8, 0xb4, 0xba, 0xba, 0xf5, 0x65, 0x15, 0x2d, 0xd1,
	0xd5, 0x66, 0x3f, 0xe0, 0xbe, 0xf7, 0x95, 0x96, 0x48, 0xde, 0xc2, 0xe3, 0x7f, 0xb4, 0x35, 0xd5,
	0x1a, 0x65, 0x5b, 0xee, 0x28, 0x25, 0x1d, 0xf9, 0xba, 0x65, 0xc8, 0x1c, 0x26, 0xd6, 0xc1, 0x2b,
	0xa5, 0x69, 0xc5, 0x30, 0xe3, 0x1b, 0x5b, 0xfc, 0x38, 0x7d, 0x68, 0xf0, 0x95, 0x83, 0x57, 0x1b,
	0x13, 0xd1, 0x2a, 0xfd, 0x8c, 0x06, 0x6d, 0x44, 0x83, 0x7d, 0x6f, 0xa1, 0xa8, 0x80, 0xe1, 0x4a,
	0x89, 0x82, 0x6a, 0xdc, 0x90, 0x18, 0xae, 0xb8, 0x3b, 0xdf, 0x8f, 0x78, 0xe9, 0xa9, 0x53, 0xcc,
	0xe7, 0x30, 0x32, 0xc9, 0x54, 0x4d, 0x99, 0x8f, 0x77, 0x02, 0x08, 0x81, 0xb3, 0x1d, 0x55, 0x3b,
	0xd7, 0x77, 0x7b, 0x8e, 0x7e, 0x05, 0x30, 0xf2, 0x93, 0x3f, 0x92, 0x25, 0x8c, 0x73, 0xae, 0x33,
	0xe6, 0xa6, 0x6c, 0x1f, 0x0a, 0x17, 0x4f, 0x4e, 0x4b, 0xd2, 0x59, 0x81, 0x34, 0xcc, 0x3b, 0xfb,
	0xb0, 0x74, 0xc1, 0x5c, 0xd3, 0xdc, 0x7a, 0x75, 0x9c, 0x9d, 0xa9, 0xb5, 0x79, 0xfd, 0x08, 0x63,
	0x18, 0xfa, 0x20, 0xd3, 0xbe, 0x75, 0x91, 0x93, 0xcb, 0x77, 0x22, 0xbd, 0xd3, 0x44, 0xb7, 0x30,
	0xf9, 0x7f, 0x55, 0xc9, 0x04, 0xfa, 0x7b, 0x3c, 0xba, 0xbe, 0x98, 0x23, 0x79, 0x0d, 0x83, 0x03,
	0x2d, 0x9a, 0xb6, 0x0b, 0xe1, 0xe2, 0xea, 0xfe, 0x9e, 0x1f, 0xd3, 0x56, 0xf1, 0xbe, 0xb7, 0x0c,
	0x7e, 0x9c, 0xdb, 0x5f, 0xe9, 0xdd, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x58, 0x97, 0x70, 0xfa,
	0x8f, 0x03, 0x00, 0x00,
}
